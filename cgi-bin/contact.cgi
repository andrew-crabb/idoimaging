#!/usr/local/bin/perl
#
# contact.cgi - trial version
# 
######################################################################
#
# NOTE: this text file is the trial version of ContactForm.
# Save it to your computer then upload it to your server and
# name it "contact.cgi".  See full instructions here:
#
#	http://encodable.com/contactform/#instructions
# 
######################################################################
#
# NOTE: do not spend too much time customizing this trial version,
# because the full version replaces it completely.
# 
######################################################################
#
# DO NOT EDIT THIS FILE unless absolutely necessary; in most cases you
# should be editing contact_prefs.cgi instead.  If you do edit
# this file, be sure to make a backup copy first.
# 
######################################################################
#
# This program is the copyrighted work of Encodable Industries.
# Redistribution is prohibited, and copies are permitted only for
# backup purposes.  You are free to modify the program for your
# own use, but you may not distribute any modified copies of it.
#
# Use of this program requires a one-time license fee.  You can
# obtain a license here:
#
#	http://encodable.com/contactform/
#
# This software comes with no warranty.  It is our hope that you
# find it useful, but it comes with no guarantees.  Under no
# circumstances shall Encodable Industries be held liable in any
# situation arising from your use of this program.
#
# For help and support, please visit:
#
# http://encodable.com/contactform/#support


my $version = "1.74t";
use CGI::Carp 'fatalsToBrowser';
$ENV{PATH} = '/bin:/usr/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
($ENV{DOCUMENT_ROOT}) = ($ENV{DOCUMENT_ROOT} =~ /(.*)/); # untaint.
#$ENV{SCRIPT_NAME} = '/cgi-bin/contact.cgi';
use lib './perlmodules';
use lib "$ENV{DOCUMENT_ROOT}/cgi-bin/perlmodules";
use lib "$ENV{DOCUMENT_ROOT}/../cgi-bin/perlmodules";
my (%PREF,%TEXT) = ();









use strict;
use POSIX;
use Digest::MD5 'md5_hex';

sub printd;
sub die_nice;

my $qs = ();
load_prefs();


if($ENV{REQUEST_METHOD} !~ /post/i)
{
	start_html_output();

	print	  qq``
		. qq`\n$PREF{contact_page_title}`
		. qq`\n$PREF{contact_page_intro}`
		. qq`\n<form method="post" action="$ENV{SCRIPT_NAME}?$qs" id="thecontactform" onsubmit="return submitmessage()">`
		. qq`\n$PREF{form_wrapper_start}`
		. qq`\n`;

	if($PREF{custom_form_fields_code})
	{
		print $PREF{custom_form_fields_code};
	}
	else
	{
		foreach my $pref (sort keys %PREF)
		{
			if($pref =~ /^formfield_(\d+)_name$/)
			{
				my $num = $1;
				my $name = $PREF{$pref};

				my $colspan	= $PREF{"formfield_${num}_colspan"}		=~ /^(\d+)$/		? qq`colspan="$1"`	: undef;
				my $lclass	= $PREF{"formfield_${num}_label_classname"}	=~ /^(.+)$/		? $1			: 'label';
				my $fclass	= $PREF{"formfield_${num}_field_classname"}	=~ /^(.+)$/		? $1			: 'field';
				my $separator	= $PREF{"formfield_${num}_separator"}	=~ /^(.+)$/		? $1			: '</td><td class="field">';
				my $maxlength	= $PREF{"formfield_${num}_maxlength"}	=~ /^(\d+)$/		? $1			: 150;
				my $required	= $PREF{"formfield_${num}_required"}	=~ /no/i		? undef			: 'required';
				my $emailclass	= $PREF{"formfield_${num}_emailformat"}	=~ /yes/i		? 'emailformat'		: undef;

				$emailclass	= 'emailformat' if $name =~ /^$PREF{name_of_sender_field}$/i; # override the _emailformat PREF for this one.

				my $field = ();
				if($PREF{"formfield_${num}_type"} eq 'multiline')
				{
					my ($w,$h) = $PREF{"formfield_${num}_size"}		=~ /^(\d+)x(\d+)$/	? ($1,$2)	: ();
					$field = qq`<textarea class="default $fclass $required" name="$name" id="contact-$name" style="width: ${w}px; height: ${h}px;"></textarea>`;
				}
				elsif($PREF{"formfield_${num}_type"} eq 'dropdown'   &&   $name !~ /^$PREF{name_of_recipient_field}$/i)
				{
					my $presetvalue = ();
					$field = qq`<select name="$name" class="default $fclass $required" id="contact-$name">`;

					my @options = split(/\|\|\|/, $PREF{"formfield_${num}_displayed_values"});
					my @option_values = split(/\|\|\|/, $PREF{"formfield_${num}_submitted_values"});
					my $j = 0;
					foreach my $option (@options)
					{
						my $option_value = $option_values[$j] ? $option_values[$j] : $option;
						$field .= qq`<option value="$option_value"` . ($option_value eq $presetvalue ? ' selected="selected"' : undef) . qq`>$option</option>`;
						$j++;
					}

					$field .= qq`</select>`;
				}
				elsif($PREF{"formfield_${num}_type"} eq 'dropdown'   &&   $name =~ /^$PREF{name_of_recipient_field}$/i)
				{
					my $presetvalue = ();
					$field = qq`<select name="$name" class="default $fclass $required" id="contact-$name">`;

					my @options = split(/\|\|\|/, $PREF{"formfield_${num}_displayed_values"});
					my $j = 0;
					foreach my $option (@options)
					{
						$field .= qq`<option value="$option"` . ($option eq $presetvalue ? ' selected="selected"' : undef) . qq`>$option</option>`;
						$j++;
					}

					$field .= qq`</select>`;
				}
				elsif($PREF{"formfield_${num}_type"} eq 'none')
				{
					$field = undef;
				}
				else
				{
					$field = qq`<input type="text" class="default text $fclass $required $emailclass" name="$name" id="contact-$name" maxlength="$maxlength" />`;
				}

				print qq`\n<tr><td class="$lclass" $colspan>$PREF{"formfield_${num}_label"}$separator$field</td></tr>`;
			}
		}
	}

	print	  qq`\n`
		. qq`\n$PREF{submit_button}`
		. qq`\n$PREF{form_wrapper_end}`
		. qq`\n</form>`
		. qq`\n$PREF{contact_page_outro}`
		. qq`\n`;

	finish_html_output();
}
else
{
	print "Content-type: text/html\n\n";
	print qq`
		<html><head><title>ContactForm Trial Version</title></head><body><h1>ContactForm Trial Version</h1>
		<p>Thanks for trying ContactForm.&nbsp; Since this is only the trial version, no emails will
		be sent.&nbsp; Visit the <a href="http://encodable.com/contactform/">ContactForm homepage</a>
		to get the full version.</p>
		</body>
		</html>
	`;
	exit;
}











sub start_html_output
{
	return if $PREF{start_html_output_called};
	$PREF{start_html_output_called} = 1;

	my $title = shift || 'Contact';
	my $css = shift;
	my $js = shift;

	$css = get_css() unless $css eq 'no_css';
	$js = get_js() unless $js eq 'no_js';

	$PREF{title} = $PREF{"title_$PREF{on_page}"} if exists $PREF{"title_$PREF{on_page}"};

	print_http_headers();

	$PREF{outer_container} =~ s!%%(\w+?)%%!$PREF{$1}!g;
	$PREF{perpage_container} =~ s!%%(\w+?)%%!$PREF{$1}!g;

	if($ENV{REQUEST_METHOD} =~ /post/i   ||   $PREF{"print_full_html_tags_for_$PREF{on_page}"} =~ /yes/i   ||   ($PREF{print_full_html_tags} =~ /yes/i   &&   $PREF{"print_full_html_tags_for_$PREF{on_page}"} !~ /no/i)   ||   ($qs =~ /forcefullhtml=yes/))
	{
		print	  qq`<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">`
			. qq`\n<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">`
			. qq`\n<head>`
			. qq`\n<meta http-equiv="Content-type" content="text/html; charset=ISO-8859-1" />`
			. qq`\n<title>$title</title>`
			. qq`\n<script type="text/javascript">\n/* <![CDATA[ */  /* so (X)HTML validators ignore the javascript. */\n\n$js\n\n/* ]]> */  /* so (X)HTML validators ignore the javascript. */\n</script>`
			. qq`\n<style type="text/css">$css</style>`
			. $PREF{extra_header_output}
			. qq`\n</head>`
			. qq`\n<body id="cfbody" class="$PREF{on_page}body">`
			. qq`\n`;
	}
	elsif($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file})
	{
		$title = $PREF{title_for_template_file} unless $title;
		open(HEADERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
		my $infh = \*HEADERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		flock $infh, 1;
		seek $infh, 0, 0;
		while(<$infh>)
		{
			s!%%title%%!$title!g;
			s!%%js%%!<script type="text/javascript" src="$ENV{SCRIPT_NAME}?js"></script>!g;
			s!%%css%%!<link rel="stylesheet" type="text/css" media="all" href="$ENV{SCRIPT_NAME}?css">!g;

			if(/(.*)%%encodable_app_output%%/i)
			{
				print $1; last;
			}
			else
			{
				print $_;
			}
		}
		close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";

		print	  $PREF{extra_header_output};
		print	  qq`$PREF{outer_container}\n`;
	}
	else
	{
		print	  $PREF{extra_header_output};
		print	  qq`$PREF{outer_container}\n`;
	}


	print $PREF{"customcode_top_$PREF{on_page}"} if $PREF{"customcode_top_$PREF{on_page}_inside_perpage_container"} !~ /yes/i;
	print $PREF{title} if $PREF{title_inside_perpage_container} !~ /yes/i;

	print qq`\n$PREF{perpage_container}\n`; # this is #uploaderpage, #filelistpage, #defaultpage, etc.

	print $PREF{"customcode_top_$PREF{on_page}"} if $PREF{"customcode_top_$PREF{on_page}_inside_perpage_container"} =~ /yes/i;
	print $PREF{title} if $PREF{title_inside_perpage_container} =~ /yes/i;


	print qq`\n<div id="$PREF{main_container_css_id}">`;
}


sub finish_html_output
{
	print qq`\n<p class="pb"><a href="http://encodable.com/contactform/">ContactForm By Encodable</a></p>` unless $PREF{hide_poweredby} =~ /yes/i;
	print qq`\n</div>`;

	if($ENV{REQUEST_METHOD} =~ /post/i   ||   $PREF{"print_full_html_tags_for_$PREF{on_page}"} =~ /yes/i   ||   ($PREF{print_full_html_tags} =~ /yes/i   &&   $PREF{"print_full_html_tags_for_$PREF{on_page}"} !~ /no/i)   ||   ($qs =~ /forcefullhtml=yes/))
	{
		print	  $PREF{extra_footer_output};
		print	  qq`</body>\n</html>\n`;
	}
	elsif($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file})
	{
		print	  qq`$PREF{outer_container_end}\n`;
		print	  $PREF{extra_footer_output};

		open(FOOTERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
		my $infh = \*FOOTERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
		flock $infh, 1;
		seek $infh, 0, 0;
		my $found_token = 0;
		while(<$infh>)
		{
			if($found_token)
			{
				print $_;
			}
			elsif(/%%encodable_app_output%%(.*)/i)
			{
				print $1; $found_token = 1;
			}
		}
		close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";
	}
	else
	{
		print	  qq`$PREF{outer_container_end}\n`;
		print	  $PREF{extra_footer_output};
	}
}


sub do_contactform_error_reporting($$)
{
	my ($mail_sent_successfully, $error_msg) = @_;
	if(!$mail_sent_successfully)
	{
		die_nice qq`

			An error occurred while trying to send the message.&nbsp; This may be a
			temporary server problem, in which case you can try to send your message
			again by pressing your browser's Refresh/Reload button, or by going back
			to the previous page and resubmitting your message.
			<br /><br />

			If you receive this same error again, you may need to wait a half hour or
			so before trying again.
			<br /><br />

			<hr />
			<br />

			Technical details:
			<br /><br />

			$error_msg
		`;
	}
}


sub load_prefs()
{
	# Pre-init stuff.
	#
	if($ENV{QUERY_STRING} eq 'version') { print "Content-type: text/plain\n\n"; print "$version\n"; exit; }
	my ($cwd) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)/.*?$!);
	unless($cwd) { $cwd = $ENV{PATH_TRANSLATED}; $cwd =~ s![^/\\]+$!!; }
	chdir $cwd;
	$qs = $ENV{QUERY_STRING};
	$PREF{internal_appname} = 'contactform';



	# Fix the %ENV if necessary.
	#
	if(!$ENV{REQUEST_URI}) # IIS is crap.
	{
		$ENV{REQUEST_URI} = $ENV{PATH_INFO};
		$ENV{REQUEST_URI} .= '?' . $qs if $qs;
	}

	$PREF{DOCROOT}					= $ENV{DOCUMENT_ROOT}				unless exists $PREF{DOCROOT};
	if(!$PREF{DOCROOT})
	{
		($PREF{DOCROOT}) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)$ENV{SCRIPT_NAME}$!);
		if(!$PREF{DOCROOT})
		{
			# try to fix IIS garbage.
			my $path_translated = $ENV{PATH_TRANSLATED};
			$path_translated =~ s!\\\\!/!g;
			$path_translated =~ s!\\!/!g;
			($PREF{DOCROOT}) = ($path_translated =~ m!^(.+)$ENV{PATH_INFO}$!);
		}
		die "Error: couldn't set \$PREF{DOCROOT} from \$ENV{DOCUMENT_ROOT} ('$ENV{DOCUMENT_ROOT}'), \$ENV{SCRIPT_FILENAME} ('$ENV{SCRIPT_FILENAME}'), or \$ENV{PATH_TRANSLATED} ('$ENV{PATH_TRANSLATED}').\n" unless $PREF{DOCROOT};
	}



	# Load the external prefs.
	#
	my ($prefs_basename) = ($ENV{SCRIPT_NAME} =~ m!.*?[/\\]?([^/\\]+)\.[^/\\\.]+!);
	my @prefs_files = ("${prefs_basename}_prefs_new.cgi", "${prefs_basename}_prefs_new.pl", "${prefs_basename}_prefs.cgi", "${prefs_basename}_prefs.pl", "${prefs_basename}_prefs_extra.cgi", "${prefs_basename}_prefs_extra.pl");
	my $prefs_loaded = 0;
	foreach my $prefs_file (@prefs_files)
	{
		for($prefs_file, "$PREF{DOCROOT}/cgi-bin/$prefs_file", "$PREF{DOCROOT}/../cgi-bin/$prefs_file")
		{
			if(-e $_)
			{
				my $file = $_;
				my $prefs_contents = ();
				open(IN,"<$file") or die_nice("$PREF{internal_appname}: couldn't open prefs file '$file': $!");
				flock IN, 1;
				seek IN, 0, 0;
				while(<IN>) { $prefs_contents .= $_; }
				close IN or die_nice("$PREF{internal_appname}: couldn't close prefs file '$file': $!");
				$prefs_contents =~ /(.*)/s;
				$prefs_contents = $1; # cheap untaint since this is our own config file.
				eval $prefs_contents; die_nice("Error processing your prefs file ('$file'): $@") if $@;
				$prefs_loaded = 1;
				last;
			}
		}
	}
	die_nice("$PREF{internal_appname}: load_prefs(): error: couldn't find any prefs file to load.  You must put your ${prefs_basename}_prefs.cgi file on the server with the ${prefs_basename}.cgi file.") unless $prefs_loaded;

	if($PREF{show_errors_in_browser} =~ /yes/i)
	{
		use CGI::Carp 'fatalsToBrowser';
	}

	my @other_prefs_files = ();
	foreach my $num (sort keys %{$PREF{other_prefs_files}})
	{
		my $name = $PREF{other_prefs_files}{$num}{shortcut_name};
		if($qs =~ /(?:^|&)prefs=$name(?:&|$)/)
		{
			my $file = $PREF{other_prefs_files}{$num}{shortcut_target};
			if($PREF{other_prefs_files_are_in_docroot} =~ /yes/i)
			{
				$file = "$PREF{DOCROOT}/$file";
				condense_slashes('leave_leading_UNC', $file);
			}
			die_nice("$PREF{internal_appname}: prefs file '$file' does not exist.") unless -e $file;
			push @other_prefs_files, $file;
		}
	}
	if($PREF{enable_other_prefs_files_with_filename_on_URL} =~ /yes/i)
	{
		while($qs =~ /(?:^|&)prefsfile=(.+?)(?:&|$)/g)
		{
			my $file = $1;
			if($PREF{other_prefs_filenames_from_URL_can_contain_paths} =~ /yes/i)	{ $file = enc_untaint($file, 'keep_path');	}
			else									{ $file = enc_untaint($file);			}
			if($PREF{other_prefs_files_are_in_docroot} =~ /yes/i)
			{
				$file = "$PREF{DOCROOT}/$file";
				condense_slashes('leave_leading_UNC', $file);
			}
			die_nice("$PREF{internal_appname}: prefs file '$file' does not exist.") unless -e $file;
			push @other_prefs_files, $file;
		}
	}
	foreach my $prefs_file (@other_prefs_files)
	{
		my $prefs_contents = ();
		open(IN,"<$prefs_file") or die_nice("$PREF{internal_appname}: couldn't open prefs file '$prefs_file': $!");
		flock IN, 1;
		seek IN, 0, 0;
		while(<IN>) { $prefs_contents .= $_; }
		close IN or die_nice("$PREF{internal_appname}: couldn't close prefs file '$prefs_file': $!");
		$prefs_contents =~ /(.*)/s;
		$prefs_contents = $1; # cheap untaint since this is our own config file.
		eval $prefs_contents; die_nice("Error processing your prefs file: $@") if $@;
	}

	if($PREF{datadir_is_in_docroot} eq 'yes')
	{
		$PREF{datadir} = $PREF{DOCROOT} . $PREF{datadir};
	}
	if(! -d $PREF{datadir})
	{
		die_nice("Error: your settings for \$PREF{datadir} and \$PREF{datadir_is_in_docroot} \nresult in \$PREF{datadir} being set to '$PREF{datadir}', \nbut that path does not exist.\n");
	}

	die_nice("Error: the directory \$PREF{datadir}  ($PREF{datadir})  must be world-readable, but it isn't.\n") if ! -r $PREF{datadir};
	die_nice("Error: the directory \$PREF{datadir}  ($PREF{datadir})  must be world-writable, but it isn't.\n") if ! -w $PREF{datadir};

	#if(   ((my $mode = sprintf "%04o", ((stat( "$PREF{datadir}" ))[2] & $PREF{writable_dir_perms_mask_as_octal})) ne $PREF{writable_dir_perms_as_string})   &&   ($PREF{ignore_chmod_errors} !~ /yes/i)   )
	#{
	#	die_nice( qq`Error: the directory \$PREF{datadir}  ($PREF{datadir})  must be chmodded $PREF{writable_dir_perms_as_string}, but it's currently $mode.`
	#		. qq`\nIn rare cases, some servers may not report $PREF{writable_dir_perms_as_string} even though the folder is chmodded correctly.`
	#		. qq`\nIf you're SURE you've chmodded it to $PREF{writable_dir_perms_as_string} (for 0777 that's AKA a+rwx, or "world-readable, `
	#		. qq`\n-writable, and -executable"), then add    \$PREF{ignore_chmod_errors} = 'yes';    near the `
	#		. qq`\ntop of this script and try again.\n`);
	#}


	$PREF{protoprefix}	= 'http://' unless exists $PREF{protoprefix};
	$PREF{contact_log}	= 'contactlog.cgi' unless exists $PREF{contact_log};
	$PREF{time_log}		= 'contact_timelog.cgi' unless exists $PREF{time_log};
	$PREF{contact_log}	= $PREF{datadir} . '/' . $PREF{contact_log};
	$PREF{time_log}		= $PREF{datadir} . '/' . $PREF{time_log};
	s!/{2,}!/!g for ($PREF{contact_log}, $PREF{time_log});
	create_file_if_DNE($PREF{contact_log},0666);
	create_file_if_DNE($PREF{time_log},0666);


	create_formfield_prefs_for_custom_form_fields();


	if($qs eq 'js'   ||   $qs =~ /action=justjs/)
	{
		print "Content-type: text/javascript\n\n";
		print get_js();
		exit;
	}
	elsif($qs eq 'css'   ||   $qs =~ /action=justcss/)
	{
		print "Content-type: text/css\n\n";
		print get_css();
		exit;
	}
}


sub create_file_if_DNE
{
	my $file = shift;
	my $mode = shift;

	return if -T $file;
	open(NEW,">$file") or die "$0: couldn't create new file $file: $!\n";
	close NEW or die "$0: couldn't close $file after creating it: $!\n";
	if($mode)
	{
		chmod($mode,$file) or die "$0: couldn't chmod file \"$file\" with mode \"$mode\": $!\n";
	}
}


sub die_nice
{
	exit_with_error(@_);
}


sub exit_with_error
{
	my $msg = shift;
	print "Content-type: text/html\n\n";
	print qq`<html><head><title>Contact - Error - $ENV{HTTP_HOST}</title></head><body><h1>Error</h1><p>$msg</p></body></html>\n`;
	exit;
}


sub enc_untaint
{
	my $item = shift;
	my $original_item = $item;
	my $keep_path = shift;
	#print STDERR "enc_untaint($item)\n";

	# Regardless of whether we're keeping the path, dots surrounded by slashes are never allowed.
	#
	#$item =~ s!(^|/|\\)\.+(/|\\|$)!$1!g;
	$item =~ s!\\!/!g; # Need to remove MS garbage beforehand, otherwise an input like .\\StupidCGI.tmp will break this.
	while($item =~ m!((?:^|/|\\)\.+(?:/|\\|$))!)
	{
		$item =~ s!$1!/!;
	}

	#print STDERR "removed slashdots: $item\n";

	if(  $item =~ m!(/|\\)!  &&  !$keep_path)
	{
		$item =~ s!^.*[/\\]+([^/\\]+)!$1!; # remove any path from the front.
		#print STDERR "removed path from front: $item\n";
		$item =~ s!^([^/\\]+)[/\\]+!$1!; # ...and the back.
	}

	$item =~ s![`\*\?\|<>]!!g; # remove some other potentially-unsafe stuff.

	$item =~ s![/\\]{2,}!/!g; # condense any multiples.

	($item) = ($item =~ /(.*)/); # untaint.

	# In case anything slips through, die as a security precaution.
	#
	die qq`$0: couldn't untaint "$original_item".\n` if $item =~ m![/\\]! && !$keep_path;
	die qq`$0: couldn't untaint "$original_item".\n` if $item =~ m!(?:^|/|\\)\.+(?:/|\\|$)!;
	die qq`$0: couldn't untaint "$original_item".\n` if $item =~ m!^\.+$!;
	die qq`$0: couldn't untaint "$original_item".\n` if $item =~ m!^\s*$!;

	#print STDERR "untainted: $item\n\n";
	return $item;
}


sub enc_redirect
{
	my $destination = shift;

	unless($destination =~ m!^https?://!)
	{
		$destination = $PREF{protoprefix} . $ENV{HTTP_HOST} . $destination;
	}

	if($PREF{output_started})
	{
		print qq`<p>$PREF{internal_appname} warning: cannot redirect because output has already started (perhaps debug is enabled?).&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
	}
	elsif($PREF{we_are_virtual})
	{
		warn "$0: enc_redirect(): cannot redirect because we are virtual.\n";
		print_http_headers();
		print qq`<p>$PREF{internal_appname} warning: cannot redirect because we are virtual.&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
	}
	else
	{
		if($ENV{SERVER_SOFTWARE} =~ /microsoft-iis/i)
		{
			# A bug in IIS v5 (and lower, probably) makes cookie-setting fail
			# when combined with a header-based redirect:
			#
			#	"BUG: Set-Cookie Is Ignored in CGI When Combined With Location"
			#	http://support.microsoft.com/kb/q176113/
			#
			# So use a meta-redirect instead.
			#
			print "Content-type: text/html\n\n";
			print qq`<html><head><meta http-equiv="refresh" content="0;url=$destination"></head><body></body></html>\n`;
		}
		else
		{
			print "Location: $destination\n\n";
		}
	}

	exit;
}


sub condense_slashes
{
	s!\\!/!g;
	my $leave_leading_UNC = 0;
	for(@_)
	{
		if(/^leave_leading_UNC$/)
		{
			$leave_leading_UNC = 1;
			next;
		}
		if($leave_leading_UNC)
		{
			my $leading_UNC_slashes = '';
			if(m!^//!)
			{
				$leading_UNC_slashes = '//';
				s!^/+!!;
			}
			s!/{2,}!/!g; # condense any multiples.
			$_ = $leading_UNC_slashes . $_; # add back any UNC slashes.
		}
		else
		{
			s!/{2,}!/!g;
		}
	}
}


sub get_js
{

return qq`
function submitmessage()
{
	if(check_for_required_fields())
	{
		$PREF{custom_js_code__onsubmit}

		document.getElementById('thecontactform').submit();
	}
	else { return false; }
}

function check_for_required_fields()
{
	var onlyinputs = document.getElementById('thecontactform').getElementsByTagName('input');
	var selects = document.getElementById('thecontactform').getElementsByTagName('select');
	var textareas = document.getElementById('thecontactform').getElementsByTagName('textarea');
	var inputs = new Array;
	var i = 0;
	for(i = 0; i < onlyinputs.length; i++)
	{
		inputs[i] = onlyinputs[i];
	}
	var j = 0;
	for(j = 0; j < selects.length; j++)
	{
		inputs[i + j] = selects[j];
	}
	var k = 0;
	for(k = 0; k < textareas.length; k++)
	{
		inputs[i + j + k] = textareas[k];
	}

	var items_missing = 0;
	var email_format_incorrect = 0;

	for(i = 0; i < inputs.length; i++)
	{
		if(inputs[i].className.indexOf('required') != -1   &&   (inputs[i].value == '' || inputs[i].value == undefined))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			items_missing = 1;
		}
		else if(inputs[i].className.indexOf('emailformat') != -1   &&   !inputs[i].value.match( /.+\@.+\\..+/ ))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			email_format_incorrect = 1;
		}
		else
		{
			inputs[i].style.background	= inputs[i].type == 'radio' || inputs[i].type == 'checkbox' || inputs[i].type == 'button' || inputs[i].type == 'submit' ? 'transparent' : '$PREF{default_bgcolor_for_required_fields}';
			inputs[i].style.color		= '$PREF{default_textcolor_for_required_fields}';
		}
	}

	if(items_missing)
	{
		alert("Please fill in the required item(s).");
	}
	else if(email_format_incorrect)
	{
		alert("Please enter a valid email address.");
	}
	else
	{
		return 1;
	}

	return 0;
}

function schedule_onload_action(newfunc)
{
	var already_scheduled = window.onload;
	if(typeof window.onload != 'function')
	{
		window.onload = newfunc;
	}
	else
	{
		window.onload = function()
		{
			already_scheduled();
			newfunc();
		}
	}
}

$PREF{custom_js_code}
`;

}


sub get_css
{
	return $PREF{css};
}


sub create_formfield_prefs_for_custom_form_fields()
{
	my $i = 0;
	foreach my $fieldname (split(/\s*,\s*/, $PREF{custom_form_fields_namelist}))
	{
		my $seqnum = get_first_unused_formfield_sequence_number();
		$PREF{"formfield_${seqnum}_label"} = $fieldname;
		$PREF{"formfield_${seqnum}_name"} = $fieldname;
		$PREF{"formfield_${seqnum}_maxlength"} = $fieldname =~ /^$PREF{name_of_message_field}$/i ? $PREF{custom_form_fields_messagefield_maxlength} : $PREF{custom_form_fields_maxlength};
		$i++;
	}
}


sub get_first_unused_formfield_sequence_number()
{
	my $seqnum = 0;
	foreach my $pref (sort keys %PREF)
	{
		if($pref =~ /^formfield_(\d+)_name$/)
		{
			$seqnum = $1;
		}
	}
	$seqnum++;
	$seqnum = "0$seqnum" if $seqnum =~ /^\d$/;
	return $seqnum;
}


sub print_http_headers
{
	return if $PREF{output_started} || $PREF{xml_output_started};

	$PREF{output_started} = 1;

	# Don't print the P3P header from here normally, because we'll pick it up automatically
	# from the site's main .htaccess file.  The only time a script needs to explicitly
	# include it is when setting cookies (and possibly when delivering JS code which is
	# used to set cookies?).
	# 
	#print_p3p_header();

	my $noprint = shift;
	my $headers = '';
	$headers .= "Cache-Control: no-store, no-cache\n";
	$headers .= "Connection: close\n"; # workaround for a Safari bug that causes uploads to fail about 50% of the time.
	$headers .= "Content-type: text/html\n\n";
	$noprint ? return $headers : print $headers;
}


