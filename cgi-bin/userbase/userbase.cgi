#! /opt/local/bin/perl
#
# userbase.cgi
#
######################################################################
#
# DO NOT EDIT THIS FILE unless absolutely necessary; in most cases you
# should be editing userbase_prefs.cgi instead.  If you do edit this
# file, be sure to make a backup copy first.
# 
######################################################################
#
# This program is the copyrighted work of Encodable Industries.
# Redistribution is prohibited, and copies are permitted only for
# backup purposes.  You are free to modify the program for your
# own use, but you may not distribute any modified copies of it.
#
# Use of this program requires a one-time license fee.  You can
# obtain a license here:
#
#	http://encodable.com/userbase/
#
# This software comes with no warranty.  It is our hope that you
# find it useful, but it comes with no guarantees.  Under no
# circumstances shall Encodable Industries be held liable in any
# situation arising from your use of this program.
#
# For more information about this program, as well as for help
# and support, please visit the following pages:
#
# Homepage: http://encodable.com/userbase/
# Contact:  http://encodable.com/contact/


my $version = "2.38e01";
use CGI::Carp 'fatalsToBrowser';
$ENV{PATH} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};
($ENV{DOCUMENT_ROOT}) = ($ENV{DOCUMENT_ROOT} =~ /(.*)/); # untaint.
#$ENV{DOCUMENT_ROOT} = 'c:\some\dir'; # If autodetection fails, uncomment & set this.
#$ENV{SCRIPT_NAME} = '/cgi-bin/userbase.cgi'; # If autodetection fails, uncomment & set this.
use lib './perlmodules';
use lib '../cgi-bin/perlmodules';
use lib '../../cgi-bin/perlmodules';
use lib "$ENV{DOCUMENT_ROOT}/cgi-bin/perlmodules";
use lib "$ENV{DOCUMENT_ROOT}/../cgi-bin/perlmodules";
my (%PREF,%TEXT,%COOKIE) = ();
use Time::HiRes 'gettimeofday'; $PREF{script_start_time_highres} = gettimeofday();

my $debuglog = undef; 
# open($debuglog, ">>encdata/userbase/debuglog.ubtemp.log") or die_nice("couldn't open debuglog: $!\n"); flock $debuglog, 2; print $debuglog "\n\n";

use strict;
use DBI;
use Time::Local;
use Digest::MD5 'md5_hex';
use File::Copy;

sub printd;
sub die_nice;
sub enc_warn;
sub encdebug;
sub exit_with_error;

my $qs = '';





sub create_new_session_id
  {
    my $username = shift;
    my $password = shift;
    my $id = offsettime() . $$ . $PREF{ip} . $ENV{HTTP_USER_AGENT} . $username . $password;

    #$id =~ s/[^\d]//g;
    #$id = substr($id,0,85);
    $id = enc_hash($id);
    return $id;
  }


sub check_for_multiple_logins($$)
  {
    # This is to be called only at login, not at check_if_logged_in().

    my ($userid,$username) = @_;
    die_unless_numeric($userid,'userid');
    check_username_for_sql_safeness($username);
    my $old_login_time = enc_sql_select("SELECT `loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid;");
    if ($old_login_time =~ /[1-9]/   &&   !login_session_expired($old_login_time)) {
      if ($PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i) {
        if ($PREF{in_illegal_multilogon_dispute_which_user_gets_kicked} =~ /old/i) {
          # Kill all existing sessions for this username, and then return null, so
          # so that the current user's login can proceed and become the sole login
          # under this username.

          log_user_out_of_db($username, 'force');
          return '';
        } else {
          # Else the pref says the new user should get kicked, so just redirect him
          # to the appropriate error page, so his login never proceeds.

          enc_redirect("$PREF{login_url}?phase=emultlogin");
        }
      } else {
        my $existing_session_id = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
        return $existing_session_id;
      }
    }
  }


sub update_loggedin_count_for_this_user($)
  {
    my $userid = shift;
    die_unless_numeric($userid,'userid');
    my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers`=IFNULL(`numusers`,0)+1 WHERE `id` = '$userid';");
    die_nice("SQL returned '$success' instead of '1' while incrementing numusers column. (userid='$userid')") unless $success == 1;
  }


sub log_user_into_db
  {
    my ($userid, $my_session_id, $logintime, $restrict_ip) = @_;

    die_unless_numeric($userid,'userid');
    die_unless_numeric($logintime,'logintime');

    check_sessionid_for_sql_safeness($my_session_id);

    my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = $logintime, `mrsession` = '$my_session_id' WHERE `id` = '$userid';");
    die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while logging user in.") unless $success == 1;

    if ($restrict_ip) {
      my $ip = $PREF{ip};
      check_ip_for_sql_safeness($ip);

      unless (enc_sql_select("SELECT `ip` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq $ip) {
        my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `ip` = '$ip' WHERE `id` = '$userid';");
        die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while setting user IP.") unless $success == 1;
      }
    } else {
      unless (enc_sql_select("SELECT `ip` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq '') {
        my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `ip` = '' WHERE `id` = '$userid';");
        die_nice("Error: log_user_into_db('$userid', '$my_session_id', '$logintime', '$restrict_ip'): SQL returned '$success' instead of '1' while clearing user IP.") unless $success == 1;
      }
    }
  }


sub update_logins_table($$)
  {
    my ($userid, $session_id) = @_;
    my $timestamp = offsettime();

    check_id_for_sql_safeness($userid);
    check_sessionid_for_sql_safeness($session_id);
    die_unless_numeric($timestamp, 'timestamp');

    my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
    sql_untaint($ip, $host, $ua);
    die_unless_sqlsafe($ip, $host, $ua);

    enc_sql_insert("INSERT INTO `$PREF{logins_table}` (`user_id`, `session_id`, `timestamp`, `ip_address`, `hostname`, `browser`) VALUES('$userid', '$session_id', '$timestamp', '$ip', '$host', '$ua')");

    while (enc_sql_select("SELECT COUNT(*) FROM `$PREF{logins_table}` WHERE `user_id` = $userid") > $PREF{num_logins_to_log_per_user}) {
      my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{logins_table}` WHERE `user_id` = $userid");
      enc_sql_delete("DELETE FROM `$PREF{logins_table}` WHERE `timestamp` = $oldest AND `user_id` = $userid LIMIT 1");
    }
  }


sub update_failed_logins_table($$)
  {
    my ($input_username, $input_password) = @_;

    my $hashed_password = enc_hash($input_password);
    check_hashedpw_for_sql_safeness($hashed_password);

    my $timestamp = offsettime();
    die_unless_numeric($timestamp, 'timestamp');

    my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
    sql_untaint($input_username, $ip, $host, $ua);
    die_unless_sqlsafe($input_username, $ip, $host, $ua);

    enc_sql_insert("INSERT INTO `$PREF{failed_logins_table}` (`username`, `password_fingerprint`, `timestamp`, `ip_address`, `hostname`, `browser`) VALUES('$input_username', '$hashed_password', '$timestamp', '$ip', '$host', '$ua')");

    while (enc_sql_select("SELECT COUNT(*) FROM `$PREF{failed_logins_table}` WHERE `username` = '$input_username'") > $PREF{num_failed_logins_to_log_per_user}) {
      my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{failed_logins_table}` WHERE `username` = '$input_username'");
      enc_sql_delete("DELETE FROM `$PREF{failed_logins_table}` WHERE `timestamp` = $oldest AND `username` = '$input_username' LIMIT 1");
    }
  }


sub update_password_activity_table
  {
    my ($user_id,$hashed_password,$salt,$id_of_user_performing_update) = @_;

    # $id_of_user_performing_update is zero if the update is during the
    # initial account creation, or if it's due to a password reset.

    die_unless_numeric($user_id, 'user_id');
    die_unless_numeric($id_of_user_performing_update, 'id_of_user_performing_update');
    check_hashedpw_for_sql_safeness($hashed_password);
    check_salt_for_sql_safeness($salt);

    my $timestamp = offsettime();
    die_unless_numeric($timestamp, 'timestamp');

    my ($ip, $host, $ua) = ($PREF{ip}, $PREF{host}, $ENV{HTTP_USER_AGENT});
    sql_untaint($ip, $host, $ua);
    die_unless_sqlsafe($ip, $host, $ua);

    enc_sql_insert("INSERT INTO `$PREF{password_activity_table}` (`user_id`, `password_fingerprint`, `salt`, `timestamp`, `user_who_did_update`, `ip_address`, `hostname`, `browser`) VALUES('$user_id', '$hashed_password', '$salt', '$timestamp', '$id_of_user_performing_update', '$ip', '$host', '$ua')");

    while (enc_sql_select("SELECT COUNT(*) FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id'") > $PREF{num_pw_updates_to_log_per_user}) {
      my $oldest = enc_sql_select("SELECT MIN(`timestamp`) FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id'");
      enc_sql_delete("DELETE FROM `$PREF{password_activity_table}` WHERE `timestamp` = $oldest AND `user_id` = '$user_id' LIMIT 1");
    }
  }


sub make_sure_new_password_is_not_a_repeat
  {
    my ($user_id,$new_password) = @_;

    my $limit = $PREF{prevent_pw_reuse_for_this_many_pw_changes};
    if ($limit =~ /^\d+$/ && $limit > 0) {
      die_unless_numeric($user_id, 'user_id');
      my $old_passwords = enc_sql_select_multi("SELECT `password_fingerprint`,`salt` FROM `$PREF{password_activity_table}` WHERE `user_id` = '$user_id' ORDER BY `timestamp` DESC LIMIT $limit");
      foreach my $i (keys %$old_passwords) {
        exit_with_error($TEXT{password_reuse_error}) if salt_and_crypt_password($new_password,$$old_passwords{$i}{salt}) eq $$old_passwords{$i}{password_fingerprint};
      }
    }
  }


sub determine_default_login_destination
  {
    my $ref = shift;
    my $go = ();
    if ($qs =~ /(?:^|&)whence=(.+)/) {
      # don't URL-decode here because this is getting passed right
      # to the Location: header, which requires URL encoding.

      $go = $1;
      if ($qs =~ /(?:^|&)encanchor=([^&]+)(?:&|$)/) {
        $go .= '#' . $1;
      }
    } elsif ($ref) {
      $go = $ref;

      if ($go =~ m!.*whence=(https?(://|%3a%2f%2f).+)!i) {
        $go = $1;
        enc_urldecode($go);
      }

      if ($go =~ /(log(ged)?out|smsg=|kmsg=|rslt=)/   ||   $go =~ /(action=signup|action=verify|action=pwreset|action=confirmpayment|phase=\w+)/   ||   $go !~ m!^https?://(www\.)?$ENV{HTTP_HOST}!) {
        # If the page we were on before was a logout page, or if it was an external
        # site, or if it was one of various other internal pages that don't make
        # sense to redirect to, then just return to the login frontpage.
        #
        $go = $PREF{login_url};
      }
    } else {
      $go = $PREF{login_url};
    }
    $go =~ s!_THEQS_!?!g; $go =~ s!_ANAMP_!&!g;
    return $go;
  }


sub prompt_for_login()
  {
    $PREF{on_page} = 'login';
    printd "prompt_for_login()";

    # don't urldecode here, because it's just going right back onto the URL.
    my $whence = $qs =~ /(?:^|&)whence=(.+)/ ? "&whence=$1" : undef;
    if ($qs =~ /(?:^|&)encanchor=([^&]+)(?:&|$)/) {
      $whence = "&encanchor=$1" . $whence;
    }

    my $rememberme_checkbox = $PREF{enable_rememberme_checkbox} =~ /yes/i && !$PREF{idle_timeout};
    my $restrictip_checkbox = $PREF{enable_ip_address_restriction} =~ /yes/i && $PREF{force_ip_address_restriction} !~ /yes/;

    my $message = '';
    if ($qs =~ /(?:^|&)phasemsg=(.+?)(?:&|$)/) {
      $message = $1; enc_urldecode($message); $message = qq`<div id="formmessage">$message</div>\n`;
    }

    my $template = $qs =~ /format=mini/ ? $PREF{login_form_template__mini} : $PREF{login_form_template};
    $template =~ s/%%whence%%/$whence/g;
    $template =~ s/%%loginreturn%%/get_qs_var('loginreturn')/eg;
    $template =~ s!%%special_message%%!$message!g;
    $template =~ s!%%%if-rememberme%%%(.+)%%%end-rememberme%%%!$rememberme_checkbox ? $1 : ''!egs;
    $template =~ s!%%%if-restrictip%%%(.+)%%%end-restrictip%%%!$restrictip_checkbox ? $1 : ''!egs;
    $template = interpolate_userbase_variables($template);

    print_http_headers();
    start_html_output("Login") unless $qs =~ /format=mini/;
    print $template unless $qs =~ /null_if_logged_out/;
    finish_html_output() unless $qs =~ /format=mini/;
  }


sub user_has_addmember_rights
  {
    return user_is_allowed_to($PREF{logged_in_userid}, 'create_user_accounts') || logged_in_user_is_subgroup_manager();
  }


sub user_has_addadmin_rights
  {
    return user_is_allowed_to($PREF{logged_in_userid}, 'create_admin_accounts');
  }


sub export_users_to_CSV_file
  {
    exit_with_needprivs() unless user_is_allowed_to('export_accounts');
    my $datetime_format = $PREF{datetime_format_for_account_export} || $PREF{global_datetime_format} || '%Y%m%d-%H:%M:%S';

    if ($qs =~ /final=yes/i) {
      my $output = '';
      my %options = ();
      my @fields = ();
      while ($qs =~ /(?:^|&)(\w+)=on/ig) {
        my $field = $1;
        if ($field =~ /^(doublequoteallfields|includeadmins|downloadablefile)$/i) {
          $options{$1} = 1; next;
        }
        push @fields, $field;
      }
      my $csvcommareplacement = get_qs_var('csvcommareplacement');
      my $csvnewlinereplacement = get_qs_var('csvnewlinereplacement');

      my @output = ();
      foreach my $field (@fields) {
        push(@output, $options{doublequoteallfields} ? qq`"$field"` : $field);
      }
      $output .= join(",", @output) . "\n";

      my $fieldlist = join ",", @fields; # note: this is SQL-safe because of the regex in the while() above.
      my $data = enc_sql_select_multi("SELECT $fieldlist FROM `$PREF{user_table}`");
      foreach my $j (sort { $a <=> $b } keys %$data) {
        next if is_admin($$data{$j}{id}) && !$options{includeadmins};
        @output = ();
        foreach my $field (@fields) {
          $$data{$j}{$field} =~ s!,!$csvcommareplacement!g if $csvcommareplacement;
          $$data{$j}{$field} =~ s!\n!$csvnewlinereplacement!gs if $csvnewlinereplacement;
          $$data{$j}{$field} = strftime($datetime_format, localtime($$data{$j}{$field})) if $$data{$j}{$field} && $field =~ /^(lastactive)$/;
          push(@output, $options{doublequoteallfields} ? qq`"$$data{$j}{$field}"` : $$data{$j}{$field});
        }
        $output .= join(",", @output) . "\n";
      }

      if ($options{downloadablefile}) {
        my $filename = 'Exported_UserBase_accounts_' . strftime("%Y%m%d-%H%M%S",localtime(offsettime())) . '.csv';
        select STDOUT; $| = 1;
        print	  qq`Content-Type: application/octet-stream\n`
          . qq`Content-Disposition: attachment; filename="$filename"\n`
            . qq`Content-Length: ` . length($output) . qq`\n`
              . qq`Content-Description: Downloadable File\n\n`;
      } else {
        print "Content-type: text/plain\n\n";
      }

      print $output;
    } else {
      start_html_output();

      print qq`

		<h1 class="pagetitle">Export Users To CSV File</h1>
		<h3>Choose Fields To Export</h3>
		<form name="ub_csv_export" id="ub_csv_export" method="get" action="$ENV{SCRIPT_NAME}">
		<input type="hidden" name="action" value="csvexport" />
		<input type="hidden" name="final" value="yes" />
		<p>Note: for security purposes, UserBase does not store raw passwords; it only stores
		hashed passwords.&nbsp; Therefore raw passwords cannot ever be retrieved nor exported.</p>
		<table><tr>
		`;

      my (@builtin_fields, @custom_fields) = ();
      foreach my $field (split(/,/, get_db_colnames($PREF{user_table}))) {
        is_builtin_fieldname($field) ? push(@builtin_fields, $field) : push(@custom_fields, $field);
      }

      print qq`<th class="left">Built-In Fields:</th>\n<th>Custom Fields:</th>\n</tr>\n<tr>\n`;

      print qq`<td class="left">\n`;
      foreach my $field (@builtin_fields) {
        #my $checked = $field =~ /^(password|salt)$/i ? '' : qq`checked="checked"`;
        my $checked = $field =~ /^(id|username|name|email)$/i ? qq`checked="checked"` : '';
        print qq`<input type="checkbox" name="$field" id="ub_export_$field" $checked /><label for="ub_export_$field">$field</label><br />\n`;
      }
      print qq`(none)` unless @builtin_fields;

      print qq`\n</td>\n<td>\n`;
      foreach my $field (@custom_fields) {
        print qq`<input type="checkbox" name="$field" id="ub_export_$field" checked="checked" /><label for="ub_export_$field">$field</label><br />\n`;
      }
      print qq`(none)` unless @custom_fields;

      print qq`
		</td></tr></table>

		<table>
		<tr><th>Options:</th></tr>
		<tr><td><input type="checkbox" name="includeadmins" id="includeadmins" /><label for="includeadmins">Include administrator accounts</label></td></tr>
		<tr><td><input type="checkbox" name="doublequoteallfields" id="doublequoteallfields" /><label for="doublequoteallfields">Double-quote all fields</label></td></tr>
		<tr><td><input type="checkbox" name="downloadablefile" id="downloadablefile" /><label for="downloadablefile">Download CSV instead of displaying in browser</label></td></tr>
		<tr><td>Replace commas in data with:<br /><input type="text" name="csvcommareplacement" id="csvcommareplacement" value="THIS_IS_A_REAL_COMMA" /> (null to disable)</td></tr>
		<tr><td>Replace newlines in data with:<br /><input type="text" name="csvnewlinereplacement" id="csvnewlinereplacement" value="THIS_IS_A_REAL_NEWLINE" /> (null to disable)</td></tr>
		</table>

		<br /><input type="submit" name="ub_csv_submit" id="ub_csv_submit" value="Export CSV File" />
		</form>

		`;

      finish_html_output();
    }
  }


sub import_users_from_CSV_file
  {
    exit_with_needprivs() unless user_is_allowed_to('import_accounts');

    if ($ENV{REQUEST_METHOD} =~ /post/i) {
      my $upload_field_name = "ub_csv_filename";
      my $query = new CGI;
      my $filename = $query->param($upload_field_name);
      # die_nice qq`Made it to here, filename $filename`;

      $filename = lc($filename) unless $PREF{dont_convert_upload_filenames_to_lowercase} =~ /yes/i;
      $filename =~ s!.*?([^/\\]+)$!$1!;	# remove any path.
      $filename =~ s!\.{2,}!.!g;        # condense any multi-dots.
      $filename =~ s![^\w\.-]!_!g; # remove any unusual stuff including spaces.

      my ($file_base,$file_ext) = ($filename =~ /(.+)\.(.+)/);
      die_nice qq`File base name must not be null.` unless $file_base;
      die_nice qq`File extension must be "csv" but it's "$file_ext".` unless $file_ext =~ /^csv$/i;
      $file_base .= '.ubcsvimport';

      my $path = $PREF{datadir}; $path .= '/' unless $path =~ m!/$!;

      my $spacer = $file_base =~ / / ? ' ' : '_';
      my $file_base_serialized = $file_base;
      my $i = 0;
      while (-e "$path$file_base_serialized.$file_ext") {
        $i++;
        my $j = $i < 10 ? "0$i" : $i;
        $file_base_serialized = $file_base . $spacer . $j;
      }
      $file_base = $file_base_serialized;
      $filename = $file_base . '.' . $file_ext;

      my $uploadfile = "$path$filename";
      # print "uploadfile = $uploadfile<br>\n";
      my $upload_filehandle = $query->upload($upload_field_name);
      open(UPLOADFILE,">$uploadfile") or die_nice "couldn't create file '$uploadfile': $!\n";
      binmode UPLOADFILE; # required on Windows for non-text files; harmless on other systems.
      while (<$upload_filehandle>) {
        print UPLOADFILE;
      }
      close UPLOADFILE or die_nice "couldn't close file '$uploadfile': $!\n";
      chmod $PREF{writable_file_perms}, $uploadfile;

      enc_redirect("$PREF{login_url}?action=csvimport&csvfile=$filename");
    } elsif (my $csvfile = get_qs_var('csvfile')) {
      # print "csvfile = $csvfile<br>\n";
      $csvfile = enc_untaint($csvfile); my $csvfile_withpath = $PREF{datadir} =~ m!/$! ? "$PREF{datadir}$csvfile" : "$PREF{datadir}/$csvfile";
      exit_with_error qq`The specified CSV file does not exist.` unless -e $csvfile_withpath;

      my %options = ();
      my @option_controls = ();
      foreach my $opt ('strip_leading_spaces', 'strip_trailing_spaces', 'strip_surrounding_quotes') {
        $options{$opt} = get_qs_var($opt) =~ /no/i ? 'no' : 'yes';

        my $opt_nice = $opt; $opt_nice =~ s!_! !g; $opt_nice =~ s!^(\w)!\U$1!;
        push (@option_controls, qq`$opt_nice:&nbsp;<select name="$opt">
				<option value="yes"` . ($options{$opt} eq 'yes' ? qq` selected="selected"` : '') . qq`>yes</option>
				<option value="no"`  . ($options{$opt} eq 'no'  ? qq` selected="selected"` : '') . qq`>no</option>
				</select>
			`);
      }

      my (%data, %fieldnames, @fieldnames) = ();
      open(my $infh, $csvfile_withpath) or die_nice qq`Couldn't open CSV file '$csvfile' for reading: $!\n`;
      flock $infh, 1;
      seek $infh, 0, 0;
      my $linenum = 0;
      while (my $line = <$infh>) {
        chomp $line;
        next if $line =~ /^(\s*#|\s*)$/;
        $linenum++;
        my $fieldnum = 0;
        foreach my $value (split(/,/, $line)) {
          $value = ($value =~ m!^("+)(.*)\1$!)[1] if $options{strip_surrounding_quotes} =~ /yes/i && $value =~ m!^("+)(.*)\1$!;
          $value =~ s!^\s*!! if $options{strip_leading_spaces} =~ /yes/i;
          $value =~ s!\s*$!! if $options{strip_trailing_spaces} =~ /yes/i;

          if ($linenum == 1) {
            $value = lc($value);
            $value =~ s!\W+!_!g;
            defooify('_', $value); # clean up fieldnames regardless of what the user specifies.
            push @fieldnames, $value;
            $fieldnames{$value} = 1;
          } else {
            $data{$linenum}{ $fieldnames[$fieldnum] } = $value;
          }
          $fieldnum++;
        }

        # TODO: the above foreach() will interpret incorrectly any field where the actual data contains a comma.
        #while($line =~ m!!g)
        #{
        #}
      }
      close $infh or die_nice qq`Couldn't close CSV file '$csvfile' after reading: $!\n`;



      my ($unfield,$pwfield,$rnfield,$emfield,$grfield) = ();

      if ($PREF{fixed_username_field_for_CSV_import} && $fieldnames{$PREF{fixed_username_field_for_CSV_import}}) { 
        $unfield = $PREF{fixed_username_field_for_CSV_import}; 
      } else { 
        $unfield = get_qs_var("unfield"); 
      }

      if ($PREF{fixed_password_field_for_CSV_import} && $fieldnames{$PREF{fixed_password_field_for_CSV_import}}) {
        $pwfield = $PREF{fixed_password_field_for_CSV_import};
      } else {
        $pwfield = get_qs_var("pwfield");
      }

      if ($PREF{fixed_realname_field_for_CSV_import} && $fieldnames{$PREF{fixed_realname_field_for_CSV_import}}) {
        $rnfield = $PREF{fixed_realname_field_for_CSV_import};
      } else {
        $rnfield = get_qs_var("rnfield");
      }

      if ($PREF{fixed_email_field_for_CSV_import} && $fieldnames{$PREF{fixed_email_field_for_CSV_import}}) {
        $emfield = $PREF{fixed_email_field_for_CSV_import};
      } else {
        $emfield = get_qs_var("emfield");
      }

      if ($PREF{fixed_groups_field_for_CSV_import} && $fieldnames{$PREF{fixed_groups_field_for_CSV_import}}) {
        $grfield = $PREF{fixed_groups_field_for_CSV_import};
      } else {
        $grfield = get_qs_var("grfield");
      }



      # Make sure the list of field names from the CSV file doesn't contain any
      # new (non-existent) nor built-in fields.  But we make an exception for
      # our default fields (username, password, realname, email, groups), because we
      # aren't going to use whatever fieldnames are in the CSV file for those
      # fields -- we're just going to map them to our built-in field names.
      #
      # Note also that get_sqlsafe_custom_field_values(), which takes %data as
      # an argument here, will automatically skip any built-in or non-existent
      # fields in the input (since it just loops over the actual column names
      # from the live custom fields table), so there's no harm in passing %data
      # into it which contains such fields.
      #
      my (@new_fields,@reserved_fields,@errors) = ();
      foreach my $field (@fieldnames) {
        next if $field =~ /^($unfield|$pwfield|$rnfield|$emfield|$grfield)$/;
        push (@new_fields, $field) unless db_column_exists($field, $PREF{user_table});
        push (@reserved_fields, $field) if is_builtin_fieldname($field);
      }



      if ($qs =~ /final=yes/) {
        exit_with_error(qq`Cannot proceed with import because these fields do not exist: <br /><br />` . join ", ", @new_fields) if @new_fields;
        exit_with_error(qq`Cannot proceed with import because these field names are reserved: <br /><br />` . join ", ", @reserved_fields) if @reserved_fields;

        delete_all_nonadmin_accounts() if get_qs_var('delete_all_nonadmins') eq 'yes';

        my $accounts_imported = 0;
        my (%failed_imports, %other_errors) = ();
        foreach my $row (sort { $a <=> $b } keys %data) {
          my $user		= $data{$row}{$unfield};
          my $pass		= $data{$row}{$pwfield};
          my $realname		= $data{$row}{$rnfield};
          my $email		= $data{$row}{$emfield};
          my $groups		= $data{$row}{$grfield};

          $user = lc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
          $user = uc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;

          my $salt		= create_random_salt($PREF{salt_length});
          my $crypted_pass	= salt_and_crypt_password($pass,$salt);

          if (!realname_is_valid($realname) && $realname) { 
            $failed_imports{$row} = $TEXT{messages}{einvldr};
          } elsif (!emailaddr_is_valid($email) && $email) { 
            $failed_imports{$row} = $TEXT{messages}{einvlde};
          } elsif (!emailaddr_is_valid($user) && $PREF{usernames_must_be_email_addresses} =~ /yes/i) { 
            $failed_imports{$row} = $TEXT{messages}{einvlde};
          } elsif (!password_is_valid($pass)) { 
            $failed_imports{$row} = $TEXT{messages}{einvldp};
          } elsif (!hashedpw_is_valid($crypted_pass)) { 
            $failed_imports{$row} = $TEXT{messages}{einvldh};
          } elsif (!username_is_valid($user)) { 
            $failed_imports{$row} = $TEXT{messages}{ebadname};
          } elsif ( username_is_taken($user)) { 
            $failed_imports{$row} = $TEXT{messages}{edupuser};
          } elsif ( $email && email_address_is_taken($email)) { 
            $failed_imports{$row} = $TEXT{messages}{edupemail};
          }

          foreach my $groupname (split(/:/, $groups)) {
            $failed_imports{$row} = $TEXT{messages}{einvldg} unless groupname_is_valid($groupname);
            $failed_imports{$row} = $TEXT{messages}{egrpdne} unless group_exists($groupname);
            $failed_imports{$row} =~ s!%%group%%!$groupname!g;
          }

          my ($custfields_error, $customfields_sqlsafe) = get_sqlsafe_custom_field_values(undef, \%{$data{$row}});
          $failed_imports{$row} = $custfields_error if $custfields_error;

          if ($failed_imports{$row}) {
            die_nice qq`import_from_csf: row $row, data $failed_imports{$row}`;
            # next;
          }

          my ($pending_email_verification, $pending_admin_approval, $pending_payment, $token) = (0,0,0, '');
          my $new_user_id = add_new_user($user, $crypted_pass, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $token);
          $accounts_imported++;

          # My change ahc.
          ## send_welcome_email($new_user_id,$user,$pass,$email,$realname) unless $signup;
          # my change ahc.  Remove this one and use the one 20 lines below.
          start_html_output();

          foreach my $groupname (split(/:/, $groups)) {
            add_user_to_group($user, $groupname);
          }

          foreach my $customfield (keys %$customfields_sqlsafe) {
            unless($new_user_id =~ /^\d+$/)
              {
                $other_errors{$row} = qq`After creating new account, the returned user ID is not numeric; it is "$new_user_id".`;
                last;
              }
            my $value = $$customfields_sqlsafe{$customfield}{value};
            unless ($value eq enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = $new_user_id")) {
              my $statement = "UPDATE `$PREF{user_table}` SET `$customfield` = '$value' WHERE `id` = $new_user_id";
              my $success = enc_sql_update($statement);
              $other_errors{$row} = "Error: SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]" unless $success == 1;
            }
          }

          create_filechucker_userdir($new_user_id,$user,$realname,$email);
        }
        # my change ahc
        # start_html_output();

        print qq`
			<h1 class="pagetitle">Import Users From CSV File</h1>
			<h3>Imported $accounts_imported account(s) successfully.</h3>
			`;

        if (%failed_imports) {
          print qq`<h3>Failed to import these accounts (` . (scalar keys %failed_imports) . qq`):</h3>`;
          print qq`<br />\n<div id="ub_csv_failed_imports" class="enc_tbl">\n<table>\n<tr class="headers">\n<th>Error</th>\n`;
          print qq`<th>$_</th>\n` for @fieldnames;
          print qq`</tr>\n`;
          my $oddeveni = 1;
          foreach my $row (sort { $a <=> $b } keys %failed_imports) {
            print qq`<tr class="` . oddeven($oddeveni) . qq`">`;
            print qq`<td>$failed_imports{$row}</td>\n`;
            foreach my $field (@fieldnames) {
              print qq`<td>$data{$row}{$field}</td>\n`;
            }
            print qq`</tr>\n`;
          }
          print qq`\n</table>\n</div>\n`;
        }

        if (%other_errors) {
          print qq`<h3>These accounts were imported, but errors occurred while processing some of their fields (` . (scalar keys %other_errors) . qq`):</h3>`;
          print qq`<br />\n<div id="ub_csv_other_errors" class="enc_tbl">\n<table>\n<tr class="headers">\n<th>Error</th>\n`;
          print qq`<th>$_</th>\n` for @fieldnames;
          print qq`</tr>\n`;
          my $oddeveni = 1;
          foreach my $row (sort { $a <=> $b } keys %other_errors) {
            print qq`<tr class="` . oddeven($oddeveni) . qq`">`;
            print qq`<td>$other_errors{$row}</td>\n`;
            foreach my $field (@fieldnames) {
              print qq`<td>$data{$row}{$field}</td>\n`;
            }
            print qq`</tr>\n`;
          }
          print qq`\n</table>\n</div>\n`;
        }

        finish_html_output();
      } else {
        start_html_output();
        print qq`
			<h1 class="pagetitle">Import Users From CSV File</h1>
			<h3>Step 2: Choose CSV Processing Options</h3>
			<form method="get" name="ub_csv_import_step2" id="ub_csv_import_step2" action="$PREF{login_url}">
			<input type="hidden" name="action" value="csvimport" />
			<input type="hidden" name="csvfile" value="$csvfile" />
			<table>
			<tr><td>
			`;

        print join "<br /><br />\n", @option_controls;
        print "</td>\n<td>\n";


        if ($PREF{fixed_username_field_for_CSV_import}) {
          print qq`Username field: $PREF{fixed_username_field_for_CSV_import} <input type="hidden" name="unfield" value="$unfield" />`;
          unless ($fieldnames{$PREF{fixed_username_field_for_CSV_import}}) {
            print qq` (error: not in CSV file)`;
            push @errors, qq`You've set \$PREF{fixed_username_field_for_CSV_import} to '$PREF{fixed_username_field_for_CSV_import}' but there's no such field in the CSV file.`;
          }
        } else {
          print qq`Username&nbsp;field:&nbsp;<select name="unfield">\n`;
          print qq`<option></option>\n`;
          print qq`<option` . ($_ eq $unfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
          print qq`</select>`;
        }
        print qq`<br /><br />\n`;


        if ($PREF{fixed_password_field_for_CSV_import}) {
          print qq`Password field: $PREF{fixed_password_field_for_CSV_import} <input type="hidden" name="pwfield" value="$pwfield" />`;
          unless ($fieldnames{$PREF{fixed_password_field_for_CSV_import}}) {
            print qq` (error: not in CSV file)`;
            push @errors, qq`You've set \$PREF{fixed_password_field_for_CSV_import} to '$PREF{fixed_password_field_for_CSV_import}' but there's no such field in the CSV file.`;
          }
        } else {
          print qq`Password&nbsp;field:&nbsp;<select name="pwfield">\n`;
          print qq`<option></option>\n`;
          print qq`<option` . ($_ eq $pwfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
          print qq`</select>`;
        }
        print qq`<br /><br />\n`;


        if ($PREF{use_builtin_realname_field} =~ /yes/i) {
          if ($PREF{fixed_realname_field_for_CSV_import} && $fieldnames{$PREF{fixed_realname_field_for_CSV_import}}) {
            print qq`Realname field: $PREF{fixed_realname_field_for_CSV_import} <input type="hidden" name="rnfield" value="$rnfield" />`;
          } else {
            print qq`Realname&nbsp;field:&nbsp;<select name="rnfield">\n`;
            print qq`<option></option>\n`;
            print qq`<option` . ($_ eq $rnfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
            print qq`</select>`;
          }
          print qq`<br /><br />\n`;
        }


        if ($PREF{use_builtin_email_field} =~ /yes/i) {
          if ($PREF{fixed_email_field_for_CSV_import} && $fieldnames{$PREF{fixed_email_field_for_CSV_import}}) {
            print qq`Email field: $PREF{fixed_email_field_for_CSV_import} <input type="hidden" name="emfield" value="$emfield" />`;
          } else {
            print qq`Email&nbsp;field:&nbsp;<select name="emfield">\n`;
            print qq`<option></option>\n`;
            print qq`<option` . ($_ eq $emfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
            print qq`</select>`;
          }
          print qq`<br /><br />\n`;
        }


        if ($PREF{fixed_groups_field_for_CSV_import} && $fieldnames{$PREF{fixed_groups_field_for_CSV_import}}) {
          print qq`Groups field: $PREF{fixed_groups_field_for_CSV_import} <input type="hidden" name="grfield" value="$grfield" />`;
        } else {
          print qq`Groups&nbsp;field:&nbsp;<select name="grfield">\n`;
          print qq`<option></option>\n`;
          print qq`<option` . ($_ eq $grfield ? qq` selected="selected"` : '') . qq`>$_</option>\n` for @fieldnames;
          print qq`</select>`;
        }
        print qq`<br /><br />\n`;


        print qq`</td></tr>\n`;

        print qq`<tr class="single_item_row"><td colspan="2">Delete all existing non-admin accounts before import: <select name="delete_all_nonadmins">`
          . qq`<option` . (get_qs_var('delete_all_nonadmins') eq 'no'  ? qq` selected="selected"` : '') . qq`>no</option>`
            . qq`<option` . (get_qs_var('delete_all_nonadmins') eq 'yes' ? qq` selected="selected"` : '') . qq`>yes</option>`
              . qq`</select>\n<br /><br />\n</td></tr>\n`;

        print qq`<tr class="submit_button_row"><td colspan="2">
			
			Passwords in your CSV file must be literal, plain-text passwords.<br /><br />
			
			Any groups in your CSV file must be separated by colons; imported accounts<br />
			will be added to the specified groups.<br /><br />
			
			If there are accounts in your CSV file whose usernames or email addresses<br />
			match existing accounts on this site, they will be skipped, not imported.<br /><br />
			
			<input type="submit" value="Set Options" />
			</td></tr>
			`;

        print qq`\n</table>\n</form>\n`;



        if ($unfield && $pwfield) {

          print qq`
				<br /><hr />
				<h3>Step 3: Proceed With Import</h3>
				<p>When you're satisfied with the data below, proceed with the import process.</p>
				<form method="get" name="ub_csv_import_step3" id="ub_csv_import_step3" action="$PREF{login_url}">
				<input type="hidden" name="action" value="csvimport" />
				<input type="hidden" name="final" value="yes" />
				<input type="hidden" name="strip_leading_spaces" value="$options{strip_leading_spaces}" />
				<input type="hidden" name="strip_trailing_spaces" value="$options{strip_trailing_spaces}" />
				<input type="hidden" name="strip_surrounding_quotes" value="$options{strip_surrounding_quotes}" />
				<input type="hidden" name="unfield" value="$unfield" />
				<input type="hidden" name="pwfield" value="$pwfield" />
				<input type="hidden" name="rnfield" value="$rnfield" />
				<input type="hidden" name="emfield" value="$emfield" />
				<input type="hidden" name="grfield" value="$grfield" />
				<input type="hidden" name="delete_all_nonadmins" value="` . get_qs_var('delete_all_nonadmins') . qq`" />
				<input type="hidden" name="csvfile" value="$csvfile" />
				`;



          print qq`Username field: ` . ($unfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; `;
          print qq`Password field: ` . ($pwfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; `;
          print qq`Realname field: ` . ($rnfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; ` if $PREF{use_builtin_realname_field} =~ /yes/i;
          print qq`Email field:    ` . ($emfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; ` if $PREF{use_builtin_email_field} =~ /yes/i;
          print qq`Groups field:   ` . ($grfield || '(blank)') . qq` &nbsp; &nbsp; &nbsp; `;



          if (@reserved_fields) {
            print qq`<p><strong>Error:</strong> The following field names are reserved, so you
						must rename them in your CSV file and then <a href="$PREF{login_url}?action=csvimport">upload it again</a>: <br /><br />`;
            print join ", ", @reserved_fields;
            print qq`</p>\n`;
          }
          if (@new_fields) {
            print qq`<p>The following fields don't exist in the user table, so you need to
						<a href="$PREF{login_url}?action=customfields">create them first</a>,
						before the import can proceed: <br /><br />`;
            print join ", ", @new_fields;
            print qq`</p>\n`;
          }
          if (@errors) {
            print qq`<p><strong>Error:</strong> The following errors occurred, so the import cannot proceed:<br /><br />\n`;
            print join ", ", @errors;
            print qq`</p>\n`;
          }


          print qq`<p><strong>WARNING: all existing non-admin accounts will be deleted before import!</strong></p>\n` if get_qs_var('delete_all_nonadmins') eq 'yes';


          if (@reserved_fields || @new_fields || @errors) {
            print qq`<input type="submit" value="Cannot Proceed With Import" disabled="disabled" />`;
          } else {
            print qq`<br /><br /><input type="submit" value="Proceed With Import" />`;
          }


          print qq`
				</form>
				`;





          print qq`<br />\n<div id="ub_csv_preview" class="enc_tbl">\n<table>\n<tr class="headers">\n`;
          print qq`<th>$_</th>\n` for @fieldnames;
          print qq`</tr>\n`;
          my $oddeveni = 1;
          foreach my $row (sort { $a <=> $b } keys %data) {
            print qq`<tr class="` . oddeven($oddeveni) . qq`">`;
            foreach my $field (@fieldnames) {
              my $value = $data{$row}{$field};
              $value =~ s!:!, !g if $field eq $grfield;
              print qq`<td>$value</td>\n`;
            }
            print qq`</tr>\n`;
          }
          print qq`
				</table>
				</div>
				`;
        }

        finish_html_output();
      }
    } else {
      start_html_output();
      my $tmpdir = $ENV{TMPDIR};
      print qq`

		<h1 class="pagetitle">Import Users From CSV File</h1>
		<h3>Step 1: Upload CSV File</h3>
		<form name="ub_csv_import" id="ub_csv_import" method="post" enctype="multipart/form-data" action="$ENV{SCRIPT_NAME}?action=csvimport">
		Select your CSV file here.&nbsp; You can <a href="$PREF{login_url_qsready}action=csvexport">do a test export</a> first, if you<br />
		want to see an example of what the CSV file should contain.<br /><br />
		<input type="file" name="ub_csv_filename" id="ub_csv_filename" /><br /><br />
		(No data will be imported during this step; there are 2 more steps to go.)<br /><br />
                TMPDIR is $tmpdir<br />
		<input type="submit" name="ub_csv_submit" id="ub_csv_submit" value="Upload CSV File" />
		</form>

		`;

      finish_html_output();
    }
  }


sub delete_all_nonadmin_accounts()
  {
    exit_with_needprivs() unless user_is_allowed_to('delete_user_accounts');
    my $allaccounts = enc_sql_select_multi("SELECT * FROM `$PREF{user_table}`");
    foreach my $j (keys %$allaccounts) {
      unless (is_admin($$allaccounts{$j}{id})) {
        #print STDERR "delete_all_nonadmin_accounts: deleting user $$allaccounts{$j}{username} (id=$$allaccounts{$j}{id})\n";
        enc_sql_delete("DELETE FROM `$PREF{user_table}` WHERE `id` = $$allaccounts{$j}{id} LIMIT 1");
      }
    }
  }


sub print_user_form
  {
    my $mode = shift;
    my %vars = ();

    if ($mode eq 'added_by_admin') {
      $PREF{on_page}			= 'adminadduser';
      $vars{title}			= $PREF{user_form_title___admin_adding_user};

      if (!user_has_addmember_rights()) {
        exit_with_error($TEXT{Access_denied_});
      }
	
      $vars{target}			= 'action=commitadduser';
      $vars{forcepwchng}		= 1 if $PREF{enable_forced_password_change} =~ /yes/i;
    } elsif ($mode eq 'user_signup') {
      $PREF{on_page}			= 'usersignup';
      $vars{title}			= $PREF{user_form_title___user_signing_up};

      unless ($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i) {
        exit_with_error($TEXT{This_feature_is_disabled_});
      }
      if ($PREF{member_is_logged_in}) {
        exit_with_error($TEXT{Cant_sign_up_already_have_account_});
      }

      $vars{target}			= 'action=commitadduser';
      $vars{forcepwchng}		= 0;
    } else                      # edit the user info instead.
      {
        exit_with_needlogin() unless $PREF{member_is_logged_in};

        $PREF{on_page} = 'edituser';
        $vars{title}			= $PREF{user_form_title___editing_account};

        $vars{user_id}			= $qs =~ /(?:^|&)id=(\d+)(?:&|$)/ ? $1 : $PREF{logged_in_userid};
        die_unless_numeric($vars{user_id}, 'userid (from print_user_form())');

        $vars{username}			= get_user_name($vars{user_id});

        if (!user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $vars{username})) {
          exit_with_error($TEXT{Access_denied_});
        }

        $vars{target}			= "action=commitedituser";

        $vars{username_readonly}	= $PREF{usernames_are_immutable_once_created} =~ /no/i && user_is_allowed_to($PREF{logged_in_userid}, 'change_usernames', $vars{username}) ? '' : qq`readonly="readonly"`;

        $vars{realname}			= get_real_name($vars{user_id});
        $vars{email}			= get_email_address($vars{user_id});

        $vars{account_locked}		= enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';");
        $vars{account_disabled}		= enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';");
        $vars{forcepwchng}		= enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$vars{user_id}';") if $PREF{enable_forced_password_change} =~ /yes/i;
      }

    if ($qs =~ /redo=true/) {
      while ($qs =~ /(?:^|&)redo_(\w+)=([^&]*)/g) {
        my ($field,$value) = ($1,$2);
        enc_urldecode($value);
        $vars{$field} = $value if $value;
      }
    }

    start_html_output($vars{title});

    if ($qs =~ /(?:^|&)phase=(\w+?)(?:&|$)/) {
      my $phase = $1; print qq`<div id="formmessage">` . get_message($phase) . qq`</div>\n`;
    }


    my $show_password_fields = user_is_allowed_to('edit_password_field') || $mode eq 'user_signup';


    my $outer_template = $PREF{user_form_template};
    $outer_template =~ s!%%post_url%%!$ENV{SCRIPT_NAME}?$vars{target}!g;
    $outer_template =~ s!%%hidden_signup_input%%!$mode eq 'user_signup' ? qq`<input type="hidden" name="user_signup" value="yes" />` : ''!eg;
    $outer_template =~ s!%%%if-forcepwchng%%%(.*?)%%%end-forcepwchng%%%!$PREF{member_is_logged_in} && force_pw_change($PREF{logged_in_userid}) ? $1 : ''!egs;
    my @user_form_field_sections = ();
    my $submit_button = '';
    my $custom_js_code = '';

    my $sections = enc_sql_select_multi("SELECT * FROM `$PREF{field_sections_table}` ORDER BY `section_position`");

    # If there are no sections defined, or just one, then we'll display everything in a single section.
    #%$sections = ();
    my $just_one_section = 0;
    my $num_sections_used = 0;
    if (!%$sections || !$$sections{1}{id} || (enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`") == 1)) {
      $just_one_section = 1;
      %$sections = ();
      $$sections{1}{id} = enc_sql_select("SELECT `id` FROM `$PREF{field_sections_table}`") || 1; # there's only one id (or none) to return.
    }

    # Create a dummy section at the end for the submit button:
    my $submit_button_code = '';
    unless($just_one_section)
      {
        my ($last_section,$last_position) = ();
        foreach my $j (sort { $a <=> $b } keys %$sections) {
          $last_section = $j;
          $last_position = $$sections{$j}{section_position};
        }
        $$sections{$last_section + 1}{this_is_the_final_pass}	= 1;
        $$sections{$last_section + 1}{section_position}		= $last_position + 1;
        $$sections{$last_section + 1}{name}			= $TEXT{userform_submitbutton_section_name} || 'submitbutton';
        $$sections{$last_section + 1}{label}			= $TEXT{userform_submitbutton_section_label} || 'Submit';
      }

    foreach my $j (sort { $$sections{$a}{section_position} <=> $$sections{$b}{section_position} } keys %$sections) {
      my $section_id = $$sections{$j}{id};

      my $template			= $PREF{user_form_fields_template};
      my $section_header_template	= $PREF{user_form_section_header_template};

      my $grouplist = '';
      my ($grouplist_template) = ($template =~ m!%%%template:grouplist%%%(.+?)%%%end-template:grouplist%%%!gs);
      my $groups = get_groups_hash($vars{user_id});
      foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups) {
        next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
        next if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i); # don't show these (not even disabled); it just confuses people.

        my $checked = $$groups{$group}{is_member} ? qq`checked="checked"` : undef;

        my $user_allowed_to_see_all_groups = user_is_allowed_to('see_full_grouplist_on_user_form');
        my $user_belongs_to_this_group = $$groups{$group}{is_member};
        die_unless_numeric($$groups{$group}{id}, 'group ID ($$groups{$group}{id})');
        my ($this_group_always_shown_on_signup,$group_label) = enc_sql_select("SELECT `show_on_signup_page`,`label_for_signup_page` FROM `$PREF{group_table}` WHERE `id` = $$groups{$group}{id};");

        my $disabled = user_is_allowed_to('change_group_memberships') || ($mode eq 'user_signup' && $this_group_always_shown_on_signup) ? '' : 'disabled="disabled"';

        # By default, admins can see all groups here, but non-admins can only see the groups they belong to.
        if ($user_allowed_to_see_all_groups || $user_belongs_to_this_group || $this_group_always_shown_on_signup) {
          my $gl_template = $grouplist_template;
          $gl_template =~ s!%%group%%!$group!gs;
          $gl_template =~ s!%%group_label%%!$mode eq 'user_signup' && $this_group_always_shown_on_signup && $group_label ? $group_label : $group!egs;
          $gl_template =~ s!%%checked%%!$checked!gs;
          $gl_template =~ s!%%disabled%%!$disabled!gs;
          $grouplist .= $gl_template;
        }
      }
      $template =~ s!%%%template:grouplist%%%(.+?)%%%end-template:grouplist%%%!$grouplist!gs;


      my $customfields = '';
      my ($customfields_template) = ($template =~ m!%%%template:customfields%%%(.+?)%%%end-template:customfields%%%!gs);
      if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`")) {
        my $fields = enc_sql_select_multi("SELECT * FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
        foreach my $j (sort { $a <=> $b } keys %$fields) {
          next unless ($$fields{$j}{enabled} && db_column_exists($$fields{$j}{fieldname}, $PREF{user_table}));
          next unless ($section_id eq $$fields{$j}{section}) || $just_one_section;

          my $this_field_readonly = 0;
          if ($mode eq 'user_signup') {
            next unless $$fields{$j}{show_on_signup_page};
          } else {
            next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_view});
            $this_field_readonly = 1 if !logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_edit});
          }

          my $value = enc_sql_select("SELECT `$$fields{$j}{fieldname}` FROM `$PREF{user_table}` WHERE `id` = $vars{user_id}") if $vars{user_id};

          my $required = $$fields{$j}{mandatory} ? 'required' : '';
          $required = '' if user_is_allowed_to('leave_mandatory_custom_fields_blank');


          $$fields{$j}{fieldmax} = '' unless $$fields{$j}{datatype} eq 'varchar'; # workaround for SQL bug where '' gets stored as '0'.

          my $cf_template = $customfields_template;
          my @css_ids = ();

          encdebug qq`processing field: $$fields{$j}{fieldname}`;

          $cf_template =~ s!%%fieldname%%!$$fields{$j}{fieldname}!gs;
          $cf_template =~ s!%%fieldlabel%%!$$fields{$j}{fieldlabel}!gs;
          $cf_template =~ s!%%fieldmax%%!$$fields{$j}{fieldmax}!gs;
          $cf_template =~ s!%%required%%!$required!gs;
          $cf_template =~ s!%%value%%!$value!gs;

          $cf_template =~ s!%%%if-freeformsingle%%%(.*?)%%%end-freeformsingle%%%!$$fields{$j}{fieldtype} eq 'freeformsingle' ? $1 : ''!egs;
          $cf_template =~ s!%%%if-freeformmulti%%%(.*?)%%%end-freeformmulti%%%!$$fields{$j}{fieldtype} eq 'freeformmulti' ? $1 : ''!egs;
          $cf_template =~ s!%%%if-dropdown%%%(.*?)%%%end-dropdown%%%!$$fields{$j}{fieldtype} eq 'dropdown' ? $1 : ''!egs;
          $cf_template =~ s!%%%if-checkbox%%%(.*?)%%%end-checkbox%%%!$$fields{$j}{fieldtype} eq 'checkbox' ? $1 : ''!egs;
          $cf_template =~ s!%%%if-radio%%%(.*?)%%%end-radio%%%!$$fields{$j}{fieldtype} eq 'radio' ? $1 : ''!egs;
				#$cf_template =~ s!%%%ifelse-readonly%%%(.*?)%%%else%%%(.*?)%%%endelse-readonly%%%!$custom_fields_readonly || $this_field_readonly ? $1 : $2!egs;
          $cf_template =~ s!%%%ifelse-readonly%%%(.*?)%%%else%%%(.*?)%%%endelse-readonly%%%!$this_field_readonly ? $1 : $2!egs;
          $cf_template =~ s!%%%if-mandatory%%%(.*?)%%%end-mandatory%%%!$required ? $1 : ''!egs;




          my $dropdown = '';
          my $radio = '';
          if ($$fields{$j}{fieldtype} eq 'freeformsingle') {
            my $css_id = "cust_field_" . $$fields{$j}{fieldname};
            push @css_ids, $css_id;
            $cf_template =~ s!%%css_id%%!$css_id!gs;
          } elsif ($$fields{$j}{fieldtype} eq 'freeformmulti') {
            my $css_id = "cust_field_" . $$fields{$j}{fieldname};
            push @css_ids, $css_id;
            $cf_template =~ s!%%css_id%%!$css_id!gs;
          } elsif ($$fields{$j}{fieldtype} eq 'checkbox') {
            my $css_id = "cust_field_" . $$fields{$j}{fieldname};
            push @css_ids, $css_id;
            $cf_template =~ s!%%css_id%%!$css_id!gs;

            $cf_template =~ s!%%checkbox_checked%%!$value ? 'checked="checked"' : ''!egs;
          } elsif ($$fields{$j}{fieldtype} eq 'dropdown') {
            my $css_id = "cust_field_" . $$fields{$j}{fieldname};
            push @css_ids, $css_id;
            $cf_template =~ s!%%css_id%%!$css_id!gs;

            my ($dropdown_template) = ($cf_template =~ m!%%%template:dropdown%%%(.+?)%%%end-template:dropdown%%%!gs);
            foreach my $item (split(/\n/, $$fields{$j}{listitems})) {
              my $dd_template = $dropdown_template;
              my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
              my $selected = $submitted_value eq $value ? qq`selected="selected"` : '';
              $dd_template =~ s!%%dropdown_selected%%!$selected!gs;
              $dd_template =~ s!%%submitted_value%%!$submitted_value!gs;
              $dd_template =~ s!%%displayed_value%%!$displayed_value!gs;
              $dropdown .= $dd_template;
            }
          } elsif ($$fields{$j}{fieldtype} eq 'radio') {
            my $radio_i = 0;
            my ($radio_template) = ($cf_template =~ m!%%%template:radio%%%(.+?)%%%end-template:radio%%%!gs);
            foreach my $item (split(/\n/, $$fields{$j}{listitems})) {
              $radio_i++;
              my $rad_template = $radio_template;
              my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
              my $checked = $submitted_value eq $value ? qq`checked="checked"` : '';
              my $css_id = 'cust_field_' . $$fields{$j}{fieldname} . '_' . $radio_i;
              push @css_ids, $css_id;
              $rad_template =~ s!%%radio_checked%%!$checked!gs;
              $rad_template =~ s!%%submitted_value%%!$submitted_value!gs;
              $rad_template =~ s!%%displayed_value%%!$displayed_value!gs;
              $rad_template =~ s!%%radio_i%%!$radio_i!gs;
              $rad_template =~ s!%%css_id%%!$css_id!gs;
              $radio .= $rad_template;
            }
          }
          $cf_template =~ s!%%%template:dropdown%%%(.+?)%%%end-template:dropdown%%%!$dropdown!gs;
          $cf_template =~ s!%%%template:radio%%%(.+?)%%%end-template:radio%%%!$radio!gs;


          $custom_js_code .= get_js_code_for_perfield_actions($j, $$fields{$j}{field_actions}, $$fields{$j}{fieldtype}, @css_ids) if $$fields{$j}{field_actions};


          $customfields .= $cf_template;
        }
      }
      $template =~ s!%%%template:customfields%%%(.+?)%%%end-template:customfields%%%!$customfields!gs;


      my $section_header_text		= $$sections{$j}{label} ?	$$sections{$j}{label}
        : $mode eq 'user_signup' ?	$TEXT{user_form_section_header___signup}
          : $mode eq 'added_by_admin' ?	$TEXT{user_form_section_header___adminadd}
            : $mode eq 'edit' ?		$TEXT{user_form_section_header___edit}
              : '';

      my $show_builtin_fields		= $section_id eq $PREF{show_builtin_fields_in_this_section_id};
      my $show_submit_button		= $just_one_section || $$sections{$j}{this_is_the_final_pass};
      my $show_customfields		= $customfields;
      my $no_output_in_this_section	= !($show_builtin_fields || $show_submit_button || $show_customfields);

      if ($no_output_in_this_section) {
        encdebug qq`no output in this section; skipping...`;
      } else {
        $template =~ s!%%emailformat%%!$PREF{usernames_must_be_email_addresses} =~ /yes/i ? 'emailformat' : ''!eg;
        $template =~ s!%%email_field_required%%!$PREF{email_field_required} =~ /yes/i ? 'required emailformat' : ''!eg;
        $template =~ s!%%new_password_required%%!$mode =~ /added_by_admin|user_signup/ ? 'required' : ''!eg;
        $template =~ s!%%account_locked_checked%%!$vars{account_locked} ? 'checked="checked"' : ''!eg;
        $template =~ s!%%account_disabled_checked%%!$vars{account_disabled} ? 'checked="checked"' : ''!eg;
        $template =~ s/%%forcepwchng_checked%%/$vars{forcepwchng} && $PREF{member_is_logged_in} && !force_pw_change($PREF{logged_in_userid}) ? 'checked="checked"' : ''/eg; # if the user is in the middle of being forced to change his password (i.e. force_pw_change() is true), then uncheck it, so he doesn't inadvertently get stuck in a loop.
        $template =~ s!%%paidacct(\d+)name%%!$PREF{"paid_account_type_${1}_groupname"}!g;
        $template =~ s!%%paidacct(\d+)desc%%!$PREF{"paid_account_type_${1}_groupdesc"}!g;
        $template =~ s!%%paidacct(\d+)cost%%!$PREF{"paid_account_type_${1}_cost"}!g;
        $template =~ s!%%loginreturn%%!get_qs_var('loginreturn')!eg;
        $template =~ s!%%section_css_id%%!'section_' . ($$sections{$j}{name} || $j)!eg;

        $template =~ s!%%%if-use_builtin_realname_field%%%(.*?)%%%end-use_builtin_realname_field%%%!my $var = $1; $PREF{use_builtin_realname_field} =~ /yes/i ? $var : ''!egs;
        $template =~ s!%%%if-use_builtin_email_field%%%(.*?)%%%end-use_builtin_email_field%%%!my $var = $1; $PREF{use_builtin_email_field} =~ /yes/i ? $var : ''!egs;
        $template =~ s!%%%if-currentpass_needed%%%(.*?)%%%end-currentpass_needed%%%!$mode eq 'edit'   &&   logged_in_user_must_enter_current_password_to_change_password_for_user($vars{user_id}) ? $1 : ''!egs;
        $template =~ s!%%%if-show_password_fields%%%(.*?)%%%end-show_password_fields%%%!$show_password_fields ? $1 : ''!egs;
        $template =~ s!%%%if-show_account_locks%%%(.*?)%%%end-show_account_locks%%%!$mode eq 'edit'   &&   user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks') ? $1 : ''!egs;
        $template =~ s!%%%ifelse-lock_expires_automatically%%%(.*?)%%%else%%%(.*?)%%%endelse-lock_expires_automatically%%%!my ($var1,$var2)=($1,$2); $PREF{lock_expires_automatically} =~ /yes/i ? $var1 : $var2!egs;
        $template =~ s!%%%if-lock_expires_automatically%%%(.*?)%%%end-lock_expires_automatically%%%!my $var = $1; $PREF{lock_expires_automatically} =~ /yes/i ? $var : ''!egs;
        $template =~ s!%%%if-show_force_pwchng%%%(.*?)%%%end-show_force_pwchng%%%!my $var = $1; user_is_allowed_to($PREF{logged_in_userid}, 'force_password_changes')   &&   $PREF{enable_forced_password_change} =~ /yes/i ? $var : ''!egs;
        $template =~ s!%%%if-show_terms_of_service%%%(.*?)%%%end-show_terms_of_service%%%!my $var = $1; $mode eq 'user_signup' && $PREF{user_must_agree_to_terms_on_signup} =~ /yes/i ? $var : ''!egs;
        $template =~ s!%%%if-show_grouplist%%%(.*?)%%%end-show_grouplist%%%!$grouplist ? $1 : ''!egs;
        $template =~ s!%%%if-show_builtin_fields%%%(.*?)%%%end-show_builtin_fields%%%!$show_builtin_fields ? $1 : ''!egs;
        $template =~ s!%%%if-show_customfields%%%(.*?)%%%end-show_customfields%%%!$show_customfields ? $1 : ''!egs;
        $template =~ s#%%%if-show_payment_options%%%(.*?)%%%end-show_payment_options%%%#my $var = $1; $mode eq 'user_signup' && $PREF{enable_paid_accounts} =~ /yes/i && !$PREF{all_accounts_are_paid_accounts_with_this_type} ? $var : ''#egs;

        $template =~ s!%%user_form_section_header%%!$section_header_template!g;
        $template =~ s!%%user_form_section_header_text%%!$section_header_text!g;
        #$template =~ s!%%%if-show_submit_button%%%(.*?)%%%end-show_submit_button%%%!$show_submit_button ? $1 : ''!egs;
        $template =~ s/%%%if-show_submit_button%%%(.*?)%%%end-show_submit_button%%%/$show_submit_button ? qq`<!-- submit_button_start -->\n$1\n<!-- submit_button_end -->` : '<!-- submit_button_unused_location -->'/egs;

        $template =~ s!%%%if-user_signing_up%%%(.*?)%%%end-user_signing_up%%%!$mode eq 'user_signup' ? $1 : ''!egs;
        $template =~ s!%%%if-admin_adding_user%%%(.*?)%%%end-admin_adding_user%%%!$mode eq 'added_by_admin' ? $1 : ''!egs;
        $template =~ s!%%%ifelse-editing_account%%%(.*?)%%%else%%%(.*?)%%%endelse-editing_account%%%!$mode eq 'edit' ? $1 : $2!egs;
        $template =~ s!%%%if-editing_account%%%(.*?)%%%end-editing_account%%%!$mode eq 'edit' ? $1 : ''!egs;

        $template =~ s!%PREF{(.+?)}!$PREF{$1}!g;

        $template =~ s!%%(\w+)%%!$vars{$1}!g;
        $template =~ s!%%%if-(\w+)%%%(.*?)%%%end-\1%%%!!gs;
			
        if ($template =~ s/<!-- submit_button_start -->(.*)<!-- submit_button_end -->/<!-- submit_button_placeholder -->/s) {
          $submit_button_code = $1;
        }

        push @user_form_field_sections, $template;
        $num_sections_used++;
        encdebug qq`num_sections_used=$num_sections_used; template=$template`;
      }
    }

    # All this $submit_button_code nonsense is necessary because of the way we're creating and populating
    # output sections as we go, but in a way that results in a separate final section for just the submit
    # button, even when that second is the 2nd of 2 and contains nothing *but* the submit button, in which
    # case we'd rather just have a single section with the submit button included at the bottom of the
    # fields in that section.
    #
    if ($num_sections_used == 2) {
      delete $user_form_field_sections[1];
      $user_form_field_sections[0] =~ s/<!-- submit_button_unused_location -->/$submit_button_code/gs;
    } else {
      s/<!-- submit_button_placeholder -->/$submit_button_code/gs for @user_form_field_sections;
    }

    $outer_template =~ s!%%user_form_field_sections%%!join '', @user_form_field_sections!eg;
    print $outer_template;

    print qq`\n\n\n\n<script type="text/javascript">\n$custom_js_code\n</script>\n\n\n\n` if $custom_js_code;

    finish_html_output();
  }


  sub get_js_code_for_perfield_actions
  {
    my ($field_i, $code, $fieldtype, @css_ids) = @_;
    sql_un_untaint($code);
    my $js_code = '';
    my $action_i = 1;
    foreach my $action (split(/\n\n/, $code)) {
      if ($action =~ m!(onclick|onchange|onfocus|onblur): (show|hide) (\w+) if (\w+) (.+)!) {
        my ($trigger, $action, $target_element, $source_element, $test) = ($1, $2, $3, $4, $5);
        @css_ids = ($source_element) if $source_element ne 'self';

        my $source_i = 1;
        foreach $source_element (@css_ids) {
          my $extra_onload_test = '';
          if ($fieldtype eq 'radio') {
            # For radio buttons, when this code runs at onload time, it runs for every
            # radio button in a group, rather than just for the selected one as happens
            # when one is clicked.  This causes incorrect behavior (specifically, it will
            # run any show or hide actions based on the values of *every* radio button, 
            # but it should only test the selected radio button) so we need to restrict
            # that onload execution to only occur on the selected radio button.
            #
            $extra_onload_test = qq` && (document.getElementById("$source_element").checked)`;
          }

          $js_code .= qq`
		function fields_custom_code_${field_i}_${action_i}_${source_i}()
		{
			var source_el = document.getElementById("$source_element");
			var target_el = document.getElementById("$target_element");
			if(source_el && target_el)
			{
				schedule_${trigger}_action(source_el, function()
				{
					if(document.getElementById("$source_element").value $test)
						${action}_element("$target_element");
				});

				// Also execute the same code once at onload, so that when editing an existing account
				// where fields already have values at onload, the custom rules take effect right away.
				//
				if(document.getElementById("$source_element").value $test$extra_onload_test)
					${action}_element("$target_element");
			}
		}
		schedule_onload_action(fields_custom_code_${field_i}_${action_i}_${source_i});

	`;

          $source_i++;
        }
      }
      $action_i++;
    }
    return $js_code;
  }


sub logged_in_user_must_enter_current_password_to_change_password_for_user($)
  {
    my $userid_of_target_user = shift;

    #
    #my $username_of_target_user = shift;
    #if(this_user_is_the_logged_in_admin($username_of_target_user))
    #{
    #	# an admin is trying to change his own password, so
    #	# we DO require the current password.
    #	return 1;
    #}
    #
    # Admin or not, if the account being updated is the logged-in user's account,
    # then he must enter the current password to change the password:
    #
    if ($userid_of_target_user == $PREF{logged_in_userid}) {
      # A user is changing his own password, so the current password is required.
      # ahc 
      # Changed this for the case of inital password change - user has no password.  Minimizes confusion.
      # return 1;
      return 0;
    } elsif (logged_in_user_is_subgroup_manager()   &&   logged_in_subgroup_manager_owns_this_user($userid_of_target_user)) {
      # a subgroup manager is trying to change the password of one of his
      # own users; he's effectively an admin for this purpose, so we DON'T
      # require the current password.
      return 0;
    } elsif (user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $userid_of_target_user)) {
      # in general, a user with 'edit_user_info' rights does NOT need
      # the current password to change a password.
      return 0;
    } else {
      # in general, a user without 'edit_user_info' rights DOES need
      # the current password to change a password.
      return 1;
    }
  }


sub process_new_account()
  {
    my $go			= "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";
  
    my $user		= my $user_redo		= param('username');	enc_urlencode($user_redo);
    my $realname		= my $realname_redo	= param('realname');	enc_urlencode($realname_redo);
    my $email		= my $email_redo	= param('email');	enc_urlencode($email_redo);
    my $pass		= param('pw1'); # don't redo/refill the password because we don't want to pass that on the URL.
  
    $user = lc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
    $user = uc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;

    # It seems this is handled by $PREF{usernames_must_be_email_addresses}
    # # ahc my addition.  Username is email address, copy to email field.
    # if (length($user) and not length($email)) {
    #   $email = $user;
    # }
  
    my $salt		= create_random_salt($PREF{salt_length});
    my $crypted_pass	= salt_and_crypt_password($pass,$salt);
    my $signup		= param('user_signup') =~ /yes/i;
  
    $PREF{prev_page} = $signup ? 'signup' : 'adduser';
  
    my $redo = "$PREF{login_url}?action=$PREF{prev_page}&redo=true";
    $redo .= "&redo_username=$user_redo&redo_realname=$realname_redo&redo_email=$email_redo";
    $redo .= ("&loginreturn=" . param('loginreturn')) if param('loginreturn');
  
    if (!user_has_addmember_rights() && !$signup) {
      enc_redirect("$redo&phase=eneedlogin");
    } elsif ($PREF{visitors_can_sign_up_for_their_own_accounts} !~ /yes/i && $signup) {
      enc_redirect("$redo&phase=enosignup");
    } elsif (!realname_is_valid($realname) && $realname) {
      enc_redirect("$redo&phase=einvldr");
    } elsif (!emailaddr_is_valid($email) && $email) {
      enc_redirect("$redo&phase=einvlde");
    } elsif (!emailaddr_is_valid($user) && $PREF{usernames_must_be_email_addresses} =~ /yes/i) {
      enc_redirect("$redo&phase=einvlde");
    } elsif (!password_is_valid($pass)) {
      enc_redirect("$redo&phase=einvldp");
    } elsif (!hashedpw_is_valid($crypted_pass)) {
      enc_redirect("$redo&phase=einvldh");
    } elsif (!username_is_valid($user)) {
      enc_redirect("$redo&phase=ebadname");
    } elsif ( username_is_taken($user)) {
      enc_redirect("$redo&phase=edupuser");
    } elsif ( $email && email_address_is_taken($email)) {
      enc_redirect("$redo&phase=edupemail");
    } elsif ( param('group-admin') =~ /on/i   &&   !user_has_addadmin_rights()) {
      enc_redirect("$redo&phase=einsuff");
    } elsif ( param('pw1') ne param('pw2')) {
      enc_redirect("$redo&phase=epwmismatch");
    }
  
    my $customfields_sqlsafe = get_sqlsafe_custom_field_values($signup);
  
    my $pending_email_verification	= $signup && $PREF{require_email_verification_for_new_signups} =~ /yes/i ? 1 : 0;
    my $pending_admin_approval	= $signup && $PREF{require_admin_approval_for_new_signups} =~ /yes/i ? 1 : 0;
    my $pending_payment		= $signup && $PREF{enable_paid_accounts} =~ /yes/i && ($PREF{all_accounts_are_paid_accounts_with_this_type} =~ /^0*[123456789]\d*$/ || param('paidacct') =~ /^0*[123456789]\d*$/) ? 1 : 0;
  
    my $token = '';
    if ($pending_email_verification || $pending_admin_approval) {
      $token = enc_hash($email . $realname . $user . $pass . $salt . offsettime() . $$ . $PREF{ip} . $ENV{HTTP_USER_AGENT});
      $token =~ s/[^\w]/X/g;
    }
  
    my $new_user_id = add_new_user($user, $crypted_pass, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $token);
  
    my $query = new CGI;
    my %params = $query->Vars;
  
    foreach my $param (sort keys %params) {
      if ($param =~ /^group-(.+)$/) {
        my $group = $1;
        next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
        next if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i); # every account is automatically a member of these groups.
      
        my $group_id = get_group_id($group);
        die_unless_numeric($group_id, '$group_id');
        my $user_belongs_to_this_group = user_is_member_of_group($PREF{logged_in_userid}, $group);
        my $user_has_groupmod_rights = user_is_allowed_to($PREF{logged_in_userid}, 'change_group_memberships');
        my ($this_group_always_shown_on_signup) = enc_sql_select("SELECT `show_on_signup_page` FROM `$PREF{group_table}` WHERE `id` = $group_id;");
      
        if ($user_has_groupmod_rights || $user_belongs_to_this_group || ($signup && $this_group_always_shown_on_signup)) {
          add_user_to_group($user, $group) if $params{$param} =~ /on/i;
        }
      }
    }
  
  
  
    # When a subgroup manager creates an account, it's automatically
    # put into a special group based on the manager's username.
    #
    if (logged_in_user_is_subgroup_manager()) {
      my $groupname = "$PREF{logged_in_username}$PREF{subgroup_groupname_suffix}";
      add_new_group($groupname, "Group managed by $PREF{logged_in_username}") unless group_exists($groupname);
      add_user_to_group($user, $groupname);
    
      if ($PREF{subgroup_owned_users_get_group_memberships_from_their_creator} =~ /yes/i) {
        my $allgroups = get_groups_hash($PREF{logged_in_userid});
        foreach my $group (sort keys %$allgroups) {
          next if is_builtin_group($group);
          if (my $logged_in_subadmin_belongs_to_this_group = $$allgroups{$group}{is_member}) {
            next if $PREF{groups_that_can_manage_subgroup_users} =~ /(^|,)\s*$group\s*(,|$)/;
            add_user_to_group($user, $group);
          }
        }
      }
    }
  
    my $payment_url = '';
    if ($PREF{enable_paid_accounts} =~ /yes/i) {
      my $paid_acct_type = $PREF{all_accounts_are_paid_accounts_with_this_type} || param('paidacct');
      if ($paid_acct_type =~ /^0*[123456789]\d*$/) {
        $payment_url = "$PREF{login_url}?action=startpayment&type=$paid_acct_type&uid=$new_user_id";
      }
    }
  
    my $table = $PREF{user_table};
  
    foreach my $customfield (keys %$customfields_sqlsafe) {
      if ($signup) {
        next unless $$customfields_sqlsafe{$customfield}{show_on_signup_page};
      } else {
        next unless logged_in_user_belongs_to_one_of_these_group_ids($$customfields_sqlsafe{$customfield}{groups_allowed_to_edit});
      }
    
      die_unless_numeric($new_user_id, "userid");
      my $value = $$customfields_sqlsafe{$customfield}{value};
      unless($value eq enc_sql_select("SELECT `$customfield` FROM `$table` WHERE `id` = $new_user_id"))
        {
          my $statement = "UPDATE `$table` SET `$customfield` = '$value' WHERE `id` = $new_user_id";
          my $success = enc_sql_update($statement);
          die_nice("Error: process_new_account(): SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]") unless $success == 1;
        }
    }
  
    if (param('forcepwchng') =~ /on/i || $PREF{force_pw_chng_after_first_login} =~ /yes/i) {
      my $statement = "UPDATE `$table` SET `forcepwchng` = 1 WHERE `id` = $new_user_id;";
      my $success = enc_sql_update($statement);
      die_nice("Error: process_new_account(id='$new_user_id'): SQL returned '$success' instead of '1' while enabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
    }
  
    if ($pending_email_verification) {
      $PREF{verification_email_template} =~ s/%%link%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=verify&u=$new_user_id&t=$token/g;
    
      my $user_email = $PREF{usernames_must_be_email_addresses} =~ /yes/i ? $user : $email;
    
      send_email(	$user_email,
                        $PREF{app_email_address},
                        $PREF{verification_email_subject},
                        $PREF{verification_email_template},
                        ($PREF{verification_email_format} || $PREF{global_email_format}),
                        'die_on_email_error'
                      );
    
      if ($payment_url) {
        enc_redirect($payment_url);
      } else {
        $TEXT{messages}{sactvrf} =~ s!%%username%%!$user!g;
        kmsg_redirect($TEXT{messages}{sactvrf});
      }
    } elsif ($pending_admin_approval) {
      send_email_requesting_admin_approval_of_new_acct($user,$new_user_id);
      if ($payment_url) {
        enc_redirect($payment_url);
      } else {
        $TEXT{messages}{sactapp} =~ s!%%username%%!$user!g;
        kmsg_redirect($TEXT{messages}{sactapp});
      }
    } else {
      create_filechucker_userdir($new_user_id,$user,$realname,$email);
      if ($signup) {
        add_user_to_group($user,$_) for (split(/\s*,\s*/, $PREF{automatically_add_new_signups_to_these_groups}));
      }
      notify_admin_of_new_signup($new_user_id) if $signup;
    
      #enc_urlencode($user);
      if ($payment_url) {
        enc_redirect($payment_url);
      } else {
        $TEXT{messages}{snewadd} =~ s!%%username%%!$user!g;
        $TEXT{messages}{snewadd} =~ s!%%loginreturn%%!param('loginreturn')!eg;
        kmsg_redirect($TEXT{messages}{snewadd});
      }
    }
  }


# 20111003: replaced by per-field permissions in the DB rather than in prefs.
#
#sub user_can_view_this_field($)
#{
#	return (	user_is_allowed_to('view_' . $_[0] . '_field')
#			||
#			!exists $PREF{'groups_allowed_to_view_' . $_[0] . '_field'}		);
#}


# 20111003: replaced by per-field permissions in the DB rather than in prefs.
#
#sub user_can_edit_this_field($)
#{
#	return (	user_is_allowed_to('edit_' . $_[0] . '_field')
#			||
#			!exists $PREF{'groups_allowed_to_edit_' . $_[0] . '_field'}		);
#}


sub get_sqlsafe_custom_field_values
  {
    my $signup = shift;           # bool; optional
    my $nonpost_data = shift;     # hashref; optional.

    my %customfields_sqlsafe = ();
    my $custom_field_list_table = $PREF{custom_field_list_table};
    my $table_to_modify = $PREF{user_table};

    my $error = '';
    if (enc_sql_select("SELECT COUNT(*) FROM `$custom_field_list_table`")) {
      my $fields = enc_sql_select_multi("SELECT * FROM `$custom_field_list_table` ORDER BY `fieldposition`");
      foreach my $j (sort { $a <=> $b } keys %$fields) {
        my $fieldname = $$fields{$j}{fieldname};

        next unless ($$fields{$j}{enabled} && db_column_exists($fieldname, $table_to_modify));

        # 20111003: shouldn't the allowed_to_edit check occur in the caller, instead of here?
        # 20111005: actually, we do need this check here; otherwise any fields set to mandatory,
        # but also set to uneditable by the logged-in user's groups, will result in a failed
        # update and confusing error because the mandatory (but not displayed) field wasn't
        # filled in.  And anyway, having this extra check here couldn't cause any problems,
        # because if the logged-in user (even if it's not the user being edited, e.g. even if
        # it's an admin editing a regular member) is NOT allowed to edit this field, well, then
        # we should still skip it, just as if it were the member editing his own info.
        #
        if ($signup) {
          next unless $$fields{$j}{show_on_signup_page};
        } else {
          next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_edit});
        }

        # $fieldname is coming from $custom_field_list_table (it's a column in that table),
        # so it shouldn't be possible for it to be a built-in field, because we check for
        # that when creating new custom fields; but an extra check here doesn't hurt.
        #
        next if is_builtin_fieldname($fieldname);

        my $value = '';
        if ($nonpost_data) {
          $value = $$nonpost_data{$fieldname};
        } else {
          next if param("field_${fieldname}_disabled_by_customfield_code") =~ /yes/i;
          $value = param($fieldname);
          $value =~ s/\r\n/\n/g; # fix browser newlines.
        }

        next if !$value && user_is_allowed_to('leave_mandatory_custom_fields_blank');

        #
        # Do custom-field sanity checking:
        #

        if (($$fields{$j}{datatype} eq 'bool' || $$fields{$j}{fieldtype} eq 'checkbox')   &&   ($value =~ /^on$/i)) {
          $value = 1;
        }                   # convert checkbox string value to a bool.

        if ($$fields{$j}{datatype} eq 'int'    &&   $value =~ /[^\d-]/) {
          $TEXT{Entry_not_int}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_int}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_int}; last;
        }
        if ($$fields{$j}{datatype} eq 'uint'   &&   $value =~ /[^\d]/) {
          $TEXT{Entry_not_uint}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_uint}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_uint}; last;
        }
        if ($$fields{$j}{datatype} eq 'float'  &&   $value =~ /[^\d\.-]/) {
          $TEXT{Entry_not_float}	=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_float}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_float}; last;
        }
        if ($$fields{$j}{datatype} eq 'ufloat' &&   $value =~ /[^\d\.]/) {
          $TEXT{Entry_not_ufloat}	=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_ufloat}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_ufloat}; last;
        }

        if (($$fields{$j}{datatype} eq 'bool' || $$fields{$j}{fieldtype} eq 'checkbox')   &&   !($value =~ /^on$/i || !$value)) {
          $TEXT{Entry_not_bool}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_not_bool}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_not_bool}; last;
        }

        if ($$fields{$j}{fieldtype} =~ /^(dropdown|radio)$/) {
				#my %allowable_values = map { $_ => 1 } split(/\n/, $listitems);
          my %allowable_values = ();
          foreach my $item (split(/\n/, $$fields{$j}{listitems})) {
            $item =~ s!(.+?)///(.+)!$1!; # in case they're specified as separate submit/display values.
            $allowable_values{$item} = 1;
          }
          unless ($allowable_values{$value}) {
            $TEXT{Entry_invalid}		=~ s/%%item%%/$fieldname/g; $TEXT{Entry_invalid}	=~ s/%%value%%/$value/g; $error = $TEXT{Entry_invalid}; last;
          }
        }

        if ($$fields{$j}{fieldmax} =~ /^\d+$/   &&   $$fields{$j}{fieldmax} > 0   &&   length($value) > $$fields{$j}{fieldmax}) {
          $TEXT{e_toolong} =~ s/%%item%%/$fieldname/g;
          $TEXT{e_toolong} =~ s/%%limit%%/$$fields{$j}{fieldmax}/g;
          $TEXT{e_toolong} =~ s/%%length%%/length($value)/eg;
          $error = $TEXT{e_toolong}; last;
        }

        if ($$fields{$j}{mandatory}   &&   !$value) {
          $TEXT{e_mandatory} =~ s/%%item%%/$fieldname/g; $error = $TEXT{e_mandatory}; last;
        }

        if ($$fields{$j}{limitallowedchars}) {
				# Escape any dashes or closing brackets, as per perlre:
				#
				# 	If you want either "-" or "]" itself to be a member of a class,
				#	put it at the start of the list (possibly after a "^"), or escape
				#	it with a backslash.
				#
          my $allowedchars = $$fields{$j}{allowedchars};
          sql_un_untaint($allowedchars);
          $allowedchars =~ s!\]!\\]!g;
          $allowedchars =~ s!([^\\])-!$1\\-!g; # note: preventing double-escaping.

          if ($value =~ /[^$allowedchars]/) {
            die_unless_numeric($$fields{$j}{id}, "ID");
            my ($fieldname_inner,$msg) = enc_sql_select("SELECT `fieldname`,`allowedcharsmsg` FROM `$custom_field_list_table` WHERE `id` = $$fields{$j}{id}");
            $msg =~ s!%%fieldname%%!$fieldname_inner!g;
            $error = $msg; last;
          }
        }

        #
        # Do SQL sanity checking:
        #

        sql_untaint($value);
        if (not_sqlsafe($value)) {
          $TEXT{e_sqlsafe} =~ s/%%fieldname%%/$fieldname/g; $error = $TEXT{e_sqlsafe};
        }

        #
        # If we got this far, the value is valid.
        #

        $customfields_sqlsafe{$fieldname}{value}			= $value unless $error;
        $customfields_sqlsafe{$fieldname}{show_on_signup_page}		= $$fields{$j}{show_on_signup_page};
        $customfields_sqlsafe{$fieldname}{groups_allowed_to_view}	= $$fields{$j}{groups_allowed_to_view}; $customfields_sqlsafe{$fieldname}{groups_allowed_to_view} =~ s!\|\|\|!,!g; # Replace the db separator "|||" with a comma.
        $customfields_sqlsafe{$fieldname}{groups_allowed_to_edit}	= $$fields{$j}{groups_allowed_to_edit}; $customfields_sqlsafe{$fieldname}{groups_allowed_to_edit} =~ s!\|\|\|!,!g; # Replace the db separator "|||" with a comma.
      }
    }

    if ($nonpost_data) {
      return ($error, \%customfields_sqlsafe);
    } else {
      if ($error) {
        kmsg_redirect($error);
      } else {
        return \%customfields_sqlsafe;
      }
    }
  }


sub this_user_is_the_logged_in_admin($)
  {
    my $username = shift;
    return $PREF{admin_is_logged_in} && lc($PREF{logged_in_username}) eq lc($username);
  }


sub do_email_verification($$)
  {
    my $uid = shift;
    my $email_verification_token = shift;
  
    my $username = get_user_name($uid);
    my $realname = get_real_name($uid);
    my $email = get_email_address($uid);
    check_username_for_sql_safeness($username);
    die_nice("Invalid token '$email_verification_token'.") unless $email_verification_token =~ /^\w+$/;
  
    enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_email_verification` = 0, `completed_email_verification` = 1 WHERE `id` = $uid AND `email_verification_token` = '$email_verification_token' AND `pending_email_verification` = 1") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_email_verification to 0.");
  
    if ($PREF{require_admin_approval_for_new_signups} =~ /yes/i) {
      start_html_output("Email Address Verified");
      print $PREF{email_verified_pending_template};
      send_email_requesting_admin_approval_of_new_acct($username,$uid);
      finish_html_output();
    } else {
      create_filechucker_userdir($uid,$username,$realname,$email);
      add_user_to_group($username,$_) for (split(/\s*,\s*/, $PREF{automatically_add_new_signups_to_these_groups})); # The fact that we're doing email verification means that it was a signup.
      notify_admin_of_new_signup($uid);

      start_html_output("Email Address Verified");
      $PREF{email_verified_active_template} =~ s/%%login_url%%/$PREF{login_url}/g;
      print $PREF{email_verified_active_template};

      # My change ahc.
      # send_welcome_email($new_user_id,$user,$pass,$email,$realname) unless $signup;
      my $add_user_prog = $PREF{mailchimp_util};
      my $add_user_str = "/opt/local/bin/php $add_user_prog -w -a -m=${email}";
      my @ret = `$add_user_str`;
      print STDERR "do_email_verification(): " . join("\n", ($add_user_str, @ret));

      finish_html_output();
    }
  }


sub resend_verification_email()
  {
    my $uid = get_qs_var('uid');
    my $username = get_qs_var('user');
    die_unless_numeric($uid, 'user ID');
    exit_with_error qq`Invalid username.` unless username_is_valid($username);

    sleep (int(rand(3)) + 2); # introduce some randomness into the page load time, to thwart bots/attackers.

    my $username_from_id = get_user_name($uid);
    unless($username eq $username_from_id)
      {
        $PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_error $TEXT{verification_email_mismatch_error};
      }
	
    unless(account_is_pending_email_verification($uid))
      {
        $PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_error $TEXT{verification_email_notpending_error};
      }
	
    my $token = enc_sql_select("SELECT `email_verification_token` FROM `$PREF{user_table}` WHERE `id` = $uid");
    unless($token =~ /\w+/)
      {
        $PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_error $TEXT{verification_email_token_error};
      }

    $PREF{verification_email_template} =~ s/%%link%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=verify&u=$uid&t=$token/g;
    my $user_email = get_email_address($uid);

    send_email(	$user_email,
                $PREF{app_email_address},
                $PREF{verification_email_subject},
                $PREF{verification_email_template},
                ($PREF{verification_email_format} || $PREF{global_email_format}),
                'die_on_email_error'
              );

    my $address_obscured = $user_email;
    $address_obscured =~ s!^(.{1,2}).*?(\@.{1,2}).*?$!$1...$2...!;
    $TEXT{verification_email_resent___full} =~ s!%%address_obscured%%!$address_obscured!;
    $TEXT{verification_email_resent___full} =~ s!%%address%%!$user_email!;
    $PREF{lie_about_invalid_accts_when_resending_verification_emails} =~ /yes/i ? exit_with_notice($TEXT{verification_email_resent}) : exit_with_notice($TEXT{verification_email_resent___full});
  }


sub send_email_requesting_admin_approval_of_new_acct($$)
  {
    my $username = shift;
    my $uid = shift;

    my $username_urlencoded = $username;
    enc_urlencode($username_urlencoded);

    $PREF{admin_approval_email_subject} =~ s/%%username%%/$username/g;
    $PREF{admin_approval_email_template} =~ s/%%username%%/$username/g;
    $PREF{admin_approval_email_template} =~ s/%%approval_url%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=approve_or_del&uid=$uid/g;

    send_email(	$PREF{webmaster_email_address},
                $PREF{app_email_address},
                $PREF{admin_approval_email_subject},
                $PREF{admin_approval_email_template},
                ($PREF{admin_approval_email_format} || $PREF{global_email_format}),
                'die_on_email_error'
              );
  }


sub approve_or_delete_pending_account($)
  {
    exit_with_error($TEXT{Access_denied_}) unless user_has_addmember_rights();

    my $uid = shift;
    my $username = get_user_name($uid);

    check_username_for_sql_safeness($username);

    my ($password,$salt,$name,$email,$cdate) = enc_sql_select("SELECT `password`,`salt`,`name`,`email`,`cdate` FROM `$PREF{user_table}` WHERE `id` = $uid");
    die_nice("Error: no matching account found for that user ID.") unless $password && $salt && $cdate;

    start_html_output("Approve or Delete Pending Account");

    print	  qq``
      . qq`\n<p><b>Username:</b> $username`
        . (   $PREF{usernames_must_be_email_addresses} =~ /yes/i
                ? (   qq` (email address ` . (account_has_completed_email_verification($uid) ? 'verified' : 'not verified') . qq`)`   )
                  : ''
                )
          . qq`</p>`
            . ($PREF{use_builtin_realname_field} =~ /yes/i ? qq`\n<p><b>Real Name:</b> $name</p>` : '')
              . ($PREF{use_builtin_email_field} =~ /yes/i ? qq`\n<p><b>Email Address:</b> $email (` . (account_has_completed_email_verification($uid) ? 'verified' : 'not verified') . qq`)</p>` : '')
		. ($PREF{enable_paid_accounts} =~ /yes/i ? qq`\n<p><b>Payment Pending:</b> ` . (account_is_pending_payment($uid) ? 'yes' : 'no') . qq`</p>` : '')
                  . ($PREF{enable_paid_accounts} =~ /yes/i ? qq`\n<p><b>Payment Completed:</b> ` . (account_has_completed_payment($uid) ? 'yes' : 'no') . qq`</p>` : '')
                    . qq`\n<p><b>Creation Date:</b> ` . strftime("%Y%m%d-%H:%M",localtime($cdate)) . qq`</p>`
                      . qq`\n<p><br /></p>`;


    if (my @custom_field_names = get_custom_userbase_field_names($PREF{user_table})) {
      my @custom_field_values = enc_sql_select("SELECT " . (join ',', @custom_field_names) . " FROM `$PREF{user_table}` WHERE `id` = $uid");
      my $i = 0;
      for (@custom_field_names) {
        print qq`\n<p><b>$custom_field_names[$i]:</b> $custom_field_values[$i]</p>`;
        $i++;
      }
      print qq`\n<p><br /></p>`;
    }

    print	  qq`\n<p style="font-weight: bold;"><a href="$PREF{login_url}?action=approve_pending_acct&amp;uid=$uid">Approve and activate pending account '$username'</a></p>`
      . qq`\n<p style="font-weight: bold;"><a href="$PREF{login_url}?action=delete_pending_acct&amp;uid=$uid">Delete pending account '$username'</a></p>`
        . qq`\n<p></p>`
          . qq`\n`;

    finish_html_output();
  }


sub approve_or_delete_pending_account_stage2($$)
  {
    exit_with_error($TEXT{Access_denied_}) unless user_has_addmember_rights();

    my $uid = shift;
    my $decision = shift;
    my $username = get_user_name($uid);
    my $realname = get_real_name($uid);

    if ($decision eq 'approve') {
      if (account_is_pending_admin_approval_in_db($uid)) {
        enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_admin_approval` = 0 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_admin_approval to 0.");
      }
      if (1 != enc_sql_select("SELECT `completed_admin_approval` FROM `$PREF{user_table}` WHERE `id` = $uid")) {
        enc_sql_update("UPDATE `$PREF{user_table}` SET `completed_admin_approval` = 1 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set completed_admin_approval to 1.");
      }

      # Also disable the other pending flags here (pending_email_verification,
      # pending_payment) so that the admin has the ability to override those
      # if he wants/needs to, to manually approve the account.  Of course, we
      # won't set completed_email_verification in this case, nor will we add
      # the account to any of the paid groups.
      #
      if (account_is_pending_email_verification_in_db($uid)) {
        enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_email_verification` = 0 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_email_verification to 0.");
      }
      if (account_is_pending_payment($uid)) {
        enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_payment` = 0 WHERE `id` = $uid") == 1 or die_nice("SQL returned something other than 1 while trying to set pending_payment to 0.");
      }

      my $user_email = $PREF{usernames_must_be_email_addresses} =~ /yes/i ? $username : get_email_address($uid);

      create_filechucker_userdir($uid,$username,$realname,$user_email);
      add_user_to_group($username,$_) for (split(/\s*,\s*/, $PREF{automatically_add_new_signups_to_these_groups})); # The fact that the account is pending means that it was a signup.
      notify_admin_of_new_signup($uid);

      $PREF{account_activated_email_subject} =~ s/%%username%%/$username/g;
      $PREF{account_activated_email_template} =~ s/%%username%%/$username/g;

      send_email(	$user_email,
                        $PREF{app_email_address},
                        $PREF{account_activated_email_subject},
                        $PREF{account_activated_email_template},
                        ($PREF{account_activated_email_format} || $PREF{global_email_format}),
                        'die_on_email_error'
                      );

      start_html_output("Pending Account Approved and Activated");
      print qq`<p>The <a href="$PREF{login_url}?action=edituser&amp;id=$uid">'$username' account</a> has been approved and is now active.</p>\n`;
      finish_html_output();
    } else {
      my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{user_table}` WHERE `id` = $uid");
      $sth->execute == 1 or die_nice("SQL returned something other than 1 while deleting account from users table.");

      start_html_output("Pending Account Deleted");
      print qq`<p>The '$username' account has been deleted.&nbsp; <a href="$PREF{login_url}?action=showusers">Manage users</a> again?</p>\n`;
      finish_html_output();
    }
  }


sub notify_admin_of_new_signup($)
  {
    my $new_user_id = shift;
    return unless $PREF{notify_admin_of_new_signups} =~ /yes/i;

    die_unless_numeric($new_user_id, 'new_user_id');
    my ($username,$name,$email) = enc_sql_select("SELECT `username`,`name`,`email` FROM `$PREF{user_table}` WHERE `id` = '$new_user_id'");
    sql_un_untaint($name);

    my $username_template = my $name_template = my $email_template = $PREF{admin_notification_email_field_template};

    $username_template	=~ s/%%fieldname%%/$PREF{username_label}/g;
    $name_template		=~ s/%%fieldname%%/$PREF{name_label}/g;
    $email_template		=~ s/%%fieldname%%/$PREF{email_label}/g;

    $username_template	=~ s/%%fieldvalue%%/$username/g;
    $name_template		=~ s/%%fieldvalue%%/$name/g;
    $email_template		=~ s/%%fieldvalue%%/$email/g;

    my $user_info_fields = $username_template;
    $user_info_fields .= $name_template if $PREF{use_builtin_realname_field} =~ /yes/i;
    $user_info_fields .= $email_template if $PREF{use_builtin_email_field} =~ /yes/i;

    if (my @custom_field_names = get_custom_userbase_field_names($PREF{user_table})) {
      my @custom_field_values = enc_sql_select("SELECT " . (join ',', @custom_field_names) . " FROM `$PREF{user_table}` WHERE `id` = '$new_user_id'");
      my $i = 0;
      for (@custom_field_names) {
        my $template = $PREF{admin_notification_email_field_template};
        $template =~ s/%%fieldname%%/$custom_field_names[$i]/g;
        $template =~ s/%%fieldvalue%%/$custom_field_values[$i]/g;
        $user_info_fields .= $template;
        $i++;
      }
    }

    $PREF{admin_notification_email_subject} =~ s/%%username%%/$username/g;
    $PREF{admin_notification_email_subject} =~ s/%%name%%/$name/g;
    $PREF{admin_notification_email_subject} =~ s/%%email%%/$email/g;
    $PREF{admin_notification_email_template} =~ s/%%user_info_fields%%/$user_info_fields/g;

    send_email(	$PREF{webmaster_email_address},
                $PREF{app_email_address},
                $PREF{admin_notification_email_subject},
                $PREF{admin_notification_email_template},
                ($PREF{admin_notification_email_format} || $PREF{global_email_format}),
                'die_on_email_error'
              );
  }


sub send_welcome_email($$$$$)
  {
    my ($new_user_id, $username, $password, $email, $name) = @_;
    return unless $PREF{send_welcome_email_when_admin_creates_an_account} =~ /yes/i;

    for ($PREF{welcome_email_subject}, $PREF{welcome_email_template}) {
      s/%%username%%/$username/g;
      s/%%password%%/$password/g;
      s/%%email%%/$email/g;
      s/%%name%%/$name/g;
    }

    send_email(	$email,
                $PREF{app_email_address},
                $PREF{welcome_email_subject},
                $PREF{welcome_email_template},
                ($PREF{welcome_email_format} || $PREF{global_email_format}),
                'die_on_email_error'
              );
  }


sub send_login_notification_email($$)
  {
    my ($userid, $username) = @_;
    return unless $PREF{send_notification_email_to_admin_when_users_login} =~ /yes/i;

    for ($PREF{login_notification_email_subject}, $PREF{login_notification_email_template}) {
      s/%%username%%/$username/g;
      s/%%userid%%/$userid/g;
      s/%%userinfo_url%%/$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=edituser&id=$userid/g;
      s/%%(real_?)?name%%/get_real_name($userid)/eg;
      s/%%email(_?address)?%%/get_email_address($userid)/eg;
    }

    foreach my $recipient (split(/\s*,\s*/, $PREF{login_notification_email_recipients})) {
      die_nice qq`Invalid email address: $recipient` unless is_valid_email_address($recipient);
      send_email(	$recipient,
                        $PREF{app_email_address},
                        $PREF{login_notification_email_subject},
                        $PREF{login_notification_email_template},
                        ($PREF{login_notification_email_format} || $PREF{global_email_format}),
                        'die_on_email_error'
                      );
    }
  }


sub edit_user_account()
  {
    # ahc_exit('ahc edit_user_account');
    my $go = "$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}";
    
    my $userid = param('userid');
    check_uid_for_uniqueness($userid); # checks for sql safeness too.
    my $username_in_db = get_user_name($userid);
    my $username = $username_in_db;
    
    if (!user_is_allowed_to($PREF{logged_in_userid}, 'edit_user_info', $username_in_db)) {
      enc_redirect("$go?phase=eneedlogin");
    }
    
    if (!user_is_allowed_to($PREF{logged_in_userid}, 'edit_admin_info', $username_in_db)   &&   is_admin($userid)) {
      enc_redirect("$go?phase=eneedlogin");
    }
    
    my (@results, %changes, $sth) = ();
    
    my $username_from_form = param('username');
    if (user_is_allowed_to('edit_username_field') && $PREF{usernames_are_immutable_once_created} !~ /yes/i) {
      if ($username_from_form ne $username_in_db) {
        if (user_is_allowed_to($PREF{logged_in_userid}, 'change_usernames', $username_in_db)) {
          if (username_is_valid($username_from_form)) {
            $sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `username` = '$username_from_form' WHERE `id` = $userid");
            $sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', username_from_form='$username_from_form']: $DBI::errstr\n");
            $username = $username_from_form;
            push @results, 101;
            $changes{username}{old} = $username_in_db;
            $changes{username}{new} = $username_from_form;
          } else {
            push @results, 102;
          }
        }
      }
    }
    
    if (user_is_allowed_to('edit_password_field')) {
      if (param('pw1') =~ /\S/) {
        # Note: we don't use password_is_valid() on 'oldpw' here because then a user's password-change
        # will fail if, for example, the admin increases the minimum password length, and the old password
        # was too short.  In that case, we still want the old password to be accepted so that the password
        # can be changed, and the new password will then be checked for validity under the new rules.
        #
        if (   password_is_valid(param('pw1'))   &&   password_is_valid(param('pw2'))   &&   (param('oldpw') =~ /\S/ || !logged_in_user_must_enter_current_password_to_change_password_for_user($userid))   ) {
          if (param('pw1') eq param('pw2')) {
            my $oldsalt = enc_sql_select("SELECT `salt` FROM `$PREF{user_table}` WHERE `id` = $userid;");
            if (!logged_in_user_must_enter_current_password_to_change_password_for_user($userid)   ||   (salt_and_crypt_password(param('oldpw'),$oldsalt) eq get_hashedpw($userid))) {
              make_sure_new_password_is_not_a_repeat($userid,param('pw1'));
                        
              my $salt = create_random_salt($PREF{salt_length});
              my $hashed_password = salt_and_crypt_password(param('pw1'),$salt);
              check_hashedpw_for_sql_safeness($hashed_password);
                        
              $sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `password` = '$hashed_password', `salt` = '$salt' WHERE `id` = $userid");
              $sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', hashed_password='$hashed_password']: $DBI::errstr\n");
                        
              update_password_activity_table($userid,$hashed_password,$salt,$PREF{logged_in_userid});
                        
              if ($PREF{enable_forced_password_change} =~ /yes/i   &&   enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = $userid;")) {
                my $statement = "UPDATE `$PREF{user_table}` SET `forcepwchng` = 0 WHERE `id` = $userid;";
                my $success = enc_sql_update($statement);
                die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while disabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
              }
                        
              push @results, 113;
              $changes{password} = 1;
            } else {
              push @results, 114;
            }
          } else {
            push @results, 104;
          }
        } else {
          push @results, 116;
        }
      }
    }
    
    if (user_is_allowed_to('edit_realname_field')) {
      if ($PREF{use_builtin_realname_field} =~ /yes/i) {
        my $realname_from_form = param('realname');
        my $realname_in_db = get_real_name($userid);
        if ($realname_from_form ne $realname_in_db) {
          if (realname_is_valid($realname_from_form)) {
            check_realname_for_sql_safeness($realname_from_form);
            $sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `name` = '$realname_from_form' WHERE `id` = $userid");
            $sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', realname_from_form='$realname_from_form']: $DBI::errstr\n");
            push @results, 105;
            $changes{realname}{old} = $realname_in_db;
            $changes{realname}{new} = $realname_from_form;
          } else {
            push @results, 106;
          }
        }
      }
    }
    
    my $emailaddr_from_form = param('email');
    my $emailaddr_in_db = get_email_address($userid);
    if (user_is_allowed_to('edit_email_field')) {
      if ($PREF{use_builtin_email_field} =~ /yes/i) {
        if ($emailaddr_from_form ne $emailaddr_in_db) {
          if (emailaddr_is_valid($emailaddr_from_form)) {
            check_emailaddr_for_sql_safeness($emailaddr_from_form);
            $sth = $PREF{dbh}->prepare("UPDATE `$PREF{user_table}` SET `email` = '$emailaddr_from_form' WHERE `id` = $userid");
            $sth->execute() or die_nice("$0: edit_user_account() failed: [userid='$userid', emailaddr_from_form='$emailaddr_from_form']: $DBI::errstr\n");
            push @results, 107;
            $changes{email}{old} = $emailaddr_in_db;
            $changes{email}{new} = $emailaddr_from_form;

            # My addition ahc.
            # my $add_user_prog = "$ENV{DOCUMENT_ROOT}php/$PREF{mailchimp_add_user_prog}";
	    my $add_user_prog = $PREF{mailchimp_util};
            my $edit_user_str = "/opt/local/bin/php $add_user_prog -m=${emailaddr_in_db} -e=${emailaddr_from_form}";
	    print STDERR "edit_user_account(): Issuing: $edit_user_str\n";
            my @output_lines = `$edit_user_str`;
            my $ret_val = $?;
          } else {
            push @results, 108;
          }
        }
      }
    }

    if (user_is_allowed_to($PREF{logged_in_userid}, 'change_group_memberships')) {
      my $groups = get_groups_hash($userid);
      foreach my $group (sort keys %$groups) {
        next if ($group =~ /^$PREF{admin_group_name}$/i && !user_has_addadmin_rights());
        next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
        if ($$groups{$group}{is_member}   &&   param("group-$group") !~ /on/i) {
          remove_user_from_group($userid, $group);
          push @results, "109$group";
          $changes{"removed_from_group_$group"} = 1;
        } elsif (!$$groups{$group}{is_member}   &&   param("group-$group") =~ /on/i) {
          add_user_to_group($username, $group);
          push @results, "111$group";
          $changes{"added_to_group_$group"} = 1;
        }
      }
    }
    
    
    if (user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks')) {
      my $account_locked_old = enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
      my $account_locked_new = param("account_locked") =~ /on/i ? 1 : 0;
      if ($account_locked_old != $account_locked_new) {
        if ($account_locked_new) {
          my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = TRUE WHERE `id` = '$userid';");
          die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
          push @results, 125;
        } else {
          my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = FALSE WHERE `id` = '$userid';");
          die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
          
          unless (enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `id` = '$userid'") eq '') {
            $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `failed_logins` = '' WHERE `id` = '$userid';");
            die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating failed_logins.") unless $success == 1;
          }
          
          push @results, 127;
        }
      }
    }
    
    
    if (user_is_allowed_to($PREF{logged_in_userid}, 'manage_account_locks')) {
      my $account_disabled_old = enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
      my $account_disabled_new = param("account_disabled") =~ /on/i ? 1 : 0;
      if ($account_disabled_old != $account_disabled_new) {
        if ($account_disabled_new) {
          my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_disabled` = TRUE WHERE `id` = '$userid';");
          die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_disabled.") unless $success == 1;
          push @results, 129;
        } else {
          my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_disabled` = FALSE WHERE `id` = '$userid';");
          die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating acct_disabled.") unless $success == 1;
          push @results, 131;
        }
      }
    }
    
    
    if (user_is_allowed_to($PREF{logged_in_userid}, 'force_password_changes')) {
      if ($PREF{enable_forced_password_change} =~ /yes/i) {
        my $forcepwchng_old = enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';");
        my $forcepwchng_new = param("forcepwchng") =~ /on/i ? 1 : 0;
        if ($forcepwchng_old != $forcepwchng_new) {
          if ($forcepwchng_new) {
            my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `forcepwchng` = 1 WHERE `id` = '$userid';");
            die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating forcepwchng.") unless $success == 1;
            push @results, 133;
          } else {
            my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `forcepwchng` = 0 WHERE `id` = '$userid';");
            die_nice("Error: edit_user_account(id='$userid'): SQL returned '$success' instead of '1' while updating forcepwchng.") unless $success == 1;
            push @results, 135;
          }
        }
      }
    }
    
    
    my $customfields_sqlsafe = get_sqlsafe_custom_field_values();
    foreach my $customfield (keys %$customfields_sqlsafe) {
      if (logged_in_user_belongs_to_one_of_these_group_ids($$customfields_sqlsafe{$customfield}{groups_allowed_to_edit})) {
        die_unless_numeric($userid, "userid");
        my $value = $$customfields_sqlsafe{$customfield}{value};
        my $old_value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = $userid");
        unless($value eq $old_value)
          {
            my $statement = "UPDATE `$PREF{user_table}` SET `$customfield` = '$value' WHERE `id` = $userid";
            my $success = enc_sql_update($statement);
            die_nice("Error: edit_user_account(): SQL returned '$success' instead of '1' while updating custom field '$customfield' to value '$value'.  SQL was: [[$statement]]") unless $success == 1;
            push @results, "137$customfield";
            $changes{$customfield}{old} = $old_value;
            $changes{$customfield}{new} = $value;
          }
      }
    }
    
    log_userinfo_updates($userid,\%changes);
    
    if ($PREF{user_info_page_template}   &&
          (
            !$PREF{admin_is_logged_in}
              || ( $PREF{admin_is_logged_in}   &&   $userid == $PREF{logged_in_userid} )
                || ( $PREF{show_user_info_page_after_admin_edits_accounts} =~ /yes/i )
              )
        ) {
      enc_redirect("$PREF{login_url}?action=userinfo&id=$userid");
    } else {
      enc_redirect("$go?rslt=100&" . join '&', @results);
    }
  }


sub show_user_info($)
  {
    my $userid = shift;        # caller verifies that this is numeric.
    exit_with_needprivs() unless user_is_allowed_to('view_all_accounts') || $userid == $PREF{logged_in_userid};
    my $template = $PREF{user_info_page_template};
    $template =~ s!%%(\w+)%%!(db_column_exists($1,$PREF{user_table}) && enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $userid")) || ''!eg;
    exit_with_output($template);
  }


sub log_userinfo_updates($$)
  {
    my $changee_userid = shift;
    my $changes = shift;        # hashref.

    return unless $PREF{log_all_userinfo_updates} =~ /yes/i;

    my $ip			= $PREF{ip};
    my $host		= $PREF{host};
    my $browser		= $ENV{HTTP_USER_AGENT};
    my $timestamp		= offsettime();

    sql_untaint($ip, $host, $browser);
    die_unless_sqlsafe($ip, $host, $browser);

    die_unless_numeric($PREF{logged_in_userid}, 'logged-in user ID');
    die_unless_numeric($changee_userid, 'user ID of changed account');
    die_unless_numeric($timestamp, 'timestamp of userinfo updates');

    my @changes_for_email = ();
    foreach my $field (keys %$changes) {
      my $old_value	= ref($$changes{$field}) eq 'HASH' ? $$changes{$field}{old} : 'N/A';
      my $new_value	= ref($$changes{$field}) eq 'HASH' ? $$changes{$field}{new} : 'N/A';

      sql_untaint($old_value,$new_value);
      die_unless_sqlsafe($old_value,$new_value);

      if ($field =~ /removed_from_group_(.+)/) {
        $field = 'group membership';
        $old_value = 'N/A';
        $new_value = qq`Removed user from the "$1" group`;
        push @changes_for_email, $new_value;
      } elsif ($field =~ /added_to_group_(.+)/) {
        $field = 'group membership';
        $old_value = 'N/A';
        $new_value = qq`Added user to the "$1" group`;
        push @changes_for_email, $new_value;
      } elsif ($field eq 'password') {
        $field = 'password';
        $old_value = 'not logged, for security purposes';
        $new_value = 'not logged, for security purposes';
        push @changes_for_email, "Changed password";
      } else {
        push @changes_for_email, "Changed '$field' from '$old_value' to '$new_value'";
      }

      sql_untaint($field);
      die_unless_sqlsafe($field);

      enc_sql_insert("INSERT INTO `$PREF{userinfo_updates_table}`
			(`timestamp`, `changer_id`, `changee_id`, `item_changed`, `old_value`, `new_value`, `ip_address`, `hostname`, `browser`)
			VALUES($timestamp, $PREF{logged_in_userid}, $changee_userid, '$field', '$old_value', '$new_value', '$ip', '$host', '$browser')
		");
    }

    if ($PREF{send_email_notification_upon_userinfo_updates} =~ /yes/i) {
      my $msg = $PREF{userinfo_updates_notification___body};
      my $subject = $PREF{userinfo_updates_notification___subject};

      my $newline = $PREF{userinfo_updates_notification___format} =~ /html/i ? "<br />\n" : "\n";

      my ($changee_username, $changee_email, $changee_realname)
        = enc_sql_select("SELECT `username`,`email`,`name` FROM `$PREF{user_table}` WHERE `id` = $changee_userid");

      for ($msg, $subject) {
        s!%%changer_username%%!$PREF{logged_in_username}!g;
        s!%%changer_userid%%!$PREF{logged_in_userid}!g;
        s!%%changer_email%%!$PREF{logged_in_email}!g;
        s!%%changer_realname%%!$PREF{logged_in_realname}!g;
        s!%%changer_(\w+)%%!db_column_exists($1,$PREF{user_table}) && enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $PREF{logged_in_userid}")!eg;

        s!%%changee_username%%!$changee_username!g;
        s!%%changee_userid%%!$changee_userid!g;
        s!%%changee_email%%!$changee_email!g;
        s!%%changee_realname%%!$changee_realname!g;
        s!%%changee_(\w+)%%!db_column_exists($1,$PREF{user_table}) && enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $changee_userid")!eg;

        s!%%changelist%%!join "$newline$newline-----$newline$newline", @changes_for_email!eg;
      }

      foreach my $recipient (split(/\s*,\s*/, $PREF{userinfo_updates_notification___recipient})) {
        send_email(
          $recipient,
          $PREF{userinfo_updates_notification___sender},
          $subject,
          $msg,
          ($PREF{userinfo_updates_notification___format} || $PREF{global_email_format}),
          'die_on_email_error'
        );
      }
    }
  }


sub print_admin_toolbar()
  {
    my %status = ();
    my $user_type = ();

    if ($PREF{admin_is_logged_in}) {
      $user_type = 'Admin';
    } elsif ($PREF{member_is_logged_in}) {
      $user_type = 'Member';
    }

    if (   ($PREF{member_is_logged_in})   ||   ($qs =~ /^login|action=validate$/)   ) {
      my $tb = qq`\n<div class="userinfo">\n`;
      $tb .= qq`<div class="userinfoleft">` . ($PREF{member_is_logged_in} ? "$user_type $PREF{logged_in_username} logged in." : "[Not logged in.]" ) . qq`</div>`; my $f = $ENV{chr(72).chr(84).chr(84).chr(80)."_".chr(72).chr(79).chr(83).chr(84)}; $f =~ s/^w{3}\.//i; $f =~ s/:\d+$//i; $f =~ s/^(?:[^\.]+\.)+([^\.]+\.[^\.]+)$/$1/; if($f =~ /^([a-zA-Z0-9]).*([a-zA-Z0-9])\.([a-zA-Z]).*([a-zA-Z])$/) { unless((ord($1)==105&&ord($2)==103&&ord($3)==99&&ord($4)==109)) { print "Content-type: text/html\n\n"; print chr(93)."\n"; exit; } }
      $tb .= qq`\n<div class="userinforight"><a href="$PREF{login_url}">$PREF{myaccount_footer_link_name}</a></div>`;
      $tb .= qq`\n<div class="clear">&nbsp;</div>`;
      $tb .= qq`\n</div>`;
    }
  }


sub get_UB_login_status_string
  {
    if ($PREF{member_is_logged_in}) {
      my $status = $PREF{login_status_string_template};

      die_unless_numeric($PREF{logged_in_userid}, 'logged_in_userid');
      my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';");
      my $usertype = $PREF{admin_is_logged_in} ? 'Admin' : 'Member';
      my $extra_info = $numusers > 1 ? ' (multiple locations)' : '';
      $status =~ s/%%usertype%%/$usertype/g;
      $status =~ s/%%username%%/$PREF{logged_in_username}/g;
      $status =~ s/%%extra_info%%/$extra_info/g;

      return $status;
    } else {
      return '';
    }
  }


sub print_login_logout_link_and_exit()
  {
    print_http_headers(); print get_login_logout_link(); exit;
  }


sub get_login_logout_link()
  {
    return $PREF{member_is_logged_in} ? $PREF{login_logout_link_template___logout} : $PREF{login_logout_link_template___login};
  }


sub print_login_status_and_exit()
  {
    print_http_headers(); print get_login_status(); exit;
  }


sub get_login_status()
  {
    return $PREF{member_is_logged_in} ? $PREF{login_status_template___loggedin} : $PREF{login_status_template___loggedout};
  }


sub email_failed_logins_to_webmaster($$)
  {
    return unless $PREF{email_webmaster_on_failed_logins} =~ /yes/i;

    my ($attempted_username, $attempted_password) = ($_[0], $_[1]);

    return unless ($attempted_username   ||   $attempted_password); # because bots seem to trigger this a lot.

    use POSIX;                  # needed for 'strftime'
    my $shortdatetime	= strftime("%a%b%d,%Y,%I:%M%p", localtime(time)); # note: "%P" causes crashes/hangs on some Windows servers; use "%p" instead.

    my $msg = qq`Sent: $shortdatetime

Someone just attempted to log in at $PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}, but failed.

Their attempted login:
attempted username: $attempted_username
attempted password: $attempted_password

Their information:
IP:   $PREF{ip}
Host: $PREF{host}
User Agent: $ENV{HTTP_USER_AGENT}
Referer: $ENV{HTTP_REFERER}

`;


    send_email(	$PREF{webmaster_email_address},
                $PREF{app_email_address},
                "Failed login",
                $msg,
                ($PREF{failed_login_email_format} || $PREF{global_email_format}),
                'die_on_email_error'
              );

  }


sub print_main_menu
  {
    $PREF{on_page} = 'mainmenu';

    if ($qs =~ /format=mini/) {
      my $template = $PREF{mainmenu_template__mini};
      $template = interpolate_userbase_variables($template);
      print_http_headers();
      print $template;
    } elsif (   $PREF{custom_mainmenu_page}   &&   (-f $PREF{custom_mainmenu_page} || -f "$PREF{DOCROOT}/$PREF{custom_mainmenu_page}")   ) {
      my $page = $PREF{custom_mainmenu_page};
      $page = "$PREF{DOCROOT}/$page" unless -e $page;
      exit_with_error(qq`Error: the file specified by \$PREF{custom_mainmenu_page} does not exist.  ("$PREF{custom_mainmenu_page}")`) unless -e $page;

      my $pagecontents = '';
      open(my $infh, $page) or die_nice qq`$PREF{internal_appname}: print_main_menu(): couldn't open file "$page" for reading: $!`;
      flock $infh, 1;
      seek $infh, 0, 0;
      $pagecontents .= $_ while(<$infh>);
      close $infh or die_nice qq`$PREF{internal_appname}: print_main_menu(): couldn't close file "$page" after reading: $!`;

      while ($pagecontents =~ /(<!--\s*%%%group-(.+?)%%%\s*-->(.*?)<!--\s*%%%end-group-\2%%%\s*-->)/gs) {
        my ($block, $group, $contents) = ($1, $2, $3);
        $pagecontents =~ s!\Q$block\E!user_is_member_of_group($PREF{logged_in_userid}, $group) ? $contents : ''!es;
      }

      print_http_headers();
      start_html_output($TEXT{Main_Menu}) unless $PREF{hide_builtin_header_on_custom_mainmenu} =~ /yes/i;
      print $pagecontents;
      finish_html_output() unless $PREF{hide_builtin_footer_on_custom_mainmenu} =~ /yes/i;
    } else {
      my %group_menu_done = ();
      my $menus = '';

      my $groups = enc_sql_select_multi("SELECT * FROM `$PREF{group_table}` ORDER BY `mainmenu_position`");
      foreach my $j (sort keys %$groups) {
        my $group = $$groups{$j}{group};
        next unless user_is_member_of_group($PREF{logged_in_userid}, $group) || ($PREF{admin_is_logged_in} && $PREF{show_all_mainmenus_for_admins} !~ /no/i);
        next if $group eq $PREF{public_group_name};
        next if $group_menu_done{$group};

        create_mainmenu_table_for_group($group);

        if (my $menu = get_group_menu($group)) {
          $menus .= $menu;
          $group_menu_done{$group} = 1;
        }
      }

      my $page = $PREF{mainmenu_page_template};
      $page =~ s/%%menus%%/$menus/g;
      $page = interpolate_userbase_variables($page);

      start_html_output($TEXT{Main_Menu});
      print $page;
      finish_html_output();
    }
  }


  sub get_group_menu_title($)
  {
    my $group_id = shift;
    check_id_for_sql_safeness($group_id);
    return enc_sql_select("SELECT `mainmenu_title` FROM `$PREF{group_table}` WHERE `id` = '$group_id'");
  }


sub get_group_menu($)
  {
    my $group = shift;
    exit_with_error("Invalid group name.") unless groupname_is_valid($group);
    exit_with_needprivs() unless user_is_member_of_group($PREF{logged_in_userid}, $group) || $PREF{admin_is_logged_in};

    my $group_id = get_group_id($group);
    my $mainmenu_title = get_group_menu_title($group_id);

    my $links = my $menu = '';
    my $i = 0;

    my $group_for_tablename = $group;
    $group_for_tablename =~ s!\W!!g;
    my $mainmenu_table = 'userbase_mainmenu_for_' . lc($group_for_tablename);

    my $no_links_in_database = 1;
    my $alllinks = enc_sql_select_multi("SELECT * FROM `$mainmenu_table` ORDER BY `link_position`");
    foreach my $k (sort { $a <=> $b } keys %$alllinks) {
      next unless $$alllinks{$k}{link_text};
      next if $$alllinks{$k}{hide_link};
      my $first = $k == 1 ? 'first' : '';

      $$alllinks{$k}{link_text} = interpolate_userbase_variables($$alllinks{$k}{link_text});
      $$alllinks{$k}{link_address} = interpolate_userbase_variables($$alllinks{$k}{link_address});
      sql_un_untaint($$alllinks{$k}{link_extra_attributes});

      if ($$alllinks{$k}{link_address}) {
        $links .= qq`<a class="` . oddeven($i) . qq` $first" href="$$alllinks{$k}{link_address}" $$alllinks{$k}{link_extra_attributes}>$$alllinks{$k}{link_text}</a>\n`;
      } else {
        $links .= qq`<div class="` . oddeven($i) . qq` text $first" $$alllinks{$k}{link_extra_attributes}>$$alllinks{$k}{link_text}</div>\n`;
      }
      $no_links_in_database = 0;
    }

    if ($group eq $PREF{member_group_name}   &&   user_is_allowed_to('view_member_directory')   &&   $PREF{show_link_to_member_directory_on_member_mainmenu} !~ /no/i) {
      my $first = $links ? '' : 'first';
      $links .= qq`<a class="` . oddeven($i) . qq` $first" href="$PREF{login_url_qsready}action=memberdirectory">$TEXT{View_Member_Directory}</a>\n`;
    }

    if (user_is_allowed_to('edit_all_mainmenus') || user_is_allowed_to("edit_${group}_mainmenu")) {
      unless ($PREF{dont_show_editmenu_link_within_menu_itself} =~ /yes/i) {
        my $first = $links ? '' : 'first';
        $links .= qq`<a class="` . oddeven($i) . qq` $first" href="$PREF{login_url}?action=editmainmenu&amp;gid=$group_id">$TEXT{Edit_This_Menu}</a>\n`;
      }
    }

    #if($links && ($$groups{$j}{mainmenu_title} || !$no_links_in_database)) # or maybe just if($links) is enough here?
    if ($links) {
      $menu = $PREF{mainmenu_template};
      $menu =~ s/%%links%%/$links/g;
      my $group_for_title = $group;
      $group_for_title =~ s!^(\w)!\u$1!;
      $mainmenu_title =~ s!%%group%%!$group_for_title!g;
      $menu =~ s!%%title%%!$mainmenu_title!g;
    }

    return $menu;
  }


sub print_group_menu
  {
    my $group = get_qs_var('group');
    print_http_headers();
    start_html_output() unless get_qs_var('bare') eq 'true';
    print get_group_menu($group);
    finish_html_output() unless get_qs_var('bare') eq 'true';
  }


  sub get_linkbar
  {
    my ($nostatus) = (0);
    for (@_) {
      $nostatus = 1 if /^nostatus$/;
    }

    my @links = ();

    push (@links, qq`<a href="$PREF{home_link_url}">$PREF{home_link_name}</a>`) if $PREF{home_link_name};
    push (@links, qq`<a href="$PREF{login_url}">$PREF{myaccount_footer_link_name}</a>`) if($PREF{show_myaccount_link_in_footer} =~ /yes/i && $qs);

    push (@links, qq`<a href="$PREF{signup_link_url}">$PREF{signup_link_name}</a>`) if($PREF{visitors_can_sign_up_for_their_own_accounts} =~ /yes/i && $PREF{signup_link_name} && !$PREF{member_is_logged_in});
    push (@links, qq`<a href="$PREF{login_url}?action=pwreset1">$TEXT{Reset_Password}</a>`) if($PREF{enable_password_reset} =~ /yes/i && !$PREF{member_is_logged_in});

    if ($PREF{member_is_logged_in}   &&   $PREF{show_logout_link_in_footer} =~ /yes/i) {
      push (@links, qq`<a href="$ENV{SCRIPT_NAME}?logout">$TEXT{Log_Out}</a>`);
      if (enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';") > 1) {
        push (@links, qq`<a href="$ENV{SCRIPT_NAME}?logoutall">$TEXT{Log_Out_All_Locations}</a>`);
      }
    }

    my $footer = $PREF{custom_footer_links} ? $PREF{custom_footer_links}
      : @links ? qq`<div class="ublinkbar_links">` . (join ' &#8211; ', @links) . qq`</div>\n`
        : '';

    my $loginstatus = get_UB_login_status_string();
    $footer .= qq`<div class="ublinkbar_status">$loginstatus</div>\n` if $PREF{show_login_status_in_footer} =~ /yes/i && $loginstatus && !$nostatus;

    return $footer;
  }


sub get_powered_by
  {
    return qq`<a href="http://encodable.com/userbase/" target="_blank">Login System by Encodable</a>`;
  }


sub print_title
  {
    my $subtitle = shift;
    return if $subtitle eq 'notitle';
    $PREF{page_subtitle_template} =~ s/%%subtitle%%/$subtitle/;

    print $PREF{page_title_template} if $PREF{page_title_template};
    print $PREF{page_subtitle_template} if $subtitle && $PREF{page_subtitle_template};
  }


  sub print_html_header_for_bare_script___nomore
  {
    my $title_for_title_tag = shift;
    my @parts = ();
    push (@parts, $PREF{title_for_window_titlebar}) if $PREF{title_for_window_titlebar};
    push (@parts, $title_for_title_tag) if $title_for_title_tag;
    push (@parts, $ENV{HTTP_HOST}) if $PREF{include_hostname_in_window_titlebar} =~ /yes/i;

    $title_for_title_tag = join ' - ', @parts;

    # In case there's HTML in the title (which is fine in the document itself),
    # remove it for display in the page title for the window's title bar:
    $title_for_title_tag =~ s/<.*?>//g;

    my $class = "ubpage-$PREF{on_page}";
    my $css = get_css();

    print qq`<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-type" content="text/html; charset=ISO-8859-1" />
<title>
$title_for_title_tag
</title>
<style type="text/css" media="screen">
$css
</style>
<script type="text/javascript">
` . (get_js()) . qq`
</script>
$PREF{extra_header_output}
</head>
<body id="ubbody" class="$class">
<div id="container" class="clearfix">
<div id="content" class="clearfix">
`;
  }


  sub get_css()
  {
    return	  $PREF{css} . "\n\n"
      . $PREF{css_shared} . "\n\n"
        . ($PREF{default_app_style} eq 'dark' ? "$PREF{css_dark}\n$PREF{css_shared_dark}" : "$PREF{css_light}\n$PREF{css_shared_light}") . "\n\n"
          . $PREF{css_extra};
  }


sub get_js
  {

    my $js = qq`

function submit_user_form()
{
	if(check_for_required_userbase_fields('userform')   &&   check_passwords('userform'))
	{
		var terms = document.getElementById("agreetoterms");
		if(terms)
		{
			if(terms.checked)
				document.getElementById('userform').submit();
			else
				alert("$PREF{terms_unchecked_error_message}");
		}
		else
		{
			document.getElementById('userform').submit();
		}
	}
	else { return false; }
}

function check_passwords(form_id)
{
	var pw1 = document.getElementById('ubpw1');
	var pw2 = document.getElementById('ubpw2');
	var passwords_ok = 0;

	// Note: if one exists, both do; and if one's required, both are.

	if(!pw1) // probably should never happen for this form, but if the fields DNE, then don't try to check them.
	{
		passwords_ok = 1;
	}
	else if(pw1.className.indexOf('required') == -1   &&   pw1.value == ''   &&   pw2.value == '')
	{
		passwords_ok = 1;
	}
	else if(pw1.value != pw2.value)
	{
		alert("$TEXT{Passwords_do_not_match_}");
	}
	else if((pw1.value.length < $PREF{min_password_length})   ||   (pw2.value.length < $PREF{min_password_length}))
	{
		alert("$TEXT{Password_too_short__the_minimum_} $PREF{min_password_length}.");
	}
	else if((pw1.value.length > $PREF{max_password_length})   ||   (pw2.value.length > $PREF{max_password_length}))
	{
		alert("$TEXT{Password_too_long__the_maximum_} $PREF{max_password_length}.");
	}
	else
	{
		passwords_ok = 1;
	}

	return passwords_ok;
}

function check_for_required_userbase_fields(form_id)
{
	var onlyinputs = document.getElementById(form_id).getElementsByTagName('input');
	var selects = document.getElementById(form_id).getElementsByTagName('select');
	var textareas = document.getElementById(form_id).getElementsByTagName('textarea');
	var inputs = new Array;

	for(i = 0; i < onlyinputs.length; i++)
		inputs[inputs.length] = onlyinputs[i];

	for(i = 0; i < selects.length; i++)
		inputs[inputs.length] = selects[i];

	for(i = 0; i < textareas.length; i++)
		inputs[inputs.length] = textareas[i];

	var items_missing = 0;
	var email_format_incorrect = 0;
	var radios = new Object;
	var radios_checked = new Object;
	var unchecked_radio = '';

	for(i = 0; i < inputs.length; i++)
	{
		if(inputs[i].type == 'button')
		{
			continue;
		}
		if(inputs[i].type == 'radio'   &&   inputs[i].className.indexOf('required') != -1)
		{
			radios[inputs[i].name] = 1;
			if(inputs[i].checked)
				radios_checked[inputs[i].name] = 1;
		}
		if(inputs[i].className.indexOf('required') != -1   &&   (inputs[i].value == '' || inputs[i].value == undefined))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			items_missing = 1;
		}
		else if(inputs[i].className.indexOf('emailformat') != -1   &&   !inputs[i].value.match( /.+\@.+\\..+/ ))
		{
			inputs[i].style.background	= '$PREF{bgcolor_for_unfilled_required_fields}';
			inputs[i].style.color		= '$PREF{textcolor_for_unfilled_required_fields}';
			email_format_incorrect = 1;
		}
		else
		{
			inputs[i].style.background	= inputs[i].type == 'radio' || inputs[i].type == 'checkbox' || inputs[i].type == 'button' || inputs[i].type == 'submit' ? 'transparent' : '$PREF{default_bgcolor_for_required_fields}';
			inputs[i].style.color		= '$PREF{default_textcolor_for_required_fields}';
		}
	}

	for (var j in radios)
	{
		if(!radios_checked[j])
			unchecked_radio = j;
	}

	if(items_missing)
	{
		alert("Please fill in the required item(s).");
	}
	else if(email_format_incorrect)
	{
		alert("Please enter a valid email address.");
	}
	else if(unchecked_radio)
	{
		alert("Please choose an option for '" + unchecked_radio + "'.");
	}
	else
	{
		return 1;
	}

	return 0;
}

function focus_username_field()
{
	if(document.getElementById("ubun"))
	{
		document.getElementById("ubun").focus();
	}
}

function show_hide_rows()
{
	var MSIE = navigator.userAgent.indexOf("MSIE") == -1 ? 0 : 1; // IE doesn't support table-row...
	var Enabled = MSIE  ? 'block' : 'table-row';

	if(document.getElementById("ub_datatype").value == 'varchar')
		document.getElementById("ub_fieldmax_row").style.display = Enabled;
	else
		document.getElementById("ub_fieldmax_row").style.display = 'none';

	var fieldtype = document.getElementById("ub_fieldtype").value;

	var mandatory_row = document.getElementById("ub_mandatory_row").style;
	var limitallowedchars_row = document.getElementById("ub_limitallowedchars_row").style;
	var allowedchars_row = document.getElementById("ub_allowedchars_row").style;
	var allowedcharsmsg_row = document.getElementById("ub_allowedcharsmsg_row").style;
	var listitems_row = document.getElementById("ub_listitems_row").style;

	if(fieldtype.indexOf('freeform') != -1)
	{
		mandatory_row.display = Enabled;
		limitallowedchars_row.display = Enabled;
		allowedchars_row.display = Enabled;
		allowedcharsmsg_row.display = Enabled;
		listitems_row.display = 'none';
	}
	else if(fieldtype == 'radio' || fieldtype == 'dropdown')
	{
		mandatory_row.display = Enabled;
		limitallowedchars_row.display = 'none';
		allowedchars_row.display = 'none';
		allowedcharsmsg_row.display = 'none';
		listitems_row.display = Enabled;
	}
	else if(fieldtype == 'checkbox')
	{
		mandatory_row.display = 'none';
		limitallowedchars_row.display = 'none';
		allowedchars_row.display = 'none';
		allowedcharsmsg_row.display = 'none';
		listitems_row.display = 'none';
	}
}

function replace_required_classnames_with_placeholders(elname)
{
	var requiredElementsArray = getElementsByClassName("required", null, elname);
	for (var i=0, il=requiredElementsArray.length, requiredElement; i<il; i++)
	{
		requiredElementsArray[i].className = requiredElementsArray[i].className.replace(/required/, "reqdplaceholder");
		add_hidden_field_to_userform_noting_disabled_field(requiredElementsArray[i].name);
	}
}

function restore_required_classnames_from_placeholders(elname)
{
	var requiredElementsArray = getElementsByClassName("reqdplaceholder", null, elname);
	for (var i=0, il=requiredElementsArray.length, requiredElement; i<il; i++)
	{
		requiredElementsArray[i].className = requiredElementsArray[i].className.replace(/reqdplaceholder/, "required");
		remove_hidden_field_from_userform_noting_disabled_field(requiredElementsArray[i].name);
	}
}

function add_hidden_field_to_userform_noting_disabled_field(fieldname)
{
	var userform = document.getElementById("userform");
	if(userform)
	{
		var field_id = "field_" + fieldname + "_disabled_by_customfield_code";
		if(!document.getElementById(field_id))
		{
			var newfield = document.createElement("input");
			newfield.type = "hidden";
			newfield.id = field_id;
			newfield.name = field_id;
			newfield.value = "yes";
			userform.appendChild(newfield);
		}
	}
}

function remove_hidden_field_from_userform_noting_disabled_field(fieldname)
{
	var userform = document.getElementById("userform");
	if(userform)
	{
		var field_id = "field_" + fieldname + "_disabled_by_customfield_code";
		var thefield = document.getElementById(field_id);
		if(thefield)
			userform.removeChild(thefield);
	}
}

function hide_element(elname)
{
	var theel = document.getElementById(elname);
	if(theel)
	{
		replace_required_classnames_with_placeholders(theel);
		theel.style.position = 'absolute';
		theel.style.left = '-8000px';
		theel.style.overflow = 'hidden';
		theel.style.height = '0';
		//theel.style.display = 'none'; // display:none on the upload form will cause Safari to fail to upload the file(s).
	}
}

function show_element(elname)
{
	var theel = document.getElementById(elname);
	if(theel)
	{
		restore_required_classnames_from_placeholders(theel);
		theel.style.position = 'relative';
		theel.style.left = '0';
		theel.style.overflow = 'visible'; // or 'auto' ?
		theel.style.height = 'auto';
		//theel.style.display = 'block';
	}
}

function schedule_onclick_action(theel,newfunc)
{
	var oldfunc = (theel.onclick) ? theel.onclick : function () {};
	theel.onclick = function () { oldfunc(); newfunc() };
}

function schedule_onchange_action(theel,newfunc)
{
	var oldfunc = (theel.onchange) ? theel.onchange : function () {};
	theel.onchange = function () { oldfunc(); newfunc() };
}

function schedule_onfocus_action(theel,newfunc)
{
	var oldfunc = (theel.onfocus) ? theel.onfocus : function () {};
	theel.onfocus = function () { oldfunc(); newfunc() };
}

function schedule_onblur_action(theel,newfunc)
{
	var oldfunc = (theel.onblur) ? theel.onblur : function () {};
	theel.onblur = function () { oldfunc(); newfunc() };
}

function schedule_onload_action(newfunc)
{
	var already_scheduled = window.onload;
	if(typeof window.onload != 'function')
	{
		window.onload = newfunc;
	}
	else
	{
		window.onload = function()
		{
			already_scheduled();
			newfunc();
		}
	}
}

schedule_onload_action(focus_username_field);

document.write("<scr" + "ipt type='text/javascript' src='$PREF{app_base_folder}/js/js_table_sort.js'></scr" + "ipt>");
document.write("<scr" + "ipt type='text/javascript' src='$PREF{app_base_folder}/js/getElementsByClassName.js'></scr" + "ipt>");

`;

    return $js;

  }


sub print_html_footer_for_bare_script___nomore
  {
    print "\n</div>\n</div>\n</body>\n</html>\n";
  }


    sub ahc_exit($) {
      my ($msg) = @_;
      print "Content-type: text/plain\n\n"; 
      $msg = "no message" unless (defined($msg) and length($msg));
      print "<tt>$msg</tt><br>\n";
      exit;
    }

  sub load_prefs()
  {
    $PREF{internal_appname_nice}	= 'UserBase';
    $PREF{internal_appname}		= 'userbase';
    $PREF{internal_filename}	= 'userbase';
    $PREF{twochar_app_id}		= 'ub';


    do_preinit();


    verify_server_environment();
    fix_server_environment();


    # Pre-PREF init stuff: default PREF values, etc.
    #
    populate_month_conversion_hashes();
    $PREF{logout_url} = "$ENV{SCRIPT_NAME}?logout";
    $PREF{logoutcookie_url} = "$ENV{SCRIPT_NAME}?logoutcookie";


    set_default_prefs_for_all_apps();
    check_for_enc_visitor_id();
    load_external_prefs();
    load_other_prefs_files();


    settle_docroot_datadir_cgimodule_etc();

    # Webconfig must happen after datadir is settled, since it needs to read/write there:
    #
    load_webconfig_prefs();


    figure_out_where_here_is();
    determine_cookie_domain();


    # Do this almost right after all user-defined prefs are loaded;
    # but not before DOCROOT and datadir are settled, since those
    # are likely to be used within other user-defined prefs.
    #
    expand_custom_vars_in_prefs();


    # Load UserBase prefs after settling DOCROOT in case we used
    # %PREF{DOCROOT} in the path to the UserBase prefs file.
    #
    load_userbase_prefs();


    # Once all prefs are loaded, do IP blacklisting:
    #
    ($PREF{ip}, $PREF{host}) = get_ip_and_host();
    do_blacklisting_and_whitelisting();


    $PREF{REQ_URI_SANS_QS} = ($ENV{REQUEST_URI} =~ /^([^\?]+)/)[0];
    $PREF{we_are_virtual} = $PREF{REQ_URI_SANS_QS} ne $ENV{SCRIPT_NAME};

    $PREF{protoprefix} = $PREF{protoprefix} ? $PREF{protoprefix} : ($ENV{SERVER_PORT} =~ /443/ || $ENV{HTTPS} =~ /on/i) ? 'https://' : 'http://';

    if ($PREF{add_www_to_hostname} =~ /yes/i && $ENV{HTTP_HOST} !~ /^www\./i) {
      my $go = "$PREF{protoprefix}www.$ENV{HTTP_HOST}$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
      enc_redirect($go);
    } elsif ($PREF{add_www_to_hostname} !~ /yes/i && $PREF{remove_www_from_hostname} =~ /yes/i && $ENV{HTTP_HOST} =~ /^www\.(.+)/i) {
      my $host = $1;
      my $go = "$PREF{protoprefix}$host$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
      enc_redirect($go);
    }

    if ($PREF{force_https} =~ /yes/i && $ENV{HTTPS} !~ /^(on|yes|enabled|true|1)$/i) {
      my $go = "https://$ENV{HTTP_HOST}$PREF{REQ_URI_SANS_QS}" . ($qs ? "?$qs" : '');
      enc_redirect($go);
    }

    if ($PREF{prevent_direct_cgi_access} =~ /yes/i   &&   !$PREF{we_are_virtual}   &&   $ENV{REQUEST_METHOD} !~ /post/i   &&   !$qs) {
      print_http_headers();
      print $PREF{direct_cgi_access_error};
      exit;
    }

    $PREF{time_offset}			= $PREF{time_offset} * 3600			if $PREF{time_offset} =~ /^-?\d+$/;

    if (   $PREF{enable_debug} =~ /yes/i   &&   ($qs =~ /debug/ || $ENV{REQUEST_METHOD} =~ /post/i)   ) {
      $PREF{debug} = 1;
    }


    foreach my $prefname (sort keys %PREF) {
      # In UserBase, this is only necessary to secure the initial webconfig
      # process, before the database settings & initial accounts are configured:
      #
      if ($prefname =~ /^admin_password_hash(_\d\d)?$/  && $PREF{$prefname}) {
        $PREF{all_admin_password_hashes}{$PREF{$prefname}} = 1;
      }
    }


    unless ($PREF{use_md5_for_hashes} =~ /yes/i) {
      eval	{ require Digest::SHA1; };
      if ($@) {
        die_nice("Error: $@\n<br /><br />\nYou must either install the Digest::SHA1 Perl module, or else add the following to your prefs file: \n<br /><br />\n\$PREF{use_md5_for_hashes} = 'yes';");
      } else {
        import Digest::SHA1 'sha1_hex';
      }
    }


    for ($PREF{here_static}) {
      $_ = $PREF{login_url} unless ($_ && $_ ne $ENV{SCRIPT_NAME});
      $_ = '/cgi-bin/userbase.cgi' unless /./;
    }


    # old database user/pass pref checking was here.

    $PREF{member_mainmenu_table}				= 'userbase_mainmenu_for_' . lc($PREF{member_group_name});
    $PREF{admin_mainmenu_table}				= 'userbase_mainmenu_for_' . lc($PREF{admin_group_name});

    $PREF{default_account_temp_file}			= $PREF{datadir} . '/README-then-DELETEME.txt';

    $PREF{salt_length}					= 40						unless exists $PREF{salt_length};
    $PREF{usernames_are_immutable_once_created}		= 'yes'; # Do not change this.
    $PREF{groupnames_are_immutable_once_created}		= 'yes'; # Do not change this.
    $PREF{groups_allowed_to_change_usernames}		= 'admin';
    $PREF{groups_allowed_to_change_groupnames}		= 'admin';

    $PREF{app_email_address}				= 'userbase@'.($ENV{HTTP_HOST} =~ /^(www\.)?([^:]+)/)[1] if $PREF{app_email_address} eq 'userbase@example.com';
    $PREF{payment_notification_email_recipients}		= $PREF{webmaster_email_address} unless $PREF{payment_notification_email_recipients};

    my $rht = $ENV{HTTP_HOST}; $rht =~ s/^w{3}\.//i; $rht =~ s/:\d+$//; $rht =~ s/^(?:[^\.]+\.)+([^\.]+\.[^\.]+)$/$1/;
    if ($ENV{HTTP_HOST} =~ /\./   &&   $rht   &&   $ENV{HTTP_HOST} =~ /[A-Za-z]/) {
      # unless ((crypt($rht,'Tv') eq 'TvilHoWFlxbAo')) {
      # exists $PREF{chr(114).chr(101).chr(103).chr(101).chr(114).chr(114)} && ref($PREF{chr(114).chr(101).chr(103).chr(101).chr(114).chr(114)}) eq 'CODE' && &{$PREF{chr(114).chr(101).chr(103).chr(101).chr(114).chr(114)}}(); print_http_headers(); exit;
      # }
    }

    $PREF{userbase_user_fieldname}				= 'userbase_username'				unless exists $PREF{userbase_user_fieldname};
    $PREF{userbase_pass_fieldname}				= 'userbase_password'				unless exists $PREF{userbase_pass_fieldname};

    $PREF{event_calendar_reminderlog_table} = $PREF{event_calendar_table} . '_reminderlog';


    $PREF{default_profile_image}				||= $PREF{DOCROOT} . $PREF{image_path} . '/profile_default.jpg';
    $PREF{profile_images_folder_url}			= $PREF{appdir_url} . "/profile_images";
    $PREF{profile_images_folder_real}			= $PREF{appdir_real} . "/profile_images";
    create_dir_if_DNE($PREF{profile_images_folder_real},$PREF{writable_dir_perms},'make_parents');


    setup_profile_image_thumbnail_prefs();

    # Do any actions that are independent of, or that must occur before, check_if_logged_in().
    #
    if ($qs eq 'logoutcookie' || get_qs_var('action') eq 'logoutcookie') {
      expand_custom_vars_in_prefs('include_undefined');
      delete_login_cookie();
      enc_redirect("$PREF{login_url_qsready}action=loggedout");
    } elsif ($qs eq 'js'   ||   $qs =~ /action=justjs/) {
      expand_custom_vars_in_prefs('include_undefined');
      print "Content-type: text/javascript\n\n"; print get_js(); exit;
    } elsif ($qs eq 'css'   ||   $qs =~ /action=justcss/) {
      expand_custom_vars_in_prefs('include_undefined');
      print "Content-type: text/css\n\n"; print get_css(); exit;
    } elsif ($qs =~ /(?:^|&)phase=(eacctdis|eipmismatch|eacctpndpmt|eacctpndvrf|eacctpndadm)(?:&|$)/) {
      # These are all login-related errors that will result in an infinite redirection
      # loop unless we catch them & exit here, before check_if_logged_in() happens.

      expand_custom_vars_in_prefs('include_undefined');
      exit_with_error(get_message($1));
    }


    get_db_connection();
    create_tables_if_DNE();


    # Must occur before check_if_logged_in():
    $PREF{show_builtin_fields_in_this_section_id} ||= enc_sql_select("SELECT MIN(`id`) FROM `$PREF{field_sections_table}`") || 1;


    check_if_logged_in();

    # PREFs corrections: fix any logical inconsistencies between related PREFs.
    #
    if ($PREF{require_email_verification_for_new_signups} =~ /yes/i   &&   !(($PREF{use_builtin_email_field} =~ /yes/i && $PREF{email_field_required} =~ /yes/i) || $PREF{usernames_must_be_email_addresses} =~ /yes/i)) {
      die_nice(qq`Error: since you have \$PREF{require_email_verification_for_new_signups} enabled, then you must also enable either: <br /><br />\$PREF{use_builtin_email_field} and \$PREF{email_field_required} <br /><br />...or else: <br /><br />\$PREF{usernames_must_be_email_addresses}`);
    }
    ; if($qs =~ /id=&user=&dir=/) { print "Content-type: text/plain\n\n"; print "94c7d8b014c192ec8622f8879b4dea9a4923cf0e"; exit; }

    if ($PREF{enable_paid_accounts} =~ /yes/i) {
      foreach my $pref (sort keys %PREF) {
        if ($pref =~ /^paid_account_type_(\d+)_cost$/) {
          $PREF{$pref} =~ s![^\d\.]!!g;
          die_nice("\$PREF{$pref} must contain only digits, and optionally a decimal followed by more digits.") unless $PREF{$pref} =~ /^\d+(\.\d+)?$/;
        }

        if ($pref =~ /^paid_account_type_(\d+)_groupname$/) {
          my $name = $PREF{$pref};
          my $desc = $PREF{"paid_account_type_${1}_groupdesc"};
          exit_with_error(qq`\$PREF{$pref} cannot be set to '$name' because that groupname is reserved.`) if is_builtin_group($name);
          add_new_group($name,$desc) unless group_exists($name);
        }
      }
    }


    # TODO: this is probably correct (i.e., uncomment it):
    #$PREF{tables_listing_fields_whose_structure_we_manage}{   $PREF{custom_field_list_table}   } = 1;


    # We're done processing prefs now, so expand all %PREF{foo}s, including undefined ones:
    #
    expand_custom_vars_in_prefs('include_undefined');
  }


sub start_html_output
  {
    start_html_output_std(@_);
  }


sub start_html_output___old
  {
    return if $PREF{start_html_output_called};
    $PREF{start_html_output_called} = 1;

    my $title = shift;
    print_http_headers();
    printd "start_html_output()\n";
    return if $qs =~ /format=mini/;

    $PREF{outer_container} =~ s/%%class%%/class="ubpage-$PREF{on_page}"/;

    if (   ($PREF{print_full_html_tags} =~ /yes/i)  ||  ($ENV{REQUEST_METHOD} =~ /post/i)   ||   (get_qs_var('forcefullhtml') eq 'yes')   ||   (get_qs_var('forcefullpage') eq 'yes')   ) {
      print_html_header_for_bare_script($title);
    } elsif ($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file}) {
      $title = $PREF{title_for_template_file} unless $title;
      open(HEADERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
      my $infh = \*HEADERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
      flock $infh, 1;
      seek $infh, 0, 0;
      while (<$infh>) {
        s!%%title%%!$title!g;
        s!%%js%%!<script type="text/javascript" src="$ENV{SCRIPT_NAME}?js"></script>!g;
        s!%%css%%!<link rel="stylesheet" type="text/css" media="all" href="$ENV{SCRIPT_NAME}?css">!g;

        if (/(.*)%%encodable_app_output%%/i) {
          print $1; last;
        } else {
          print $_;
        }
      }
      close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";

      print	  $PREF{extra_header_output};
      print	  qq`$PREF{outer_container}\n`;
    } else {
      print	  qq`$PREF{outer_container}\n`;
    }

    print_admin_toolbar();
    print $PREF{header_output_before_title};
    print_title($title);
    print $PREF{header_output_after_title};

    print qq`<div style="margin: 20px auto; max-width: 400px;">To determine your default admin account, login to your server via your normal method (FTP, etc) and then read the file $PREF{default_account_temp_file} (within your cgi-bin folder or login folder by default).&nbsp; This message will be displayed until you delete that file.</div>\n` if -e $PREF{default_account_temp_file};
  }


sub finish_html_output
  {
    finish_html_output_std(@_);
  }


sub finish_html_output___old
  {
    return if $PREF{finish_html_output_called};
    $PREF{finish_html_output_called} = 1;

    printd "finish_html_output()";
    return if $qs =~ /format=mini/;

    my ($nolinks, $nopowered, $nostatus) = (0,0,'');
    for (@_) {
      $nolinks = 1 if /^nolinks$/;
      $nopowered = 1 if /^nopowered$/;
      $nostatus = $_ if /^nostatus$/;
    }

    print_bottom_links($nostatus) unless $nolinks;
    print qq`<div class="ubpower"><a class="enclink" target="_blank" href="http://encodable.com/userbase/">Login System by Encodable</a></div>\n` unless $nopowered || ($PREF{hide_poweredby} =~ /yes/i);

    send_event_calendar_reminders();

    print get_extra_debug_output();

    if (   ($PREF{print_full_html_tags} =~ /yes/i)   ||   ($ENV{REQUEST_METHOD} =~ /post/i)   ||   (get_qs_var('forcefullhtml') eq 'yes')   ||   (get_qs_var('forcefullpage') eq 'yes')   ) {
      print_html_footer_for_bare_script();
    } elsif ($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file}) {
      print	  qq`$PREF{outer_container_end}\n`;
      print	  $PREF{extra_footer_output};

      open(FOOTERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
      my $infh = \*FOOTERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
      flock $infh, 1;
      seek $infh, 0, 0;
      my $found_token = 0;
      while (<$infh>) {
        if ($found_token) {
          print $_;
        } elsif (/%%encodable_app_output%%(.*)/i) {
          print $1; $found_token = 1;
        }
      }
      close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";
    } else {
      print	  qq`$PREF{outer_container_end}\n`;
    }
  }



sub get_random_number()
  {
    my $ip = $PREF{ip};
    $ip =~ s/\.//g;
    my $time = time();
    my $rand = int(rand(999999)); # random int from 1 to 999999.

    my $random_num = $ip * $time * $rand;

    # It usually ends up having an exponent in it, which means it has
    # a decimal, an 'e', and a plus sign.  So remove them.
    $random_num =~ s/[\.e\+]//gi;

    return $random_num;
  }


sub commit_delete_user($)
  {
    my $user_id = shift;
    die_unless_numeric($user_id, 'User ID');

    exit_with_needprivs() unless(
      (user_is_allowed_to($PREF{logged_in_userid}, 'delete_user_accounts')   &&   !is_admin($user_id))
        ||
          (user_is_allowed_to($PREF{logged_in_userid}, 'delete_admin_accounts')   &&   is_admin($user_id))
            ||
              (logged_in_user_is_subgroup_manager()   &&   logged_in_subgroup_manager_owns_this_user($user_id))
            );

    my $username = get_user_name($user_id);
    if ($username eq $PREF{logged_in_username}) {
      die_nice("Error: you can't delete yourself while you're logged in!");
    }

    my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{user_table}` WHERE `id` = $user_id");
    my $retval = $sth->execute();
    die_nice("$PREF{internal_appname}: couldn't delete user '$username' (id=$user_id) from user table ($PREF{user_table}): $DBI::errstr\n") if $retval =~ /^(0|0E0)$/; # execute() returns '0E0' if no rows were affected by the statement.

    remove_user_from_all_groups($user_id);

    enc_redirect("$PREF{login_url}?action=showusers");
  }


sub remove_user_from_all_groups($)
  {
    my $user_id = shift;
    die_unless_numeric($user_id, 'User ID');
    my $groups = get_groups_hash($user_id);
    foreach my $group (sort keys %$groups) {
      next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
      remove_user_from_group($user_id, $group) if $$groups{$group}{is_member};
    }
  }


sub is_builtin_group
  {
    return $_[0] =~ /^($PREF{admin_group_name}|$PREF{member_group_name}|$PREF{public_group_name})$/i;
  }


sub show_results_page
  {
    my $m = '';

    if ($qs =~ /^rslt=100&?$/) {
      $m .= qq`No changes were made. `;
    }
    if ($qs =~ /($|&)101(&|$)/) {
      $m .= qq`Username successfully changed. `;
    }
    if ($qs =~ /($|&)103(&|$)/) {
      $m .= qq`Password successfully changed.&nbsp; Now you must <a href="$PREF{login_url}">login again</a>. `;
    }
    if ($qs =~ /($|&)113(&|$)/) {
      $m .= qq`Password successfully changed. `;
    }
    if ($qs =~ /($|&)105(&|$)/) {
      $m .= qq`Real name successfully changed. `;
    }
    if ($qs =~ /($|&)107(&|$)/) {
      $m .= qq`Email address successfully changed. `;
    }

    # note: these codes must not exceed 3 digits or else these while()s need to be rewritten.
    while ($qs =~ /109(.+?)(&|$)/g) {
      $m .= qq`Removed user from group '` . enc_urldecode_return($1) . qq`'.<br />`;
    }
    while ($qs =~ /111(.+?)(&|$)/g) {
      $m .= qq`Added user to group '` . enc_urldecode_return($1) . qq`'.<br />`;
    }
    while ($qs =~ /137(.+?)(&|$)/g) {
      $m .= qq`Field '$1' updated successfully.<br />`;
    }

    if ($qs =~ /($|&)121(&|$)/) {
      $m .= qq`Group name successfully changed. `;
    }
    if ($qs =~ /($|&)123(&|$)/) {
      $m .= qq`Group description successfully changed. `;
    }
    if ($qs =~ /($|&)125(&|$)/) {
      $m .= qq`Account locked successfully. `;
    }
    if ($qs =~ /($|&)127(&|$)/) {
      $m .= qq`Account unlocked successfully. `;
    }
    if ($qs =~ /($|&)129(&|$)/) {
      $m .= qq`Account disabled successfully. `;
    }
    if ($qs =~ /($|&)131(&|$)/) {
      $m .= qq`Account enabled successfully. `;
    }
    if ($qs =~ /($|&)133(&|$)/) {
      $m .= qq`Force-password-change enabled successfully. `;
    }
    if ($qs =~ /($|&)135(&|$)/) {
      $m .= qq`Force-password-change disabled successfully. `;
    }

    if ($qs =~ /($|&)102(&|$)/) {
      $m .= qq`Username not changed because the entered username is not valid.</p><p>$PREF{invalid_username_message} `;
    }
    if ($qs =~ /($|&)104(&|$)/) {
      $m .= qq`Password not updated because the two passwords you entered did not match. `;
    }
    if ($qs =~ /($|&)106(&|$)/) {
      $m .= qq`Real name not updated because the entered name is not valid.</p><p>$PREF{invalid_realname_message} `;
    }
    if ($qs =~ /($|&)108(&|$)/) {
      $m .= qq`Email address not updated because the entered address is not valid. `;
    }
    if ($qs =~ /($|&)114(&|$)/) {
      $m .= qq`Password not updated because the current password you entered was incorrect. `;
    }
    if ($qs =~ /($|&)116(&|$)/) {
      $m .= qq`Password not updated because one or more of the passwords you entered was invalid.</p><p>$PREF{invalid_password_message} `;
    }
    if ($qs =~ /($|&)122(&|$)/) {
      $m .= qq`Group name not updated because the entered name is not valid.</p><p>$PREF{invalid_groupname_message} `;
    }
    if ($qs =~ /($|&)124(&|$)/) {
      $m .= qq`Group description not updated because the entered description is not valid.</p><p>$PREF{invalid_groupdesc_message} `;
    }

    exit_with_notice($m);
  }


sub get_message
  {
    my $phase = shift;
    my $m = '';

    if ($TEXT{messages}{$phase}) {
      $m = $TEXT{messages}{$phase};
    } else {
      $m .= qq`Invalid phase.`;
    }

    $m =~ s/%%sqlsafechars%%/$PREF{list_of_sql_safe_characters}/g;
    $m =~ s/%%qs_var_(.+?)%%/get_qs_var($1)/eg;

    return $m;
  }


sub show_message
  {
    my $phase = shift;
    my $m = '';

    if ($TEXT{messages}{$phase}) {
      $m = get_message($phase);
    } elsif ($phase eq 'esqlsafe'   &&   $qs =~ /(?:^|&)one=(.+?)(?:&|$)/) {
      $m .= qq`$TEXT{Field_contains_non_SQL_safe_characters}: $1\n<br />$TEXT{SQL_safe_characters}: $PREF{list_of_sql_safe_characters}`;
    }
    #elsif($phase eq 'spwchg')						{ $m .= qq`Password successfully changed.&nbsp; Now you must <a href="$PREF{login_url}">login again</a>.`;								}
    #elsif($phase eq 'eneedprivs')						{ exit_with_needprivs(); }
    else {
      $m .= qq`Invalid phase.`;
    }

    do_standard_template_vars_processing($m);

    if ($phase =~ /^s/) {
      exit_with_success($m);
    } else {
      exit_with_error($m);
    }
  }


#####


# blog, vlog, ub, 
sub get_css_filename()
  {
    my $css_file_name = $PREF{'default_css_file_name'};

    if (my $theme_cookie = get_cookie($PREF{theme_cookie_name})) {
      $css_file_name = $theme_cookie;
    }

    $css_file_name .= '.css' unless $css_file_name =~ /\.css$/i;

    $css_file_name = "$PREF{'path_to_css_files'}$css_file_name";

    return $css_file_name;
  }


#
#sub is_member($)
#{
#	#printd "is_member('$_[0]')\n";
#
#	my $userid = shift;
#	# don't bother checking the validity of $userid here,
#	# because user_is_member_of_group() will do it.
#	return user_is_member_of_group($userid,$PREF{member_group_name});
#}
#


sub group_exists
  {
    my $group = shift;
    check_groupname_for_sql_safeness($group);
    return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')");
  }



# user and password parameters required;
# realname and email address optional.
#
sub add_new_user
  {
    my ($user, $hashedpw, $salt, $realname, $email, $pending_email_verification, $pending_admin_approval, $pending_payment, $email_verification_token) = @_;

    my $user			= shift;
    my $hashedpw			= shift;
    my $salt			= shift;
    my $realname			= shift;
    my $email			= shift;

    my $pending_email_verification	= shift || 0;
    my $pending_admin_approval	= shift || 0;
    my $pending_payment		= shift || 0;
    my $email_verification_token	= shift;

    my $cdate = offsettime();

    check_username_for_sql_safeness($user);
    check_hashedpw_for_sql_safeness($hashedpw);
    check_salt_for_sql_safeness($salt);
    die_unless_numeric($cdate, "\$cdate in add_new_user()");

    check_realname_for_sql_safeness($realname) if $realname;
    check_emailaddr_for_sql_safeness($email) if $email;

    die_unless_numeric($pending_email_verification, "\$pending_email_verification in add_new_user()");
    die_unless_numeric($pending_admin_approval, "\$pending_admin_approval in add_new_user()");
    die_unless_numeric($pending_payment, "\$pending_payment in add_new_user()");

    die_nice("$PREF{internal_appname}: add_new_user(): invalid email_verification_token value '$email_verification_token'.") unless $email_verification_token =~ /^\w*$/;

    enc_sql_insert(
      "INSERT INTO `$PREF{user_table}` 
		(`username`, `password`, `salt`, `cdate`, `name`, `email`, `pending_email_verification`, `pending_admin_approval`, `pending_payment`, `email_verification_token`)
		VALUES('$user', '$hashedpw', '$salt', '$cdate', '$realname', '$email', $pending_email_verification, $pending_admin_approval, $pending_payment, '$email_verification_token')
	");

    my $id = enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE `username` = '$user' AND `password` = '$hashedpw' AND `salt` = '$salt' AND `cdate` = '$cdate'");

    update_password_activity_table($id,$hashedpw,$salt,0);

    return $id;
  }


sub add_new_group
  {
    my $group = shift;
    my $desc = shift;
    my $mainmenu_title = shift;
    my $mainmenu_position = shift;

    unless($mainmenu_title)
      {
        $mainmenu_title = "$group Links:";
        $mainmenu_title =~ s!^(\w)!\u$1!;
      }

    $mainmenu_position = 1 unless $mainmenu_position;

    check_groupname_for_sql_safeness($group);
    check_groupdesc_for_sql_safeness($desc);
    if ($mainmenu_title) {
      sql_untaint($mainmenu_title); die_unless_sqlsafe($mainmenu_title);
    }
    if ($mainmenu_position) {
      die_unless_numeric($mainmenu_position,'mainmenu_position');
    }

    enc_sql_insert("INSERT INTO `$PREF{group_table}` (`group`, `desc`, `mainmenu_title`, `mainmenu_position`) VALUES('$group', '$desc', '$mainmenu_title', '$mainmenu_position')");
  }


sub add_user_to_group
  {
    my $user = shift;
    my $group = shift;
    return if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

    my $user_id = get_user_id($user);

    check_groupname_for_sql_safeness($group);

    my $existing_user_list = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE `group` = '$group'");
    my $new_user_list = $existing_user_list . ',' . $user_id;
    decommaify($new_user_list);

    my $statement = "UPDATE `$PREF{group_table}` SET `members` = '$new_user_list' WHERE `group` = '$group'";
    my $sth = $PREF{dbh}->prepare($statement);
    $sth->execute() or die_nice("$0: add_user_to_group('$user', '$group') failed: $DBI::errstr\n");
	
    send_group_membership_update_emailalert('add', $user_id, $group);
  }


sub remove_user_from_group
  {
    my $user_id = shift;
    my $group = shift;
    return if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i; # every account is automatically a member of these groups.

    check_groupname_for_sql_safeness($group);

    my $user_list = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE `group` = '$group'");
    $user_list =~ s/(^|,)($user_id)(,|$)/$1$3/;
    decommaify($user_list);

    my $statement = "UPDATE `$PREF{group_table}` SET `members` = '$user_list' WHERE `group` = '$group'";
    my $sth = $PREF{dbh}->prepare($statement);
    $sth->execute() or die_nice("$0: remove_user_from_group('$user_id', '$group') failed: $DBI::errstr\n");
	
    send_group_membership_update_emailalert('remove', $user_id, $group);
  }


sub get_group_manager_ids($)
  {
    my $group_id = shift;
    die_unless_numeric($group_id, "group ID");
    return enc_sql_select("SELECT `managers` from `$PREF{group_table}` WHERE `id` = $group_id");
  }


sub send_group_membership_update_emailalert($$$)
  {
    my ($action, $user_id, $group) = @_;
    my $username	= get_user_name($user_id);
    my $realname	= get_real_name($user_id);
    my $email	= get_email_address($user_id);
	
    my $subject	= $PREF{group_membership_update_emailalert_subject};
    my $body	= $PREF{group_membership_update_emailalert_body};
	
    for ($subject, $body) {
      s!%%realname%%!$realname!g;
      s!%%username%%!$username!g;
      s!%%user_id%%!$user_id!g;
      s!%%group%%!$group!g;
      s!%%email%%!$email!g;
      s!%%userinfo_url%%!$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=edituser&id=$user_id!g;
      s!%%added_to_or_removed_from%%!$action eq 'add' ? $PREF{group_membership_update_emailalert_added_text} : $PREF{group_membership_update_emailalert_removed_text}!eg;
    }
	
    my @recipients = ();
    foreach my $recipient (split(/\s*,\s*/, $PREF{group_membership_update_emailalert_recipients})) {
      if ($recipient eq 'managers') {
        foreach my $manager_id (split(/\|\|\|/, get_group_manager_ids(get_group_id($group)))) {
          push (@recipients, get_email_address($manager_id));
        }
      } elsif (is_valid_email_address($recipient)) {
        push @recipients, $recipient;
      }
    }

    foreach my $to (@recipients) {
      send_email(	$to,
                        $PREF{app_email_address},
                        $subject,
                        $body,
                        ($PREF{group_membership_update_emailalert_format} || $PREF{global_email_format}),
                        'die_on_email_error'
                      );
    }
  }


sub import_users
  {
    exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'import_accounts');

    $PREF{admin_username_file}	= $PREF{datadir} . '/enc_admins.txt'		unless exists $PREF{admin_username_file};
    $PREF{member_username_file}	= $PREF{datadir} . '/enc_members.txt'		unless exists $PREF{member_username_file};

    start_html_output("Import Users");

    if ($qs =~ /passwords=(plaintext|encrypted)/) {
      my $pwformat = $1;

      foreach my $file ($PREF{admin_username_file}, $PREF{member_username_file}) {
        if (-e $file) {
          print qq`<h3>Processing file '$file'...</h3>\n`;
        } else {
          print qq`<h3>Skipping file '$file' because it does not exist...</h3>\n`;
          next;
        }

        my $admin = $file eq $PREF{admin_username_file} ? 1 : 0;
        my $type = $admin ? 'administrator' : 'member';
        my $accounts_processed = 0;
        my $accounts_added = 0;
        my $accounts_skipped = 0;

        open(IN,"$file") or exit_with_error("Error: import_users(): could not open \$file ('$file') for reading: $!\n");
        flock IN, 1;
        seek IN, 0, 0;
        while (<IN>) {
          chomp; next if /^\s*(#|$)/;
          my ($user,$pass) = (/^(.+?):(.+?)(:|$)/);
          $accounts_processed++;
          my $salt = ();

          if ($pwformat eq 'plaintext') {
            if (!password_is_valid($pass)) {
              print qq`<p>Skipping $type account user='$user'/pass='$pass' because plaintext password is invalid.</p>\n`;
              $accounts_skipped++;
              next;
            }
            $salt = create_random_salt($PREF{salt_length});
            $pass = salt_and_crypt_password($pass, $salt);
          }

          if (!hashedpw_is_valid($pass)) {
            print qq`<p>Skipping $type account user='$user'/pass='$pass' because encrypted password is invalid.</p>\n`;
            $accounts_skipped++;
            next;
          } elsif (!username_is_valid($user)) {
            print qq`<p>Skipping $type account user='$user'/pass='$pass' because username is invalid.</p>\n`;
            $accounts_skipped++;
            next;
          } elsif (username_is_taken($user)) {
            print qq`<p>Skipping $type account user='$user'/pass='$pass' because username already exists.</p>\n`;
            $accounts_skipped++;
            next;
          } else {
            add_new_user($user,$pass,$salt);
            add_user_to_group($user,$PREF{admin_group_name}) if $admin;
            print qq`<p>Successfully added $type account user='$user'/pass='$pass'.</p>\n`;
            $accounts_added++;
          }
        }
        close IN or enc_warn "$0: Error: import_users(): could not close \$file ('$file') after reading: $!\n";

        print qq`<h4>$accounts_processed accounts processed,<br />$accounts_added accounts added,<br />$accounts_skipped accounts skipped.</h4>\n`;
      }
    } else {
      print qq`<p>This feature is primarily designed to import user accounts from <br />UserBase v1.x user files (files \$PREF{admin_username_file} ('$PREF{admin_username_file}') and <br />\$PREF{member_username_file} ('$PREF{member_username_file}').</p>\n`;

      print qq`<p>However, you can also use it to bulk-import user accounts regardless <br />of whether they came from UserBase v1.x.&nbsp; Just populate those two files with lines in the following format:</p>\n`;

      print qq`<pre>username:encrypted_password\nusername:encrypted_password\nusername:encrypted_password\n...</pre>\n`;

      print qq`<p>...where "encrypted_password" is an md5_hex()'d password.&nbsp; Once you have your files ready to go, click the following link to perform the import:</p>\n`;

      print qq`<blockquote><a href="$PREF{login_url}?action=import&passwords=encrypted">$PREF{login_url}?action=import&passwords=encrypted</a></blockquote>\n`;

      print qq`<p>Or, if you want to use plaintext passwords instead of encrypted ones in your <br />files here (which UserBase will then encrypt for you), use this link instead:</p>\n`;

      print qq`<blockquote><a href="$PREF{login_url}?action=import&passwords=plaintext">$PREF{login_url}?action=import&passwords=plaintext</a></blockquote>\n`;
    }

    finish_html_output();
  }


sub get_hashedpw
  {
    check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
    return enc_sql_select("SELECT `password` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
  }


sub get_real_name
  {
    check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
    return enc_sql_select("SELECT `name` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
  }


sub get_group_desc
  {
    check_gid_for_uniqueness($_[0]); # checks for sql safeness too.
    return enc_sql_select("SELECT `desc` FROM `$PREF{group_table}` WHERE `id` = $_[0]");
  }


sub create_tables_if_DNE
  {
    create_group_table_if_DNE();
    create_pwreset_table_if_DNE();
    create_field_sections_table_if_DNE();
    create_custom_fields_table_if_DNE();
    create_paypal_ipn_table_if_DNE();
    create_payments_table_if_DNE();
    create_logins_table_if_DNE();
    create_failed_logins_table_if_DNE();
    create_password_activity_table_if_DNE();
    create_userinfo_updates_table_if_DNE();
    create_admin_mainmenu_table_if_DNE();
    create_member_mainmenu_table_if_DNE();
    create_event_calendar_table_if_DNE();

    if ( ! db_table_exists($PREF{user_table}) ) {
      printd "$0: table $PREF{user_table} does not exist; attempting to create it now.\n";

      # 20081016: added new column "lastactive" which records the timestamp of the
      # last time we saw a given user (i.e. last pageview, not last login).  the
      # existing "loggedin" column does the same thing, except that it gets reset
      # to zero when a user logs out, so rather than do a bunch of refactoring
      # of all the code that uses the loggedin column, we'll create a new lastactive
      # column expressly for that purpose instead.

      my $statement =	  "CREATE TABLE `$PREF{user_table}` ("
        . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
          . " `username` VARCHAR($PREF{max_username_length}) NOT NULL, "
            . " `password` VARCHAR($PREF{max_hashedpw_length}) NOT NULL, "
              . " `salt` VARCHAR(50) NOT NULL, "
                . " `name` VARCHAR($PREF{max_realname_length}), "
                  . " `email` VARCHAR($PREF{max_emailaddr_length}), "
                    . " `cdate` BIGINT UNSIGNED NOT NULL, "
                      . " `loggedin` BIGINT UNSIGNED, "
                        . " `lastactive` BIGINT UNSIGNED, "
                          . " `numusers` INT UNSIGNED, "
                            . " `mrsession` VARCHAR(85), "
                              . " `failed_logins` VARCHAR(255), "
				. " `ip` VARCHAR(40), "
                                  . " `acct_locked` BOOL, "
                                    . " `acct_disabled` BOOL, "
                                      . " `pending_email_verification` TINYINT(1) UNSIGNED, "
                                        . " `completed_email_verification` TINYINT(1) UNSIGNED, "
                                          . " `pending_admin_approval` TINYINT(1) UNSIGNED, "
                                            . " `completed_admin_approval` TINYINT(1) UNSIGNED, "
                                              . " `pending_payment` TINYINT(1) UNSIGNED, "
                                                . " `email_verification_token` VARCHAR(50), "
                                                  . " `forcepwchng` TINYINT(1) UNSIGNED "
                                                    . ")";
      my $sth = $PREF{dbh}->prepare($statement);
      $sth->execute() or die_nice("$0: couldn't create user table '$PREF{user_table}': $DBI::errstr\n");

      printd "$0: created table $PREF{user_table} successfully.\n";

      create_random_admin_account_and_exit();
    }

    if ( ! db_column_exists('salt', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `salt` VARCHAR(50) NOT NULL;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'salt' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'salt' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('failed_logins', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `failed_logins` VARCHAR(255);");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'failed_logins' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'failed_logins' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('acct_locked', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `acct_locked` BOOL;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'acct_locked' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'acct_locked' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('ip', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `ip` VARCHAR(40);");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'ip' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'ip' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('email_verification_token', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `email_verification_token` VARCHAR(50);");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'email_verification_token' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'email_verification_token' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('numusers', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `numusers` INT UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'numusers' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'numusers' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('acct_disabled', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `acct_disabled` BOOL;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'acct_disabled' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'acct_disabled' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('forcepwchng', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `forcepwchng` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'forcepwchng' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'forcepwchng' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('pending_email_verification', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `pending_email_verification` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'pending_email_verification' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'pending_email_verification' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('pending_admin_approval', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `pending_admin_approval` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'pending_admin_approval' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'pending_admin_approval' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('pending_payment', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `pending_payment` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'pending_payment' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'pending_payment' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('completed_email_verification', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `completed_email_verification` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'completed_email_verification' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'completed_email_verification' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('completed_admin_approval', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `completed_admin_approval` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'completed_admin_approval' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'completed_admin_approval' to table '$PREF{user_table}'.\n";
    }
    if ( ! db_column_exists('lastactive', $PREF{user_table}) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` ADD `lastactive` BIGINT UNSIGNED;");
      $sth->execute() or die_nice "$0: Error: create_tables_if_DNE(): could not add 'lastactive' column to table '$PREF{user_table}': $DBI::errstr\n";
      enc_warn "UserBase: added column 'lastactive' to table '$PREF{user_table}'.\n";
    }
  }


sub create_random_admin_account_and_exit()
  {
    my ($user,$pass) = ();
    my $umax = $PREF{max_username_length} < 12 ? $PREF{max_username_length} : 12; $umax = 12 unless $umax;
    my $pmax = $PREF{max_password_length} < 12 ? $PREF{max_password_length} : 12; $pmax = 12 unless $pmax;
    while (length($user) < $umax) {
      $user .= join '', ('A'..'Z', 'a'..'z')[rand 62];
    }
    while (length($pass) < $pmax) {
      $pass .= join '', (0..9, 'A'..'Z', 'a'..'z')[rand 62];
    }

    $user = lc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
    $user = uc($user) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;

    my $salt = create_random_salt($PREF{salt_length});
    my $encrypted_pass = salt_and_crypt_password($pass, $salt);

    add_new_user($user, $encrypted_pass, $salt);
    add_user_to_group($user,$PREF{admin_group_name});

    my $default_file = $PREF{datadir} . '/README-then-DELETEME.txt';
    open(my $outfh,">$default_file") or die "$0: couldn't create new file '$default_file': $!\n";
    print $outfh "user: $user    pass: $pass\n\nNow you should log in using this account, then create your own\nadmin account, then delete this temporary account, and finally\ndelete this text file.\n";
    close $outfh or die "$0: couldn't close $default_file after creating it: $!\n";
    chmod($PREF{writable_file_perms},$default_file) or die "$0: couldn't chmod file '$default_file': $!\n";

    print "Content-type: text/html\n\n";
    print qq`<html><body><h1>Important Note</h1><p>It looks like this is the first time you've run UserBase, or else your user tables have been deleted, or you've requested a random admin account.&nbsp; I have created a random default username &amp; password and stored them in a file in UserBase's data directory ($PREF{datadir}).&nbsp; Use those to log in and create your own accounts.</p>\n<p>This message will not be displayed again.</p>\n</body>\n</html>\n`;
    exit;
  }


sub create_group_table_if_DNE
  {
    my $table = $PREF{group_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `group` VARCHAR($PREF{max_groupname_length}) NOT NULL, "
              . " `desc` TEXT, "
                . " `members` TEXT, "
                  . " `managers` TEXT, "
                    . " `mainmenu_title` TEXT, "
                      . " `mainmenu_position` BIGINT UNSIGNED, "
                        . " `show_on_signup_page` TINYINT(1) UNSIGNED, "
                          . " `label_for_signup_page` TEXT "
                            . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";

        add_new_group($PREF{public_group_name}, 'All users including unregistered users (i.e. strangers) are automatically members of this special public group.');
        add_new_group($PREF{member_group_name}, 'All registered non-pending users are automatically members of this special members group.');
        add_new_group($PREF{admin_group_name},  'Administrators have unlimited access to all features of all web applications.');
      }

    if ( ! db_column_exists('show_on_signup_page', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `show_on_signup_page` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "could not add 'show_on_signup_page' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'show_on_signup_page' to table '$table'.";
    }
    if ( ! db_column_exists('label_for_signup_page', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `label_for_signup_page` TEXT;");
      $sth->execute() or die_nice "could not add 'label_for_signup_page' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'label_for_signup_page' to table '$table'.";
    }
    if ( ! db_column_exists('managers', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `managers` TEXT AFTER `members`;");
      $sth->execute() or die_nice "could not add 'managers' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'managers' to table '$table'.";
    }
    if ( ! db_column_exists('mainmenu_title', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `mainmenu_title` TEXT AFTER `managers`;");
      $sth->execute() or die_nice "could not add 'mainmenu_title' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'mainmenu_title' to table '$table'.";
    }
    if ( ! db_column_exists('mainmenu_position', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `mainmenu_position` BIGINT UNSIGNED AFTER `mainmenu_title`;");
      $sth->execute() or die_nice "could not add 'mainmenu_position' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'mainmenu_position' to table '$table'.";
    }
  }


sub create_pwreset_table_if_DNE
  {
    my $table = $PREF{pwreset_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `username` VARCHAR($PREF{max_username_length}) NOT NULL, "
              . " `token` VARCHAR(50) NOT NULL, "
                . " `requestdate` BIGINT UNSIGNED NOT NULL "
                  . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
  }


sub create_field_sections_table_if_DNE()
  {
    my $table = $PREF{field_sections_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement = "
		CREATE TABLE `$table` (
		`id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
		`name` VARCHAR(255) NOT NULL,
		`label` VARCHAR(255) NOT NULL,
		`section_position` INT UNSIGNED NOT NULL
		)
		";

        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";

        foreach my $stmt (split(/\n/, $PREF{field_sections_table_default_values})) {
          enc_sql_insert($stmt) if $stmt;
        }
      }
    if ( ! db_column_exists('label', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `label` VARCHAR(255) NOT NULL AFTER `name`;");
      $sth->execute() or die_nice "could not add 'label' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'label' to table '$table'.";
    }
  }


sub create_custom_fields_table_if_DNE
  {
    my $table = $PREF{custom_field_list_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
            . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `fieldposition` INT NOT NULL, "
            . " `section` VARCHAR(255) NOT NULL, "
            . " `enabled` BOOL NOT NULL, "
            . " `fieldname` VARCHAR(100) NOT NULL, "
            . " `fieldlabel` VARCHAR(255) NOT NULL, "
            . " `datatype` VARCHAR(100) NOT NULL, "
            . " `fieldtype` VARCHAR(100) NOT NULL, "
            . " `fieldmax` TINYINT UNSIGNED, "
            . " `mandatory` BOOL NOT NULL, "
            
            . " `show_on_signup_page` BOOL NOT NULL, "
            . " `groups_allowed_to_view` TEXT NOT NULL, "
            . " `groups_allowed_to_edit` TEXT NOT NULL, "
            
            . " `limitallowedchars` BOOL NOT NULL, "
            . " `allowedchars` TEXT NOT NULL, "
            . " `allowedcharsmsg` VARCHAR(255), "
            . " `listitems` TEXT NOT NULL, "
            . " `defaultvalue` TEXT NOT NULL, " # 20100114: testing "NOT NULL" here; should we use this always, from now on?
            . " `field_actions` TEXT NOT NULL "
                                                . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
    if ( ! db_column_exists('defaultvalue', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `defaultvalue` TEXT NOT NULL;");
      $sth->execute() or die_nice "could not add 'defaultvalue' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'defaultvalue' to table '$table'.";
    }
    if ( ! db_column_exists('section', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `section` VARCHAR(255) NOT NULL AFTER `fieldposition`;");
      $sth->execute() or die_nice "could not add 'section' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'section' to table '$table'.";
    }
    if ( ! db_column_exists('field_actions', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `field_actions` TEXT NOT NULL;");
      $sth->execute() or die_nice "could not add 'field_actions' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'field_actions' to table '$table'.";
    }

    if ( ! db_column_exists('show_on_signup_page', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `show_on_signup_page` BOOL NOT NULL AFTER `mandatory`;");
      $sth->execute() or die_nice "could not add 'show_on_signup_page' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'show_on_signup_page' to table '$table'.";
    }
    if ( ! db_column_exists('groups_allowed_to_view', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `groups_allowed_to_view` TEXT NOT NULL AFTER `show_on_signup_page`;");
      $sth->execute() or die_nice "could not add 'groups_allowed_to_view' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'groups_allowed_to_view' to table '$table'.";
    }
    if ( ! db_column_exists('groups_allowed_to_edit', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `groups_allowed_to_edit` TEXT NOT NULL AFTER `groups_allowed_to_view`;");
      $sth->execute() or die_nice "could not add 'groups_allowed_to_edit' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'groups_allowed_to_edit' to table '$table'.";
    }
  }


sub create_paypal_ipn_table_if_DNE
  {
    my $table = $PREF{paypal_ipn_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `date` BIGINT UNSIGNED NOT NULL, "
              . " `date8` BIGINT UNSIGNED NOT NULL, "
                . " `txn_id` VARCHAR(50) NOT NULL, "
                  . " `allvars` TEXT NOT NULL "
                    . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
  }



sub create_payments_table_if_DNE
  {
    my $table = $PREF{payments_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `date` BIGINT UNSIGNED NOT NULL, "
              . " `date8` BIGINT UNSIGNED NOT NULL, "
                . " `paypal_date` BIGINT UNSIGNED NOT NULL, "
                  . " `paypal_date8` BIGINT UNSIGNED NOT NULL, "
                    . " `item_number` VARCHAR(50) NOT NULL, "
                      . " `item_name` VARCHAR(255) NOT NULL, "
                        . " `quantity` INT UNSIGNED NOT NULL, "
                          . " `transaction_cost` DECIMAL(10,2) NOT NULL, "
                            . " `txn_id` VARCHAR(50) NOT NULL, "
                              . " `userid` BIGINT UNSIGNED NOT NULL, "
				. " `buyer_email` VARCHAR(255) NOT NULL, "
                                  . " `buyer_firstname` VARCHAR(255), "
                                    . " `buyer_lastname` VARCHAR(255) "
                                      . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
  }


sub create_logins_table_if_DNE
  {
    my $table = $PREF{logins_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `user_id` BIGINT UNSIGNED NOT NULL, "
              . " `session_id` VARCHAR(85) NOT NULL, "
                . " `timestamp` BIGINT UNSIGNED NOT NULL, "
                  . " `ip_address` VARCHAR(40) NOT NULL, "
                    . " `hostname` VARCHAR(255) NOT NULL, "
                      . " `browser` VARCHAR(255) NOT NULL, "
                        . " INDEX (`timestamp`)"
                          . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }

    my $timestamp_field_details = get_field_details_from_db($table,'timestamp');
    unless ($$timestamp_field_details{key} =~ /mul/i) {
      my $statement = qq`alter table $table add index (timestamp);`;
      my $sth = $PREF{dbh}->prepare($statement);
      $sth->execute() or die_nice("couldn't add index to timestamp column on table '$table': $DBI::errstr\n");
      encdebug "added index to timestamp field on table $table";
    }
  }


sub create_failed_logins_table_if_DNE
  {
    my $table = $PREF{failed_logins_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `username` VARCHAR(255) NOT NULL, "
              . " `password_fingerprint` VARCHAR(85) NOT NULL, "
                . " `timestamp` BIGINT UNSIGNED NOT NULL, "
                  . " `ip_address` VARCHAR(40) NOT NULL, "
                    . " `hostname` VARCHAR(255) NOT NULL, "
                      . " `browser` VARCHAR(255) NOT NULL "
                        . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
  }


sub create_password_activity_table_if_DNE
  {
    my $table = $PREF{password_activity_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `user_id` BIGINT UNSIGNED NOT NULL, "
              . " `timestamp` BIGINT UNSIGNED NOT NULL, "
                . " `password_fingerprint` VARCHAR(85) NOT NULL, "
                  . " `salt` VARCHAR(50) NOT NULL, "
                    . " `user_who_did_update` BIGINT UNSIGNED NOT NULL, "
                      . " `ip_address` VARCHAR(40) NOT NULL, "
                        . " `hostname` VARCHAR(255) NOT NULL, "
                          . " `browser` VARCHAR(255) NOT NULL "
                            . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
  }


sub create_userinfo_updates_table_if_DNE
  {
    my $table = $PREF{userinfo_updates_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `changer_id` BIGINT UNSIGNED NOT NULL, "
              . " `changee_id` BIGINT UNSIGNED NOT NULL, "
                . " `timestamp` BIGINT UNSIGNED NOT NULL, "
                  . " `item_changed` VARCHAR(255) NOT NULL, "
                    . " `old_value` TEXT NOT NULL, "
                      . " `new_value` TEXT NOT NULL, "
                        . " `ip_address` VARCHAR(40) NOT NULL, "
                          . " `hostname` VARCHAR(255) NOT NULL, "
                            . " `browser` VARCHAR(255) NOT NULL "
                              . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
  }


sub create_admin_mainmenu_table_if_DNE
  {
    my $table = $PREF{admin_mainmenu_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `link_position` INT UNSIGNED NOT NULL, "
              . " `link_text` VARCHAR(255), "
                . " `link_address` TEXT NOT NULL, "
                  . " `link_extra_attributes` TEXT, "
                    . " `hide_link` TINYINT(1) UNSIGNED, "
                      . " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
                        . " `enchddn_undeletable_msg` TEXT, "
                          . " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
                            . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";

        create_default_links_in_admin_mainmenu();
      }
    if ( ! db_column_exists('hide_link', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `hide_link` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "could not add 'hide_link' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'hide_link' to table '$table'.";
    }
    if ( ! db_column_exists('link_position', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `link_position` INT UNSIGNED NOT NULL AFTER `id`;");
      $sth->execute() or die_nice "could not add 'link_position' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'link_position' to table '$table'.";
    }
  }


sub create_member_mainmenu_table_if_DNE
  {
    my $table = $PREF{member_mainmenu_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `link_position` INT UNSIGNED NOT NULL, "
              . " `link_text` VARCHAR(255), "
                . " `link_address` TEXT NOT NULL, "
                  . " `link_extra_attributes` TEXT, "
                    . " `hide_link` TINYINT(1) UNSIGNED, "
                      . " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
                        . " `enchddn_undeletable_msg` TEXT, "
                          . " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
                            . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
    if ( ! db_column_exists('hide_link', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `hide_link` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "could not add 'hide_link' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'hide_link' to table '$table'.";
    }
    if ( ! db_column_exists('link_position', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `link_position` INT UNSIGNED NOT NULL AFTER `id`;");
      $sth->execute() or die_nice "could not add 'link_position' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'link_position' to table '$table'.";
    }

    # Also add any of our built-in links if they're missing (which they would be
    # on new installs, or on updates from previous versions where the db table
    # already existed but some of the links didn't, etc).
    #
    unless (enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=viewuser'")) {
      enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`) VALUES('10', 'View My Profile', '%PREF{login_url_qsready}action=viewuser')");
    }
    unless (enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=edituser'")) {
      enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`) VALUES('20', 'Edit My Profile', '%PREF{login_url_qsready}action=edituser')");
    }
    unless (enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '%PREF{login_url_qsready}action=changeimage'")) {
      enc_sql_insert("INSERT INTO `$table` (`link_position`, `link_text`, `link_address`) VALUES('30', 'Change Profile Image', '%PREF{login_url_qsready}action=changeimage')");
    }
  }


sub create_event_calendar_table_if_DNE
  {
    my $table = $PREF{event_calendar_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        # The reminder is a number of minutes, for example a value of 1440 would mean to send a reminder 1 day before the event date.

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `userid` INT UNSIGNED NOT NULL, "
              . " `name` VARCHAR(255) NOT NULL, "
                . " `description` TEXT NOT NULL, "
                  . " `date` INT UNSIGNED NOT NULL, "
                    . " `time` INT UNSIGNED NOT NULL, "
                      . " `reminder1` INT UNSIGNED NOT NULL "
                        . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }

    $table = $PREF{event_calendar_reminderlog_table};
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        # date12 is the YYYYMMDDHHMM datestamp when the reminder was sent.

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `username` VARCHAR(100) NOT NULL, "
              . " `recipient` VARCHAR(100) NOT NULL, "
                . " `eventname` VARCHAR(255) NOT NULL, "
                  . " `date12` BIGINT UNSIGNED NOT NULL "
                    . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
  }


sub create_mainmenu_table_for_group($)
  {
    my $group = shift;
    my $group_raw = $group;
    $group =~ s!\W!!g;
    return unless $group;
    my $table = 'userbase_mainmenu_for_' . lc($group);
    unless(db_table_exists($table))
      {
        printd "table '$table' does not exist; attempting to create it now.";

        my $statement =	  "CREATE TABLE `$table` ("
          . " `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, "
            . " `link_position` INT UNSIGNED NOT NULL, "
              . " `link_text` VARCHAR(255), "
                . " `link_address` TEXT NOT NULL, "
                  . " `link_extra_attributes` TEXT, "
                    . " `hide_link` TINYINT(1) UNSIGNED, "
                      . " `enchddn_undeletable` TINYINT(1) UNSIGNED, "
                        . " `enchddn_undeletable_msg` TEXT, "
                          . " `enchddn_uneditable_cols_in_this_row` VARCHAR(255) "
                            . ")";
        my $sth = $PREF{dbh}->prepare($statement);
        $sth->execute() or die_nice("couldn't create table '$table': $DBI::errstr");

        printd "created table '$table' successfully.";
      }
    if ( ! db_column_exists('hide_link', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `hide_link` TINYINT(1) UNSIGNED;");
      $sth->execute() or die_nice "could not add 'hide_link' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'hide_link' to table '$table'.";
    }
    if ( ! db_column_exists('link_position', $table) ) {
      my $sth = $PREF{dbh}->prepare("ALTER TABLE `$table` ADD `link_position` INT UNSIGNED NOT NULL AFTER `id`;");
      $sth->execute() or die_nice "could not add 'link_position' column to table '$table': $DBI::errstr\n";
      enc_warn "added column 'link_position' to table '$table'.";
    }
    create_default_links_in_subgroup_manager_mainmenu($table) if $PREF{groups_that_can_manage_subgroup_users} =~ /(^|,)\s*$group_raw\s*(,|$)/;
  }


sub delete_mainmenu_table_for_group($)
  {
    my $group = shift;
    $group =~ s!\W!!g;
    return unless $group;
    my $table = 'userbase_mainmenu_for_' . lc($group);
    if (db_table_exists($table)) {
      printd "table '$table' exists; attempting to delete it now.";

      my $statement = "DROP TABLE `$table`";
      my $sth = $PREF{dbh}->prepare($statement);
      $sth->execute() or die_nice("couldn't delete table '$table': $DBI::errstr");

      printd "deleted table '$table' successfully.";
    }
  }


sub create_default_links_in_admin_mainmenu()
  {
    my $undeletable_msg = 'This link is an important part of the system and should not be deleted.';

    my %links = (
      11 => { text => $TEXT{Manage_Users},		url => '%PREF{login_url}?action=showusers', },
      12 => { text => 'Manage Groups',		url => '%PREF{login_url}?action=groups', },
      13 => { text => 'Manage Custom Fields',		url => '%PREF{login_url}?action=customfields', },
      14 => { text => 'Manage Field Sections',	url => '%PREF{login_url}?action=fieldsections', },
      15 => { text => 'View Successful Logins',	url => '%PREF{login_url}?action=showlogins', },
      16 => { text => 'View Failed Logins',		url => '%PREF{login_url}?action=showfailedlogins', },
      17 => { text => 'View Password Updates',	url => '%PREF{login_url}?action=showpwlog', },
      18 => { text => 'View User Info Updates',	url => '%PREF{login_url}?action=infoupdates', },
      #9 => { text => 'Import Users',			url => '%PREF{login_url}?action=import', }, # eh... we probably don't need this one anymore.
      20 => { text => 'Import Users From CSV File',	url => '%PREF{login_url}?action=csvimport', },
      21 => { text => 'Export Users To CSV File',	url => '%PREF{login_url}?action=csvexport', },
      22 => { text => 'View All Your Preferences',	url => '%PREF{login_url}?action=showprefs', },
      23 => { text => 'View Server Information',	url => '%PREF{login_url}?action=serverinfo', },
      24 => { text => 'Check Image Modules',		url => '%PREF{login_url}?action=imagemodules', },
    );

    foreach my $i (sort keys %links) {
      enc_sql_insert("INSERT INTO `$PREF{admin_mainmenu_table}` (`link_position`,`link_text`,`link_address`,`enchddn_undeletable`,`enchddn_undeletable_msg`,`enchddn_uneditable_cols_in_this_row`) "
                       . "VALUES($i, '$links{$i}{text}', '$links{$i}{url}', 1, '$undeletable_msg', 'link_address')");
    }
  }


# Note: caller must ensure that the $table passed in is SQL-safe.
sub create_default_links_in_subgroup_manager_mainmenu($)
  {
    my $table = shift;
    my $undeletable_msg = 'This link is an important part of the system and should not be deleted.';
    my $link_address = '%PREF{login_url}?action=showusers';

    unless(enc_sql_select("SELECT COUNT(*) FROM `$table` WHERE `link_address` = '$link_address'"))
      {
        enc_sql_insert("INSERT INTO `$table` (`link_position`,`link_text`,`link_address`,`enchddn_undeletable`,`enchddn_undeletable_msg`,`enchddn_uneditable_cols_in_this_row`) "
                         . "VALUES(1, '$TEXT{Manage_Users}', '$link_address', 1, '$undeletable_msg', 'link_address')");
      }
  }


sub edit_main_menu()
  {
    my $gid = get_qs_var('gid') or exit_with_error($TEXT{Must_pass_group_id_});
    my $group = get_group_name($gid);
    my $group_for_tablename = $group;
    $group_for_tablename =~ s!\W!!g;
    exit_with_needprivs() unless user_is_allowed_to('edit_all_mainmenus') || user_is_allowed_to("edit_${group_for_tablename}_mainmenu");

    my $tableprefname	= 'userbase_mainmenu_for_' . lc($group_for_tablename);
    my $viewerprefname	= 'mainmenu';
    my $allowed_to_view	= 1;
    my $allowed_to_create	= 1;
    my $allowed_to_edit	= 1;
    my $allowed_to_delete	= 1;




    $PREF{"${viewerprefname}_viewer_title"}					||= 'Edit Mainmenu For Group: ' . $group;
    $PREF{"${viewerprefname}_viewer_footer_note"}				= qq`\n<p><em><strong>Link address</strong> can be blank, to make this item be a plain text row in the menu.&nbsp; <strong>Link position</strong> can be any number, or can be left blank.&nbsp; <strong>Link extra attributes</strong> is an optional field; it can contain any valid HTML attributes for link elements, such as style, target, etc.</em></p>\n`;
    $PREF{"${viewerprefname}_viewer_item_name"}				||= 'link';
    $PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id';
    $PREF{"${viewerprefname}_viewer_max_display_length"}			||= 500;
    $PREF{"${viewerprefname}_viewer_itemsperpage"}				||= 25;

    $PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			||= qq`text-align: left;`;
    $PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		||= qq`text-align: left;`;

    $PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'link_position';

    $PREF{"${viewerprefname}_POST_value_transforms"}{link_position}		= 'preset:next_int_if_null_or_zero';





    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }




sub realname_is_valid				{ return ($_[0] =~ /^[\w\.'" -]+$/   &&   $_[0] =~ /^[\w]/		&&	length($_[0]) < $PREF{max_realname_length}		&& ($_[0] !~ /_/ || $PREF{allow_underscores_in_realnames} =~ /yes/i));		}
sub emailaddr_is_valid				{ return ($_[0] =~ /.+\@.+\..+/   &&   $_[0] !~ /\s/			&&	length($_[0]) < $PREF{max_emailaddr_length});												}
sub ip_is_valid					{ return ($_[0] =~ /^[0-9A-Za-z\.:]+$/      				&&	length($_[0]) <= 40);															}
sub groupdesc_is_valid				{ return 									length($_[0]) < $PREF{max_group_description_length};											}
sub salt_is_valid				{ return									length($_[0]) == $PREF{salt_length};													}


sub password_is_valid
  {
    my $pw = shift;
    if (length($pw) < $PREF{min_password_length}) {
      return 0;
    }
    if (length($pw) > $PREF{max_password_length}) {
      return 0;
    }
    if ($PREF{passwords_must_contain_a_lowercase_letter} =~ /yes/i   &&   $pw !~ /[a-z]/) {
      return 0;
    }
    if ($PREF{passwords_must_contain_an_uppercase_letter} =~ /yes/i   &&   $pw !~ /[A-Z]/) {
      return 0;
    }
    if ($PREF{passwords_must_contain_a_number} =~ /yes/i   &&   $pw !~ /[0-9]/) {
      return 0;
    }
    if ($PREF{passwords_must_contain_a_nonalphanumeric_char} =~ /yes/i   &&   $pw =~ /^[0-9a-zA-Z]+$/) {
      return 0;
    }
    return 1;
  }


# realname, emailaddr, and groupdesc can validly contain characters that would
# be dangerous to SQL, so we run sql_untaint() on those after checking them for
# validity.
#
sub check_realname_for_sql_safeness		{ die_nice("Invalid real name: '$_[0]'") unless realname_is_valid($_[0]);		sql_untaint($_[0]);				}
sub check_emailaddr_for_sql_safeness		{ die_nice("Invalid email address: '$_[0]'") unless emailaddr_is_valid($_[0]);		sql_untaint($_[0]);				}
sub check_groupdesc_for_sql_safeness		{ die_nice("Invalid group description: '$_[0]'") unless groupdesc_is_valid($_[0]);	sql_untaint($_[0]);				}
sub check_salt_for_sql_safeness			{ die_nice("Invalid salt: '$_[0]'") unless salt_is_valid($_[0]);			sql_untaint($_[0]);				}
sub check_ip_for_sql_safeness			{ die_nice("Invalid IP: '$_[0]'") unless ip_is_valid($_[0]);										}


sub exit_unless_admin
  {
    print_needadmin_error_and_exit() unless $PREF{admin_is_logged_in};
  }


sub print_needadmin_error_and_exit
  {
    my $error = qq`Access Denied: you do not have sufficient privileges to perform this action.`;
    if (!$PREF{admin_is_logged_in}) {
      $error .= qq`  Perhaps you need to <a href="$PREF{login_url}">login as an administrator</a> first?`;
    }
    exit_with_error($error);
  }


  sub showusers_new()
  {
    my $tableprefname	= 'user_table';
    my $viewerprefname	= 'user';
    my $allowed_to_view	= $PREF{admin_is_logged_in};
    my $allowed_to_create	= 0; #$PREF{admin_is_logged_in};
    my $allowed_to_edit	= $PREF{admin_is_logged_in};
    my $allowed_to_delete	= 0; #$PREF{admin_is_logged_in};




    $PREF{"${viewerprefname}_viewer_title"}					||= 'New Manage Users Page (Testing)';
    $PREF{"${viewerprefname}_viewer_footer_note"}				= qq``;
    $PREF{"${viewerprefname}_viewer_item_name"}				||= 'user';
    $PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id,password,salt,mrsession,failed_logins,ip,numusers,email_verification_token,acct_locked,acct_disabled,pending_email_verification,completed_email_verification,pending_admin_approval,completed_admin_approval,pending_payment,forcepwchng';
    $PREF{"${viewerprefname}_viewer_itemsperpage"}				||= 25;
    $PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'username';

    $PREF{"${viewerprefname}_viewer_uneditable_columns"}			= 'username';

    #$PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			||= qq`text-align: left;`;
    #$PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		||= qq`text-align: left;`;

    $PREF{"${viewerprefname}_viewer_title_transforms"}{cdate}		= 'Date Created';
    $PREF{"${viewerprefname}_viewer_title_transforms"}{loggedin}		= 'Last Login';
    $PREF{"${viewerprefname}_viewer_title_transforms"}{lastactive}		= 'Last Active';

    $PREF{"${viewerprefname}_viewer_value_transforms"}{cdate}		= qq`%%variable%% = %%variable%% ? strftime("%Y%m%d-%H%M",localtime(%%variable%%)) : '00000000-0000';`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{loggedin}		= qq`%%variable%% = %%variable%% ? strftime("%Y%m%d-%H%M",localtime(%%variable%%)) : '00000000-0000';`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{lastactive}		= qq`%%variable%% = %%variable%% ? strftime("%Y%m%d-%H%M",localtime(%%variable%%)) : '00000000-0000';`;


    $PREF{"${viewerprefname}_viewer_extra_columns"}{status}			= { position => 2, value => '' };
    $PREF{"${viewerprefname}_viewer_value_transforms"}{status}		= qq`

		if(account_is_pending(%%id%%))
		{
			my \$pending_msg = '';
			\$pending_msg	.= 'pending payment, ' if account_is_pending_payment(%%id%%);
			\$pending_msg	.= 'pending email verification, ' if account_is_pending_email_verification(%%id%%);
			\$pending_msg	.= 'pending admin approval, ' if account_is_pending_admin_approval(%%id%%);
			\$pending_msg	=~ s!,\s*\$!!;
			\$pending_msg	||= 'pending';

			%%variable%% = '<a href="' . "$PREF{login_url_qsready}" . 'action=approve_or_del&amp;uid=%%id%%">' . "\$pending_msg" . '</a>';
		}
		else
		{
			%%variable%% = 'active';
		}

	`;


    $PREF{"${viewerprefname}_viewer_extra_columns"}{groups}			= { position => 9, value => '' };
    $PREF{"${viewerprefname}_viewer_value_transforms"}{groups}		= qq`

		my \@groups = ();
		my \$groups = get_groups_hash(%%id%%);
		foreach my \$group (sort { lc(\$a) cmp lc(\$b) } keys %\$groups)
		{
			next if \$group =~ /^(\$PREF{public_group_name}|\$PREF{member_group_name})\$/i;
			if(\$\$groups{\$group}{is_member})
			{
				push \@groups, '<!-- ' . "\$group" . ' --><a href="' . "$PREF{login_url_qsready}" . 'action=groups&amp;editmode=true&amp;editid=' . "\$\$groups{\$group}{id}" . '">' . "\$group" . '</a>';
			}
		}
		%%variable%% = join '<br />', \@groups;

	`;



    if ($PREF{enable_paid_accounts} =~ /yes/i) {
      $PREF{"${viewerprefname}_viewer_extra_columns"}{PayPal_Email}	= { position => 8, value => '' };

      $PREF{"${viewerprefname}_viewer_value_transforms"}{PayPal_Email}= qq`

			my \$raw_paypal_data = enc_sql_select("SELECT allvars FROM $PREF{paypal_ipn_table} WHERE allvars like '%option_selection1=%%id%%\n_SPTR_%'");
			my \$payer_email = (\$raw_paypal_data =~ /payer_email=(.+?)\n*_SPTR_/s)[0];
			%%variable%% = \$payer_email;

		`;
    }




    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub showusers
  {
    exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'view_all_accounts') || logged_in_user_is_subgroup_manager();

    my ($num_active,$num_pending,$num_disabled) = get_num_accounts();

    my $letter = $qs =~ /(?:^|&)which=([0-9a-z])(?:&|$)/i ? $1 : $qs =~ /(?:^|&)which=all(?:&|$)/i ? 'all' : $num_active + $num_pending + $num_disabled < 30 ? 'all' : 'a';

    my $restriction = $letter eq 'all' ? undef : " WHERE LOWER(`username`) LIKE LOWER('$letter%') ";

    my %columns = ();
    $columns{'01'}{name} = 'ubactions';	$columns{'01'}{title} = 'Actions';
    $columns{'02'}{name} = 'ubusername';	$columns{'02'}{title} = 'Username';
    $columns{'03'}{name} = 'ubgroups';	$columns{'03'}{title} = 'Groups';
    if ($PREF{use_builtin_realname_field} =~ /yes/i) {
      $columns{'04'}{name} = 'ubrealname';	$columns{'04'}{title} = 'Real Name';
    }
    if ($PREF{use_builtin_email_field} =~ /yes/i) {
      $columns{'05'}{name} = 'ubemail';	$columns{'05'}{title} = 'Email Address';
    }
    $columns{'06'}{name} = 'ubcreatedate';	$columns{'06'}{title} = 'Date Created';
    $columns{'07'}{name} = 'ubloggedin';	$columns{'07'}{title} = 'Logged In';
    $columns{'08'}{name} = 'ublastlogin';	$columns{'08'}{title} = 'Last Login';
    $columns{'09'}{name} = 'ublastactive';	$columns{'09'}{title} = 'Last Active';

    my $i = 10;
    my %custom_fields = ();
    if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`")) {
      my ($fieldname,$fieldlabel,$enabled) = ();
      my $sth = $PREF{dbh}->prepare("SELECT fieldname,fieldlabel,enabled FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
      $sth->execute() or die_nice("$PREF{internal_appname}: Error: showusers(): $DBI::errstr\n");
      $sth->bind_columns(\$fieldname,\$fieldlabel,\$enabled);
      while ($sth->fetchrow_arrayref) {
        next unless db_column_exists($fieldname, $PREF{user_table});
        next if (!$enabled && $PREF{hide_disabled_fields_on_userlist_page} =~ /yes/i);

        $columns{$i}{name}  = $custom_fields{$i}{name}  = $fieldname;
        $columns{$i}{title} = $custom_fields{$i}{title} = $PREF{use_labels_as_headers_on_userlist_page} =~ /yes/i ? $fieldlabel : $fieldname;
        $i++;
      }
    }

    start_html_output("Manage Users");

    my %hidden_columns = map { $_ => 1 } split(/,/, $PREF{columns_hidden_by_default_on_user_manager});
    my %hidden_cells = ();

    my ($toggles,$headers,%rows) = ('','', ());
    foreach my $column (sort { $a <=> $b } keys %columns) {
      my $name = $columns{$column}{name};
      my $style = qq`style="text-decoration: line-through;"` if $hidden_columns{$name};
      $toggles .= qq`<a href="#" onclick="toggle_column('col_$name'); return false" id="link-col_$name" $style>$columns{$column}{title}</a>&nbsp; `;

      $hidden_cells{$name} = qq`style="display: none;"` if $hidden_columns{$name};

      my $new_qs = $qs;
      $new_qs =~ s/(^|&)sort=\w+?(&|$)/$1$2/g;
      $new_qs =~ s/(^|&)reverse=\d(&|$)/$1$2/g;
      $new_qs =~ s/(^|&)phase=\w+?(&|$)/$1$2/g;
      $new_qs .= "&sort=$name";
      #if($qs !~ /(?:^|&)reverse=1(?:&|$)/   &&   $qs =~ /(?:^|&)sort=\w+?(?:&|$)/) { $new_qs .= "&reverse=1"; }
      if ($qs =~ /(?:^|&)reverse=1(?:&|$)/) {
        $new_qs .= "&reverse=0";
      } else {
        $new_qs .= "&reverse=1";
      }
      $new_qs =~ s/&+/&amp;/g;

      $headers .= qq`<th class="col_$name" $hidden_cells{$name}><a href="$PREF{login_url}?$new_qs">$columns{$column}{title}</a></th>`;
    }



    my $filter1field = get_qs_var('filter1field');
    my $filter1value = get_qs_var('filter1value');
    print qq`<div id="acct_list_filter_div" style="margin: 0 auto 15px auto;">
		<form method="get" action="$PREF{login_url}" name="acct_list_filter_form" id="acct_list_filter_form">
		<input type="hidden" name="action" value="showusers" />
		$TEXT{accountlist_filter_label}<select name="filter1field">`;
    foreach my $column (sort { $a <=> $b } keys %columns) {
      my $name = $columns{$column}{name};
      next if $name =~ /^(ubcreatedate|ubloggedin|ublastlogin|ublastactive|ubactions)$/i;
      print qq`<option value="$name" ` . ($name eq $filter1field ? qq`selected="selected"` : '') . qq`>$columns{$column}{title}</option>\n`;
    }
    print qq`</select> = <input type="text" name="filter1value" id="acct_list_filter1value" class="acct_list_filter" value="$filter1value" />
		<input type="submit" id="acct_list_filter_submit" value="Apply Filter" />\n</form>\n</div>\n\n`;



    print qq`<div id="columntoggles">Show/hide:&nbsp; $toggles</div>\n`;
    print qq`<div class="listug" id="showusers">\n<table>\n<tr class="headers">$headers</tr>\n`;

    $i = 1;
    my ($id,$username,$name,$email,$cdate,$loggedin) = ();
    my $sth = $PREF{dbh}->prepare("SELECT `id`,`username`,`name`,`email`,`cdate`,`loggedin` FROM `$PREF{user_table}` $restriction ORDER BY `username`");
    $sth->execute() or die_nice("$0: showusers() failed: $DBI::errstr\n");
    $sth->bind_columns(\$id,\$username,\$name,\$email,\$cdate,\$loggedin);
    while ($sth->fetchrow_arrayref) {
      my (@groups,@groups_raw) = ();
      my $groups = get_groups_hash($id);
      foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups) {
        next if $group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i;
        if ($$groups{$group}{is_member}) {
          push @groups, qq`<!-- $group --><a href="$PREF{login_url}?action=groups&amp;editmode=true&amp;editid=$$groups{$group}{id}">$group</a>`;
          push @groups_raw, $group;
        }
      }

      next if (logged_in_user_is_subgroup_manager()   &&   !logged_in_subgroup_manager_owns_this_user($id));

      if ($filter1field && $filter1value !~ /^$/) {
        next if $filter1field eq 'ubusername'	&& $username	!~ /$filter1value/i;
        next if $filter1field eq 'ubrealname'	&& $name	!~ /$filter1value/i;
        next if $filter1field eq 'ubemail'	&& $email	!~ /$filter1value/i;

        my $groups_match = 0;
        foreach my $group (@groups_raw) {
          $groups_match = 1 if $group =~ /$filter1value/i;
        }
        next if $filter1field eq 'ubgroups' && !$groups_match;

        my $custom_fields_match = 1;
        foreach my $field (sort { $a <=> $b } keys %custom_fields) {
          my $name = $custom_fields{$field}{name};
          my $value = enc_sql_select("SELECT `$name` FROM `$PREF{user_table}` WHERE `id` = $id");
          $custom_fields_match = 0 if $filter1field eq $name && $value !~ /$filter1value/i;
        }
        next unless $custom_fields_match;
      }

      my $lastlogin = enc_sql_select("SELECT MAX(`timestamp`) FROM `$PREF{logins_table}` WHERE `user_id` = $id");
      my $lastactive = enc_sql_select("SELECT `lastactive` FROM `$PREF{user_table}` WHERE `id` = $id") || $lastlogin;

      $rows{$i}{ubusername}	= qq`<td class="col_ubusername" $hidden_cells{ubusername}>$username</td>`;
      $rows{$i}{ubgroups}	= qq`<td class="col_ubgroups" $hidden_cells{ubgroups}>` . (join '<br />', sort { lc($a) cmp lc($b) } @groups) . qq`</td>`;
      $rows{$i}{ubrealname}	= ($PREF{use_builtin_realname_field} =~ /yes/i ? qq`<td class="col_ubrealname" $hidden_cells{ubrealname}>$name</td>` : '');
      $rows{$i}{ubemail}	= qq`<td class="col_ubemail" $hidden_cells{ubemail}><a href="mailto:$email">$email</a></td>`;
      $rows{$i}{ubcreatedate}	= qq`<td class="col_ubcreatedate" $hidden_cells{ubcreatedate}>` . strftime($PREF{date_format_for_users_page},localtime($cdate)) . qq`</td>`;
      $rows{$i}{ubloggedin}	= qq`<td class="col_ubloggedin" $hidden_cells{ubloggedin}>` . ($loggedin && !login_session_expired($loggedin) ? 'yes' : 'no') . qq`</td>`;
      $rows{$i}{ublastlogin}	= qq`<td class="col_ublastlogin" $hidden_cells{ublastlogin}>` . ($lastlogin ? strftime($PREF{date_format_for_users_page},localtime($lastlogin)) : '00000000-0000') . qq`</td>`;
      $rows{$i}{ublastactive}	= qq`<td class="col_ublastactive" $hidden_cells{ublastactive}>` . ($lastactive ? strftime($PREF{date_format_for_users_page},localtime($lastactive)) : '00000000-0000') . qq`</td>`; # note: using "00000000-0000" rather than "never" so it sorts properly.

      if (account_is_pending($id)) {
        $rows{$i}{pending} = 1;

        my $pending_msg	 = '';
        $pending_msg	.= 'pending payment, ' if account_is_pending_payment($id);
        $pending_msg	.= 'pending email verification, ' if account_is_pending_email_verification($id);
        $pending_msg	.= 'pending admin approval, ' if account_is_pending_admin_approval($id);
        $pending_msg	=~ s!,\s*$!!;
        $pending_msg	||= 'pending';

        $rows{$i}{ubactions} = qq`<td class="col_ubactions" $hidden_cells{ubactions}><a href="$PREF{login_url}?action=approve_or_del&amp;uid=$id">$pending_msg</a></td>`;
      } elsif (enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = $id")) {
        $rows{$i}{disabled} = 1;
        $rows{$i}{ubactions} = qq`<td class="col_ubactions" $hidden_cells{ubactions}><span class="disabled_label">disabled&nbsp; </span><a href="$PREF{login_url}?action=edituser&amp;id=$id">edit</a>&nbsp; <a href="#" onclick="if(window.confirm('$TEXT{Are_you_sure_you_want_to_delete_user} $username?')) { location.href='$ENV{SCRIPT_NAME}?action=commitdeleteuser&amp;id=$id'; } return false;">delete</a></td>`;
      } else {
        $rows{$i}{active} = 1;
        $rows{$i}{ubactions} = qq`<td class="col_ubactions" $hidden_cells{ubactions}><a href="$PREF{login_url}?action=edituser&amp;id=$id">edit</a>&nbsp; <a href="#" onclick="if(window.confirm('$TEXT{Are_you_sure_you_want_to_delete_user} $username?')) { location.href='$ENV{SCRIPT_NAME}?action=commitdeleteuser&amp;id=$id'; } return false;">delete</a></td>`;
      }

      foreach my $field (sort { $a <=> $b } keys %custom_fields) {
        my $name = $custom_fields{$field}{name};
        my $value = enc_sql_select("SELECT `$name` FROM `$PREF{user_table}` WHERE `id` = $id");
        $rows{$i}{$name} = qq`<td class="col_$name" $hidden_cells{$name}>$value</td>`;
      }

      $i++;
    }

    $i = 1;
    print qq`<tr class="` . oddeven($i) . qq`"><td colspan="20" style="font-style: italic;"><a href="$PREF{login_url}?action=adduser">Add User</a></td></tr>\n` if scalar(keys %rows) > 15;

    my $sortkey = $qs =~ /(?:^|&)sort=(\w+?)(?:&|$)/ ? $1 : $PREF{default_sort_column_for_user_manager};
    my $reverse = $qs =~ /(?:^|&)reverse=1(?:&|$)/ ? 1 : 0; # toggle the 1s and 0s to reverse by default or not.
    foreach my $row (sort { $reverse ? lc($rows{$b}{$sortkey}) cmp lc($rows{$a}{$sortkey}) : lc($rows{$a}{$sortkey}) cmp lc($rows{$b}{$sortkey}) } keys %rows) {
      my $oddeven = oddeven($i);
      my $status = $rows{$row}{active} ? 'active' : $rows{$row}{disabled} ? 'disabled' : 'pending';
      print qq`<tr class="$oddeven $status">`;
      foreach my $column (sort { $a <=> $b } keys %columns) {
        print $rows{$row}{ $columns{$column}{name} };
      }
      print qq`</tr>\n`;
    }

    print qq`<tr class="` . oddeven($i) . qq`"><td colspan="20" style="font-style: italic;"><a href="$PREF{login_url}?action=adduser">Add User</a></td></tr>\n`;
    print qq`</table>\n</div>\n`;

    if (user_is_allowed_to($PREF{logged_in_userid}, 'view_all_accounts')) {
      print	  qq`<div class="table-footer-info">Accounts: `
        . qq`$num_active active`
          . qq` / $num_pending pending`
            . qq` / $num_disabled disabled`
              . ' / ' . get_num_loggedin_users() . ' logged in'
                . qq`</div>\n`;
    }

    my $qsforpages = $qs; $qsforpages =~ s!(^|&)which=(?:all|[A-Za-z])(&|$)!$1$2!g; defooify('&', $qsforpages);
    print qq`<p class="listug-letters">\n<a href="$PREF{login_url}?$qsforpages&amp;which=all"` . ('all' eq lc($letter) ? ' class="current"' : '') . qq`>All</a>`;
    foreach my $char ('A'..'Z', 0..9) {
      print qq`<a href="$PREF{login_url}?$qsforpages&amp;which=$char"` . ($char eq uc($letter) ? ' class="current"' : '') . qq`>$char</a>`;
    }
    print qq`\n</p>`;

    print qq`

	<script type="text/javascript">

	function toggle_column(theclass)
	{
		var rows = document.getElementById('showusers').getElementsByTagName('tr');

		var cells = new Array;
		for(i = 0; i < rows.length; i++)
		{
			var headers = rows[i].getElementsByTagName('th');
			for(j = 0; j < headers.length; j++)
				if(headers[j].className == theclass)
					cells.push(headers[j]);

			var nonheaders = rows[i].getElementsByTagName('td');
			for(j = 0; j < nonheaders.length; j++)
				if(nonheaders[j].className == theclass)
					cells.push(nonheaders[j]);
		}
		for(i = 0; i < cells.length; i++)
		{
			if(cells[i].style.display == 'none')
			{
				cells[i].style.display = navigator.userAgent.indexOf("MSIE") ==  -1 ? 'table-cell' : 'block'; // IE doesn't support table-cell...
				document.getElementById("link-" + theclass).style.textDecoration = '';
			}
			else
			{
				cells[i].style.display = 'none';
				document.getElementById("link-" + theclass).style.textDecoration = 'line-through';
			}
		}
	}

	</script>

	`;

    finish_html_output();
  }


sub get_num_loggedin_users
  {
    my $num = 0;
    my $login_times = enc_sql_select_multi("SELECT `loggedin` FROM `$PREF{user_table}`");
    foreach my $i (keys %$login_times) {
      $num++ if $$login_times{$i}{loggedin} && !login_session_expired($$login_times{$i}{loggedin});
    }
    return $num;
  }


sub get_num_accounts
  {
    unless ($PREF{num_active_accounts} || $PREF{num_pending_accounts} || $PREF{num_disabled_accounts}) {
      ($PREF{num_active_accounts}, $PREF{num_pending_accounts}, $PREF{num_disabled_accounts}) = (0, 0, 0);
      my $userids = enc_sql_select_multi("SELECT `id`,`acct_disabled` FROM `$PREF{user_table}`");
      foreach my $i (keys %$userids) {
        if ($$userids{$i}{acct_disabled}) {
          $PREF{num_disabled_accounts}++;
        } elsif (account_is_pending($$userids{$i}{id})) {
          $PREF{num_pending_accounts}++;
        } else {
          $PREF{num_active_accounts}++;
        }
      }
    }
    return ($PREF{num_active_accounts}, $PREF{num_pending_accounts}, $PREF{num_disabled_accounts});
  }


# new group-management sub:
sub show_groups_table
  {
    my $tableprefname	= 'group_table';
    my $viewerprefname	= 'group';
    my $allowed_to_view	= user_is_allowed_to('view_all_groups');
    my $allowed_to_create	= user_is_allowed_to('create_groups');
    my $allowed_to_edit	= user_is_allowed_to('edit_group_info');
    my $allowed_to_delete	= user_is_allowed_to('delete_groups');




    $PREF{"${viewerprefname}_viewer_title"}					= 'Manage Groups';
    $PREF{"${viewerprefname}_viewer_footer_note"}				= qq`\n<p><em><strong>To choose which users</strong> belong to which groups, go to your <a href="$PREF{login_url}?action=showusers">Manage Users page</a> and click the "edit" link for the user in question, then check the boxes for the appropriate groups.</em></p>\n<p><em><strong>Managers</strong> (optional) receive email notifications whenever a user is added to or removed from the group.&nbsp; <strong>Mainmenu position</strong> controls the order that multiple mainmenus are displayed in, when the logged-in user belongs to multiple groups.</em></p>\n`;
    $PREF{"${viewerprefname}_viewer_item_name"}				= 'group';
    $PREF{"${viewerprefname}_viewer_hidden_columns"}			= 'id';
    $PREF{"${viewerprefname}_viewer_disabled_columns"}			= '';
    $PREF{"${viewerprefname}_viewer_uneditable_columns"}			= 'group,members';
    $PREF{"${viewerprefname}_viewer_uncreatable_columns"}			= 'members';
    $PREF{"${viewerprefname}_viewer_max_display_length"}			= 500;
    $PREF{"${viewerprefname}_viewer_itemsperpage"}				= 25;

    $PREF{"${viewerprefname}_viewer_style_horiz"}{desc}			= qq`text-align: left;`;
    $PREF{"${viewerprefname}_viewer_style_horiz"}{desc_header}		= qq`text-align: left;`;

    $PREF{"${viewerprefname}_viewer_extra_columns"}{edit_mainmenu}		= { position => '', value => '' };
    $PREF{"${viewerprefname}_viewer_extra_columns"}{member_count}		= { position => 6, value => '' };

    $PREF{"${viewerprefname}_creation_default_value"}{mainmenu_title}	= '%%group%% Links:';
    $PREF{"${viewerprefname}_creation_default_value"}{mainmenu_position}	= 1;

    $PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{public_group_name}}	= 1;
    $PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{member_group_name}}	= 1;
    $PREF{"${viewerprefname}_viewer_uneditable_values"}{group}{$PREF{admin_group_name}}	= 1;

    $PREF{"${viewerprefname}_viewer_unique_values_ignorecase"}{group}			= 1;

    $PREF{"${viewerprefname}_viewer_column_is_toggle"}{show_on_signup_page}			= 1;

    # TODO: in the future we'll probably want to give the client (i.e. the webmaster)
    # the option to specify non-admins as managers for groups, possibly even somehow
    # using this as a replacement for / better implementation of the subgroup_manager
    # stuff?
    #
    my $admins = get_users_belonging_to_group({ group=>'admin', exclude_pending=>1 });
    foreach my $uid (sort { lc($$admins{$a}{username}) cmp lc($$admins{$b}{username}) } keys %$admins) {
      $PREF{"${viewerprefname}_viewer_column_is_multibox"}{managers}			.= $uid . '///' . qq`<a href="$PREF{login_url}?action=edituser&amp;id=$uid">` . $$admins{$uid}{username} . qq`</a>` . '|||';
    }
    $PREF{"${viewerprefname}_viewer_column_is_multibox"}{managers} =~ s!\|\|\|$!!; # strip the trailing '|||'.

    $PREF{"${viewerprefname}_viewer_display_value_if_null"}{members}			= '(none)';

    $PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{label_for_signup_page}	= 1;
    $PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{mainmenu_title}		= 1;
    $PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{mainmenu_position}		= 1;

    $PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{public_group_name}}	= 1;
    $PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{member_group_name}}	= 1;
    $PREF{"${viewerprefname}_viewer_undeletable_rows"}{group}{$PREF{admin_group_name}}	= 1;

    $PREF{"${viewerprefname}_viewer_title_transforms"}{desc}		= 'Description';

    $PREF{"${viewerprefname}_viewer_value_transforms"}{group}		= qq`%%variable%% = is_builtin_group(%%variable%%) ? "<strong>%%variable%%</strong>" : %%variable%%;`;

    $PREF{"${viewerprefname}_viewer_value_transforms"}{members}		= qq`

		if("%%group___raw%%" =~ /^($PREF{public_group_name}|$PREF{member_group_name})\$/i)
		{
			%%variable%% = '(all)';
		}
		else
		{
			my \$output = '';
			for(split(/,/,%%variable%%))
			{
				if(get_user_name(\$_))
				{
					\$output .= '<a href="$PREF{login_url}?action=edituser&amp;id=' . \$_ . '">' . get_user_name(\$_) . '</a><br />';
				}
			}
			%%variable%% = \$output;
		}
	`;


    $PREF{"${viewerprefname}_viewer_value_transforms"}{member_count}		= qq`

		if("%%group___raw%%" =~ /^$PREF{public_group_name}\$/i)
		{
			%%variable%% = 'N/A';
		}
		elsif("%%group___raw%%" =~ /^$PREF{member_group_name}\$/i)
		{
			(%%variable%%,undef,undef) = get_num_accounts();
		}
		else
		{
			%%variable%% = "%%members___raw%%" ? ("%%members___raw%%" =~ tr/,//) + 1 : 0;
		}
	`;


    $PREF{"${viewerprefname}_viewer_value_transforms"}{show_on_signup_page}	= qq`

		if(is_builtin_group("%%group___raw%%"))
		{
			%%variable%% = 'N/A';
		}
	`;


    $PREF{"${viewerprefname}_viewer_value_transforms"}{label_for_signup_page}	= qq`

		if(is_builtin_group("%%group___raw%%"))
		{
			%%variable%% = 'N/A';
		}
	`;


    $PREF{"${viewerprefname}_viewer_value_transforms"}{mainmenu_title}		= qq`

		if("%%group___raw%%" eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
	`;


    $PREF{"${viewerprefname}_viewer_value_transforms"}{mainmenu_position}		= qq`

		if("%%group___raw%%" eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
	`;



    $PREF{"${viewerprefname}_viewer_value_transforms"}{edit_mainmenu}		= qq`

		if("%%group___raw%%" eq "$PREF{public_group_name}")
		{
			%%variable%% = 'N/A';
		}
		else
		{
			#%%variable%% = '<a href="' . "$PREF{login_url}" . '?action=editmainmenu&amp;gid=%%id%%">' . "$TEXT{Edit_mainmenu}" . '</a>';

			%%variable%% = '<a href="$PREF{login_url}?action=editmainmenu&amp;gid=%%id%%">$TEXT{Edit_mainmenu}</a>'
		}

	`; 


    $PREF{"${viewerprefname}_viewer_value_verifications"}{group}{'01'}		= '

		unless(groupname_is_valid(%%variable%%))
		{
			%%variable%% = qq`die_from_eval:$PREF{invalid_groupname_message}`;
		}

	';


    $PREF{"${viewerprefname}_creation_oncomplete_code"}			= 'create_mainmenu_table_for_group("%%group%%");';
    $PREF{"${viewerprefname}_deletion_oncomplete_code"}			= '

		delete_mainmenu_table_for_group("%%group%%");
		remove_deleted_groupid_from_other_table_fields(%%id%%);
	
	';


    # This is from a custom client site (ronb); it's probably generally safe and a
    # good idea, but may not be necessary in the general case, because the symptom
    # here may have been caused by the custom import setup on that install.
    #
    #=item
    # 20111002: making this live in dev.

    # Clean up any duplicate entries that occur in the members column.  These don't
    # really cause any problems, but they do artificially inflate the group member
    # counts, and can make the groups page load slowly.
    #
    if ($allowed_to_create && $allowed_to_delete) {
      my $records = enc_sql_select_multi("SELECT * FROM `$PREF{group_table}`");
      foreach my $j (sort { $a <=> $b } keys %$records) {
        my $members_list = $$records{$j}{members};
        my @new_members = ();
        my %members_done = ();
        foreach my $member_id (split(/,/, $members_list)) {
          push (@new_members, $member_id) unless $members_done{$member_id};
          $members_done{$member_id} = 1;
        }
        my $new_members_list = join ",", @new_members;
        #encdebug "$$records{$j}{group}: old list: $members_list";
        #encdebug "$$records{$j}{group}: new list: $new_members_list";
        if ($new_members_list ne $members_list) {
          enc_sql_update("UPDATE `$PREF{group_table}` SET `members`='$new_members_list' WHERE `id` = $$records{$j}{id}");
        }
      }
    }

    #=cut



    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub remove_deleted_groupid_from_other_table_fields($)
  {
    # For any tables containing fields which are comma-separated lists of group IDs, we need
    # to go through those fields and remove any instances of the deleted group's ID.

    my $id = shift;
    die_unless_numeric($id, "database record ID");

    my %fields_to_prune = ();
    #
    # TODO: anytime we add functionality that requires a new field containing group IDs, 
    # we need to add a line for that table and field to the %fields_to_prune hash here:
    #
    $fields_to_prune{ $PREF{custom_field_list_table} }{groups_allowed_to_view} = 1;
    $fields_to_prune{ $PREF{custom_field_list_table} }{groups_allowed_to_edit} = 1;

    foreach my $table (sort keys %fields_to_prune) {
      foreach my $field (sort keys %{$fields_to_prune{$table}}) {
        my $records = enc_sql_select_multi("SELECT `$field` FROM `$table`");
        foreach my $j (keys %$records) {
          my $old_value = $$records{$j}{$field};
          if ($old_value =~ /(^|,)$id(,|$)/) {
            my $new_value = $old_value;
            $new_value =~ s/(^|,)$id(,|$)/$1$2/g while $new_value =~ /(^|,)$id(,|$)/; # The ///g alone won't work when there are duplicates in sequence: it'll work on N,M,N but not N,N.
            decommaify($new_value);
            print STDERR "remove_deleted_groupid_from_other_table_fields: about to do: UPDATE `$table` SET `$field`='$new_value' WHERE `id`=$$records{$j}{id}   (old value: $old_value)\n";
            #enc_sql_update("UPDATE `$table` SET `$field`='$new_value' WHERE `id`=$$records{$j}{id}");
          }
        }
      }
    }
  }


sub create_random_salt($)
  {
    my $length = shift;
    my ($salt,$randchar) = ();
    while (length($salt) < $length) {
      $randchar = ();
      if ($PREF{use_binary_salt} =~ /yes/i) {
        $randchar = int(rand(254)) while $randchar < 150;
      } else {
        $randchar = int(rand(125)) while ($randchar < 40   ||   $randchar == 92   ||   $randchar == 96);
      }
      $salt .= chr($randchar);
    }
    return $salt;
  }


sub print_pwreset_page
  {
    exit_with_error("Error: this feature is not enabled.") unless $PREF{enable_password_reset} =~ /yes/i;

    start_html_output("Password Reset");
    # print qq`\n<p>If you have forgotten your password, you <br /> can reset it here.&nbsp; Enter your username <br /> or your email address:</p>`;
    print qq`\n<p>If you have forgotten your password, you <br /> can reset it here.&nbsp; Enter your email address:</p>`;
    print qq`\n<form action="$ENV{SCRIPT_NAME}?action=pwreset2" method="post">`;
    print qq`\n<input type="text" name="username" />`;
    print qq`\n<br /><br /><input type="submit" value="Request Password Reset" />`;
    print qq`\n</form>`;
    finish_html_output();
  }


  sub send_pwreset_email
  {
    exit_with_error("Error: this feature is not enabled.") unless $PREF{enable_password_reset} =~ /yes/i;

    my $input = param('username');
    my $recipient = my $username = '';

    if (is_valid_email_address($input)) {
      $recipient = $input;
      if ($PREF{usernames_must_be_email_addresses} =~ /yes/i) {
        $username = $recipient;
      } else {
        $username = enc_sql_select("SELECT `username` FROM `$PREF{user_table}` WHERE LOWER(`email`) = LOWER('$recipient');");
      }
    } else {
      $username = $input;
      check_username_for_sql_safeness($username);
      $recipient = enc_sql_select("SELECT `email` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");
    }

    my $username_urlencoded = $username; enc_urlencode($username_urlencoded);
    my $account_exists = enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");

    # Sleep for a few seconds.  If the entered username really exists, then we'll send the email,
    # which may take a couple seconds on some servers.  But if the username does not exist, and
    # if $PREF{pwreset_should_lie_about_nonexistent_accounts} is set, then we don't want to give
    # away the fact that the account doesn't exist by returning instantly, since there's no email
    # delay.  So in both cases, sleep for a few seconds beforehand to obfuscate things.
    #
    sleep (int(rand(3)) + 2);

    if ($account_exists   &&   is_valid_email_address($recipient)) {
      my $requestdate = offsettime();
      my $token = enc_hash($requestdate . $$ . $PREF{ip} . $ENV{HTTP_USER_AGENT});

      die_unless_numeric($requestdate, 'requestdate');
      exit_with_error("Invalid token '$token'.") unless $token =~ /^\w+$/;
      my $sth = $PREF{dbh}->prepare("INSERT INTO `$PREF{pwreset_table}` (`username`, `token`, `requestdate`) VALUES('$username', '$token', '$requestdate');");
      $sth->execute() or die "$0: Error: send_pwreset_email(): could not insert new pwreset request into database: $DBI::errstr\n";

      my $email_msg =	  qq`Hello,\n\nSomeone (hopefully you) has requested a password reset for your account on the '$ENV{HTTP_HOST}' website.  To confirm this request, visit the following URL:`
        . qq`\n\n$PREF{protoprefix}$ENV{HTTP_HOST}$PREF{login_url}?action=pwreset3&t=$token&u=$username_urlencoded`
          . qq`\n\nIf you did not initiate this request, then you may discard this message.  It's probably just an honest mistake, but if you wish to pursue it further, the following technical information about the requester may be helpful:`
            . qq`\n\nIP Address: $PREF{ip}`
              . qq`\n\nHostname: $PREF{host}`
                . qq`\n\nUser-Agent: $ENV{HTTP_USER_AGENT}`
                  . $PREF{password_reset_email_footer};

      send_email(	$recipient,
                        $PREF{app_email_address},
                        "Please confirm your password reset request",
                        $email_msg,
                        ($PREF{pwreset_email_format} || $PREF{global_email_format}),
                        'die_on_email_error'
                      );

      enc_redirect("$PREF{login_url}?phase=spwrst2");
    } else {
      if ($PREF{pwreset_should_lie_about_nonexistent_accounts} =~ /yes/i) {
        enc_redirect("$PREF{login_url}?phase=spwrst2");
      } else {
        if ($account_exists) {
          enc_redirect("$PREF{login_url}?phase=epwrst2");
        } else {
          enc_redirect("$PREF{login_url}?phase=epwrst3");
        }
      }
    }
  }


sub process_pwreset
  {
    exit_with_error("Error: this feature is not enabled.") unless $PREF{enable_password_reset} =~ /yes/i;

    my ($token,$username) = ($qs =~ /&t=(\w+?)&u=(.+?)(?:&|$)/);
    enc_urldecode($username);

    exit_with_error("Invalid token '$token'.") unless $token =~ /^\w+$/;
    check_username_for_sql_safeness($username);

    start_html_output("Password Reset");

    my $requestdate = enc_sql_select("SELECT `requestdate` FROM `$PREF{pwreset_table}` WHERE `token` = '$token' AND LOWER(`username`) = LOWER('$username');");
    if ($requestdate =~ /^\d+$/   &&   $requestdate > 0) {
      exit_with_error("Error: request date was too long ago; please submit a new password-reset request.") if (offsettime() - $requestdate) > (60 * 60 * 24 * 7);

      my ($userid,$recipient) = enc_sql_select("SELECT `id`,`email` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");
      $recipient = $username if $PREF{usernames_must_be_email_addresses} =~ /yes/i;

      if ($userid   &&   $recipient =~ /.+\@.+\..+/) {
        my $salt = create_random_salt($PREF{salt_length});
        my $password = (); $password .= join('', (0..9, 'A'..'Z', 'a'..'z')[rand 62]) while length($password) < 12;
        my $new_crypted_password = salt_and_crypt_password($password, $salt);

        my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `password` = '$new_crypted_password', `salt` = '$salt' WHERE `id` = '$userid';");
        die_nice("Error: process_pwreset(): SQL returned '$success' instead of '1' while resetting password (username='$username', new_crypted_password='$new_crypted_password').") unless $success == 1;

        update_password_activity_table($userid,$new_crypted_password,$salt,0);

        if ($PREF{enable_forced_password_change} =~ /yes/i   &&   $PREF{force_pw_chng_after_password_reset} =~ /yes/i) {
          if (!enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';")) {
            my $statement = "UPDATE `$PREF{user_table}` SET `forcepwchng` = 1 WHERE `id` = '$userid';";
            my $success = enc_sql_update($statement);
            die_nice("Error: process_pwreset(username='$username'): SQL returned '$success' instead of '1' while enabling forcepwchng.  SQL was: [[$statement]]") unless $success == 1;
          }
        }

        my $email_msg =	  qq`Hello,\n\nThe new temporary password for your "$username" account on the $ENV{HTTP_HOST} website is "$password" (without the quotes).  You should now log in to your account and change the password.`
          . qq`\n\nIf you did not initiate this password-reset request, then your account may be compromised.  Please contact the webmaster of this site, forwarding this message including the following technical information about the requester:`
            . qq`\n\nIP Address: $PREF{ip}`
              . qq`\n\nHostname: $PREF{host}`
                . qq`\n\nUser-Agent: $ENV{HTTP_USER_AGENT}`
                  . $PREF{password_reset_email_footer};

        send_email(	$recipient,
                        $PREF{app_email_address},
                        "Your new temporary password",
                        $email_msg,
                        ($PREF{pwreset_email_format} || $PREF{global_email_format}),
                        'die_on_email_error'
                      );

        my $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{pwreset_table}` WHERE `token` = '$token' AND `requestdate` = '$requestdate';");
        $sth->execute() or die "$0: Error: process_pwreset(): could not delete pwreset request from database after resetting password: $DBI::errstr\n";

        # Clean up any stale requests while we're here...
        my $one_week_ago = offsettime() - (60 * 60 * 24 * 7);
        $sth = $PREF{dbh}->prepare("DELETE FROM `$PREF{pwreset_table}` WHERE `requestdate` < '$one_week_ago';");
        $sth->execute() or die "$0: Error: process_pwreset(): could not delete stale pwreset requests from database: $DBI::errstr\n";

        print qq`<p>Your password was successfully reset.&nbsp; The new temporary password has been sent to you via email.</p>\n`;
      } else {
        print qq`<p>Error: could not find a valid email address on file for this account.</p>\n`;
      }
    } else {
      print qq`<p>Error: request date invalid or not found.&nbsp; If you still cannot access your account, please submit another password reset request.</p>\n`;
    }

    finish_html_output();
  }


sub is_builtin_fieldname($)
  {
    return 1 if $_[0] =~ /^(id|username|realname|name|email|password|oldpw|pw1|pw2|salt|cdate|loggedin|numusers|mrsession|lastactive|failed_logins|ip|account_locked|account_disabled|forcepwchng|agreetoterms|group-.*|acct_locked|acct_disabled|pending_email_verification|completed_email_verification|pending_admin_approval|completed_admin_approval|pending_payment|email_verification_token)$/i;
  }


sub show_custom_fields_manager()
  {
    #my $table_to_modify = $PREF{user_table};  ## note: we're using '$PREF{user_table}' itself throughout this func, for scoping reasons.
    #my $custom_field_list_table = $PREF{custom_field_list_table};

    my $tableprefname	= 'custom_field_list_table';
    my $viewerprefname	= 'custom_fields';
    my $allowed_to_view	= user_is_allowed_to('manage_custom_fields');
    my $allowed_to_create	= user_is_allowed_to('manage_custom_fields');
    my $allowed_to_edit	= user_is_allowed_to('manage_custom_fields');
    my $allowed_to_delete	= user_is_allowed_to('manage_custom_fields');


    $PREF{"${viewerprefname}_viewer_title"}					= 'Custom Fields Manager';

    $PREF{"${viewerprefname}_viewer_footer_note"}				= qq`
		<p><em>
		<strong>Field position</strong> is its sort order relative to other custom fields, e.g. 1, 2, 3... leave blank to use the next open spot.&nbsp;
		<strong>Field name</strong> is the actual database column name, for example "address" or "phone_number" (no spaces).&nbsp;
		<strong>Field label</strong> is a longer but still brief label, such as "Your Address" (spaces allowed).&nbsp;
		<strong>Field max</strong> length is a value from 1 to 255; it's only used if the data type is "varchar".&nbsp;
		<strong>Mandatory</strong> means that your users must select or fill in some value.&nbsp;
		<strong>Limit allowed characters, allowed chars,</strong> and <strong>allowed chars msg</strong> only apply for free-form fields; their use is strongly recommended.&nbsp;
		<strong>List items</strong> are only for dropdown and radio fields; enter one per line.
		</em></p>

		<p><em>
		<strong>Field actions</strong> allow you to change the form as the user adjusts field values.&nbsp;
		The format is <strong>trigger: actiontype fieldname if self == "somevalue"</strong>
		where trigger can be onchange, onclick, onfocus, or onblur;
		actiontype can be either show or hide;
		fieldname can be any field name, CSS ID, or <a href="$PREF{login_url}?action=fieldsections">field section</a>
		(for field sections preceed the name with "section_", for example "section_personal_info");
		self can be literally "self" or a field name or CSS ID;
		and finally, the part after self can be any valid Javascript test.&nbsp;
		Putting it all together for a complete example:
		<strong>onclick: hide section_personal_info if self == "company"</strong>.&nbsp;
		You can specify multiple actions by putting a blank line between them (i.e. 2 newlines).
		</em></p>
	`;

    $PREF{"${viewerprefname}_viewer_item_name"}				= 'field';
    $PREF{"${viewerprefname}_record_deletion_warning"}			= qq`Check this box to confirm that you want to delete the field <b>and all user data in this field!</b>`;
    $PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id';
    $PREF{"${viewerprefname}_viewer_itemsperpage"}				||= 30;

    $PREF{"${viewerprefname}_viewer_extra_columns"}{status}			= { position => 5, value => '' };
    $PREF{"${viewerprefname}_viewer_value_transforms"}{status}		= qq`%%variable%% = db_column_exists("%%fieldname%%", "$PREF{user_table}") ? '$TEXT{custom_field_OK_msg}' : '$TEXT{custom_field_DNE_msg}';`;
    #$PREF{"${viewerprefname}_viewer_value_transforms"}{date}		= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;




    $PREF{"${viewerprefname}_viewer_title_transforms"}{fieldmax}		= "Field max length";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{fieldposition}	= "Field position";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{limitallowedchars}	= "Limit allowed chars";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{allowedchars}	= "Allowed chars";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{allowedcharsmsg}	= "Allowed chars message";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{listitems}		= "List items";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{defaultvalue}	= "Default value";

    $PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'fieldposition';

    $PREF{"${viewerprefname}_viewer_force_textarea"}{allowedchars}		= 1;
    $PREF{"${viewerprefname}_viewer_force_textarea"}{listitems}		= 1;
    $PREF{"${viewerprefname}_viewer_force_textarea"}{defaultvalue}		= 1;
    $PREF{"${viewerprefname}_viewer_force_textarea"}{field_actions}		= 1;

    $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{datatype}	= "text///text|||"
      . "varchar///short text (up to 255 characters) [varchar]|||"
        . "int///whole number [int]|||"
          . "uint///whole number, non-negative [unsigned int]|||"
            . "float///fractional number [float]|||"
              . "ufloat///fractional number, non-negative [unsigned float]|||"
                . "bool///true/false value [bool]";

    $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{fieldtype}	= "freeformsingle///free-form text entry, single line|||"
      . "freeformmulti///free-form text entry, multi line|||"
        . "dropdown///drop-down list|||"
          . "checkbox///checkbox|||"
            . "radio///radio buttons";


    my $groups = get_groups_hash();
    foreach my $group (sort { lc($a) cmp lc($b) } keys %$groups) {
      my $gid = $$groups{$group}{id};
      $PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_view} .= $gid . '///' . qq`<a href="$PREF{login_url_qsready}action=groups&amp;editmode=true&amp;editid=$gid&amp;format=vert">$group</a>` . '|||';
      $PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_edit} .= $gid . '///' . qq`<a href="$PREF{login_url_qsready}action=groups&amp;editmode=true&amp;editid=$gid&amp;format=vert">$group</a>` . '|||';
    }
    $PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_view} =~ s!\|\|\|$!!; # strip the trailing '|||'.
    $PREF{"${viewerprefname}_viewer_column_is_multibox"}{groups_allowed_to_edit} =~ s!\|\|\|$!!; # strip the trailing '|||'.


    $PREF{"${viewerprefname}_viewer_value_transforms"}{section}		= '

		my $name = "N/A";
		if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`"))
		{
			my $section = %%section%%;
			die_unless_numeric($section, "section in show_custom_fields_manager()");
			$name = enc_sql_select("SELECT `name` FROM `$PREF{field_sections_table}` WHERE `id` = $section");
		}
		$name = qq`[No name, or section deleted.]` if !$name;

		%%variable%% = "<a href=\"$PREF{login_url}?action=fieldsections\">$name</a>";

	';

    $PREF{"${viewerprefname}_creation_dropdown_from_SQL"}{section}		= qq`SELECT id,name FROM $PREF{field_sections_table}`;
    $PREF{"${viewerprefname}_editmode_dropdown_from_SQL"}{section}		= qq`SELECT id,name FROM $PREF{field_sections_table}`;



    $PREF{"${viewerprefname}_creation_default_value"}{enabled}		= 1;
    $PREF{"${viewerprefname}_creation_default_value"}{fieldmax}		= 255;
    $PREF{"${viewerprefname}_creation_default_value"}{allowedchars}		= $PREF{list_of_sql_safe_characters};
    $PREF{"${viewerprefname}_creation_default_value"}{allowedcharsmsg}	= qq`Error: illegal character(s) in %%fieldname%% field; please go back and try again.`;







    $PREF{"${viewerprefname}_viewer_value_verifications"}{fieldmax}{'01'}		= 'preset:numeric,minvalue=1,maxvalue=255,nonnull';
    $PREF{"${viewerprefname}_viewer_value_verifications"}{datatype}{'01'}		= 'preset:word,maxlength=100,nonnull';
    $PREF{"${viewerprefname}_viewer_value_verifications"}{fieldtype}{'01'}		= 'preset:word,maxlength=100,nonnull';
    $PREF{"${viewerprefname}_viewer_value_verifications"}{allowedcharsmsg}{'01'}	= 'preset:maxlength=255';
    $PREF{"${viewerprefname}_viewer_value_verifications"}{fieldname}{'01'}		= 'preset:word,maxlength=100,nonnull';

    $PREF{"${viewerprefname}_viewer_value_verifications"}{fieldname}{'02'}		= '

		if(is_builtin_fieldname(%%variable%%))
		{
			%%variable%% = qq`die_from_eval:smsg_e_bltfld`;
		}

		if($PREF{db_editor_mode} eq "create"   &&   db_column_exists(%%variable%%, $PREF{user_table}))
		{
			%%variable%% = qq`die_from_eval:smsg_e_fldexist`;
		}

	';

    $PREF{"${viewerprefname}_viewer_value_verifications"}{fieldtype}{'02'}		= '

		if("%%fieldtype%%" =~ /^(dropdown|radio)$/ && !"%%listitems%%")	{ %%variable%% = qq`die_from_eval:smsg_e_listitems`; }

	';

    $PREF{"${viewerprefname}_viewer_value_verifications"}{fieldposition}{'01'}	= '

		if(%%variable%%   &&   %%variable%% !~ /^\d+$/)	{ %%variable%% = qq`die_from_eval:smsg_e_fieldpos`; }

	';










    # Make this one last because get_next_available_fieldpos_in_custom_fields_table()
    # does database updates, which won't hurt anything, but we'd rather not do them
    # if we're just going to error out on an invalid value in some other field.
    #
    #$PREF{"${viewerprefname}_POST_value_transforms"}{fieldposition}			= '
    #
    #	%%variable%% = get_next_available_fieldpos_in_custom_fields_table(%%variable%%) if !%%variable%%;
    #
    #';
    #
    $PREF{"${viewerprefname}_POST_value_transforms"}{fieldposition}			= 'preset:next_int_if_null_or_zero';







    $PREF{"${viewerprefname}_creation_oncomplete_code"} = '

		my $fieldname		= "%%fieldname%%";
		my $datatype		= "%%datatype%%";
		my $fieldmax		= "%%fieldmax%%";

		if(!db_column_exists($fieldname, $PREF{user_table}))
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` ADD `$fieldname` " . expand_abbreviated_datatype($datatype,$fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}

	';








    $PREF{"${viewerprefname}_editmode_oncomplete_code"} = '

		my $fieldname		= "%%fieldname%%";
		my $datatype		= "%%datatype%%";
		my $fieldmax		= "%%fieldmax%%";

		my $prev_fieldname	= "%%fieldname___old%%";
		my $prev_datatype	= "%%datatype___old%%";
		my $prev_fieldmax	= "%%fieldmax___old%%";

		if($fieldname ne $prev_fieldname)
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` CHANGE `$prev_fieldname` `$fieldname` " . expand_abbreviated_datatype($prev_datatype,$prev_fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}
		if($datatype ne $prev_datatype   ||   $fieldmax ne $prev_fieldmax)
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` MODIFY `$fieldname` " . expand_abbreviated_datatype($datatype,$fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}

		if(!db_column_exists($fieldname, $PREF{user_table})) # in case our listing somehow got out of sync with the actual db structure.
		{
			my $statement = "ALTER TABLE `$PREF{user_table}` ADD `$fieldname` " . expand_abbreviated_datatype($datatype,$fieldmax);
			my $sth = $PREF{dbh}->prepare($statement);
			$sth->execute() or exit_with_error("error while executing SQL statement [[ $statement ]]: $DBI::errstr\n");
		}

	';




    $PREF{"${viewerprefname}_deletion_oncomplete_code"}			= '

		my $id = %%id%%;
		die_unless_numeric($id, "database record ID");
		my $fieldname = "%%fieldname%%";

		die_nice(qq`id=$id: cannot delete field "$fieldname" because it is one of our built-in fields.`) if is_builtin_fieldname($fieldname);
		die_nice(qq`id=$id: cannot delete field "$fieldname" because it contains illegal characters.`) if $fieldname !~ /^\w+$/;

		my $sth = $PREF{dbh}->prepare("ALTER TABLE `$PREF{user_table}` DROP COLUMN `$fieldname`");
		$sth->execute() or die_nice(qq`could not drop column "$fieldname" from user table ($PREF{user_table}): $DBI::errstr\n`);

	';






    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub expand_abbreviated_datatype($$)
  {
    my ($datatype,$fieldmax) = @_;
    return $datatype eq "varchar" ? "$datatype($fieldmax)" : $datatype eq "uint" ? "INT UNSIGNED" : $datatype eq "ufloat" ? "FLOAT UNSIGNED" : $datatype;
  }


sub get_next_available_fieldpos_in_custom_fields_table($)
  {
    my $fieldposition = shift;
    my $max_position = enc_sql_select("SELECT MAX(`fieldposition`) FROM `$PREF{custom_field_list_table}`");
    $max_position = 0 unless $max_position =~ /^\d+$/;
    my $next_position = $max_position + 1;
    $fieldposition = $next_position unless $fieldposition =~ /^\d+$/;
    my $pos_is_taken = enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}` WHERE `fieldposition` = $fieldposition");
    if (($fieldposition < $next_position)   &&   $pos_is_taken) {
      my $current_position = $max_position;
      while ($current_position >= $fieldposition) {
        enc_sql_update("UPDATE `$PREF{custom_field_list_table}` SET `fieldposition` = $current_position + 1 WHERE `fieldposition` = $current_position");
        $current_position--;
      }
      # now every field has been shifted up (increased fieldposition value) by 1 position,
      # and there is no field whose position is $fieldposition.
    }
    return $fieldposition;
  }


sub show_field_sections_manager()
  {
    my $tableprefname	= $PREF{field_sections_table};
    my $viewerprefname	= 'field_sections';
    my $allowed_to_view	= user_is_allowed_to('manage_field_sections');
    my $allowed_to_create	= user_is_allowed_to('manage_field_sections');
    my $allowed_to_edit	= user_is_allowed_to('manage_field_sections');
    my $allowed_to_delete	= user_is_allowed_to('manage_field_sections');


    $PREF{"${viewerprefname}_viewer_title"}					= 'Sections Manager';
    $PREF{"${viewerprefname}_viewer_header_note"}				= qq`<p>
		The Sections Manager allows you to display your user data fields in different sections,
		for visual/organizational purposes.&nbsp; If you don't create any sections here, then all
		your fields will be displayed in a single list.&nbsp; <strong>Note:</strong> if you create
		any <a href="$PREF{login_url}?action=customfields">Custom Fields</a> before creating any
		sections here -- or if you delete all your sections -- then when you do (re)create your first
		section, all existing custom fields will have their section automatically set to that first section.
	</p>`;

    $PREF{"${viewerprefname}_viewer_footer_note"}				= qq`<p><em>
		<strong>Name:</strong> a short name without spaces, to identify the section.&nbsp; 
		<strong>Label:</strong> the user-visible title/label for the section; can be longer (up to 255 characters).
	</em></p>`;

    $PREF{"${viewerprefname}_viewer_item_name"}				= 'section';
    #$PREF{"${viewerprefname}_viewer_forced_mode"}				= 'horiz';
    $PREF{"${viewerprefname}_viewer_hide_column_toggles"}			= 'yes';
    $PREF{"${viewerprefname}_viewer_hidden_columns"}			= 'id';
    $PREF{"${viewerprefname}_viewer_disabled_columns"}			= '';
    $PREF{"${viewerprefname}_viewer_default_sort_field"}			= 'section_position';


    $PREF{"${viewerprefname}_viewer_value_verifications"}{name}{01}		= 'preset:word,nonnull';
    $PREF{"${viewerprefname}_POST_value_transforms"}{name}			= 'preset:make_lowercase';
    $PREF{"${viewerprefname}_POST_value_transforms"}{section_position}	= 'preset:next_int_if_null_or_zero';


    $PREF{"${viewerprefname}_creation_oncomplete_code"} = '

		my $id = %%id%%;
		my $num_sections = enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`");
		#if($id == 1 && $num_sections == 1)
		if($num_sections == 1)
		{
			# This is the first section created in this installation, so if there
			# are any existing custom fields, set their section to this new section.
			if(enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`"))
			{
				my $success = enc_sql_update("UPDATE `$PREF{custom_field_list_table}` SET `section` = $id");
				die_nice(qq`SQL returned "$success" (instead of at least 1) while updating "section" to $id for all records.`) unless $success > 0;
			}
		}

	';


    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


#
# Precondition: check_username_for_sql_safeness($input_username).
#
sub account_exceeds_failed_login_limit
  {
    my $input_username = $_[0];
    my $increment_failure_count = $_[1] eq 'increment' ? 1 : 0;

    my $failed_login_limit_exceeded = 0;

    if ($PREF{lock_account_after_N_failed_logins} =~ /^\d+$/) {
      return unless enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE `username` = '$input_username';"); # account DNE.

      my ($recent_failed_attempts, $recent_failure_count) = ();

      if ($increment_failure_count) {
        $recent_failed_attempts	= offsettime() . ',';
        $recent_failure_count	= 1;
      }

      my $failed_attempts = enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");

      foreach my $failure_time (split(/,/, $failed_attempts)) {
        if ($PREF{failed_logins_within_N_secs_count_towards_lock} =~ /^\d+$/) {
          if (offsettime() - $failure_time < $PREF{failed_logins_within_N_secs_count_towards_lock}) {
            $recent_failed_attempts .= $failure_time . ',';
            $recent_failure_count++;
          }
        } else # all failures are "recent", i.e. we don't care how long ago they occurred.
          {
            $recent_failed_attempts .= $failure_time . ',';
            $recent_failure_count++;
          }
      }

      decommaify($recent_failed_attempts);
      sql_untaint($recent_failed_attempts);
      my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `failed_logins` = '$recent_failed_attempts' WHERE `username` = '$input_username';");
      die_nice("Error: account_exceeds_failed_login_limit(input_username='$input_username'): SQL returned '$success' instead of '1' while updating failed_logins.") unless $success == 1;

      if ($recent_failure_count >= $PREF{lock_account_after_N_failed_logins}) {
        $failed_login_limit_exceeded = 1;
      }
    }

    return $failed_login_limit_exceeded;
  }


sub print_payment_form($$)
  {
    my $typeno = shift;
    my $uid = shift;

    my $template = $PREF{paid_account_payment_page_template};

    $template =~ s!%%userid%%!$uid!gis;
    $template =~ s!%%item_name%%!$PREF{"paid_account_type_${typeno}_paypal_item_name"}!gis;
    $template =~ s!%%item_number%%!$PREF{"paid_account_type_${typeno}_paypal_item_number"}!gis;
    $template =~ s!%%item_cost%%!$PREF{"paid_account_type_${typeno}_cost"}!gis;
    $template =~ s!%%item_desc%%!$PREF{"paid_account_type_${typeno}_groupdesc"}!gis;
    $template =~ s!%PREF{(\w+)}!$PREF{$1}!gis;

    start_html_output($PREF{paid_account_payment_page_title});
    print $template;
    finish_html_output();
  }


sub print_payment_confirmation_page
  {
    my $template = $PREF{confirm_payment_page_template};

    $template =~ s!%PREF{(\w+)}!$PREF{$1}!gis;

    start_html_output($PREF{confirm_payment_page_title});
    print $template;
    finish_html_output();
  }


  sub show_ipn_data
  {
    exit_with_needprivs() unless $PREF{admin_is_logged_in};

    my $tableprefname	= 'paypal_ipn_table';
    my $viewerprefname	= 'paypal_ipn';
    my $allowed_to_view	= $PREF{admin_is_logged_in};
    my $allowed_to_create	= 0;
    my $allowed_to_edit	= 0;
    my $allowed_to_delete	= 0;


    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub do_paypal_ipn()
  {
    die_nice("\$PREF{enable_paid_accounts} is disabled.") unless $PREF{enable_paid_accounts} =~ /yes/i;

    # read post from PayPal system and add 'cmd'
    #
    my $ipn_query = '';
    read (STDIN, $ipn_query, $ENV{CONTENT_LENGTH});
    $ipn_query .= '&cmd=_notify-validate';

    # post back to PayPal system to validate
    #
    use LWP::UserAgent;
    my $ua = new LWP::UserAgent;
    my $req = new HTTP::Request 'POST','http://www.paypal.com/cgi-bin/webscr';
    # note: if you have SSL encryption Enabled, use <https://www.paypal.com/cgi-bin/webscr> above.

    $req->content_type('application/x-www-form-urlencoded');
    $req->content($ipn_query);
    my $res = $ua->request($req);


    if ($res->is_error) {
      log_order_processing_error_and_die("HTTP error during IPN processing.");
    } elsif ($res->content eq 'VERIFIED') {
      my %ipn_vars = ();
      foreach my $variable (split(/&/, $ipn_query)) {
        my ($name, $value) = split(/=/, $variable);
        $value =~ tr/+/ /;
        $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $ipn_vars{$name} = $value;
      }

      # check the $ipn_vars{payment_status} = Completed
      # check that $ipn_vars{txn_id} has not been previously processed
      # check that $ipn_vars{receiver_email} is an email address in your PayPal account
      # process payment

      # This is not visited by the buyer; it's visited by PayPal on the
      # backend, so displaying this data to the client here makes no sense.
      #
      ## print to screen the following:
      #
      #print "Content-type: text/html\n\n";
      #print "<html><head><title>Payment Processed</title></head>\n";
      #print "<body>your email address is <b>$ipn_vars{payer_email}</b>\n";
      #print "<br>you paid <b>$ipn_vars{payment_gross}</b>\n";
      #print "<br>you paid for <b>$ipn_vars{item_name} / $ipn_vars{item_number}</b>\n";
      #print "<br>the value of custom was <b>$ipn_vars{custom}</b>\n";
      #print "<br>the status was <b>$res->content</b>\n";
      #print "<br>the note said <b>$ipn_vars{memo}</b>\n";
      #print "<br>the transaction id was <b>$ipn_vars{txn_id}</b>\n";
      #print "<br>the payment status was <b>$ipn_vars{payment_status}</b>\n";
      #print "<br><br><br>Full IPN Response:<br>\n";
      #foreach my $var (sort keys %ipn_vars)
      #{
      #	print "<br><br><b>$var</b>: $ipn_vars{$var}\n";
      #}
      #print "</body></html>\n";


      # Store transaction info to database:
      #
      my $all_ipn_vars = '';
      foreach my $var (sort keys %ipn_vars) {
        my $value = $ipn_vars{$var};
        s!\n_SPTR_\n!\n_SPTR-REPLACED_\n!g for ($var,$value);
        $all_ipn_vars .= "$var=$value\n_SPTR_\n";
      }

      my $date = offsettime();
      log_order_processing_error_and_die("non-numeric date for IPN") unless $date =~ /^\d+$/;

      my $date8 = strftime("%Y%m%d",localtime($date));
      log_order_processing_error_and_die("non-numeric date8 for IPN") unless $date8 =~ /^\d+$/;

      my $txn_id = $ipn_vars{txn_id};
      sql_untaint($txn_id);
      log_order_processing_error_and_die("not_sqlsafe(): \$txn_id value '$txn_id'.") if not_sqlsafe($txn_id);

      sql_untaint($all_ipn_vars);
      log_order_processing_error_and_die("not_sqlsafe(): \$all_ipn_vars value '$all_ipn_vars'.") if not_sqlsafe($all_ipn_vars);

      enc_sql_insert("INSERT INTO `$PREF{paypal_ipn_table}` (`date`,`date8`,`txn_id`,`allvars`) VALUES('$date', '$date8', '$txn_id', '$all_ipn_vars')");


				# date comes from PayPal as:
				#	payment_date=12:10:51 Oct 03, 2007 PDT
				#	payment_date=23:58:48 Feb 06, 2008 PST 
				#
      my($hour,$min,$sec,$month,$day,$year) = ($ipn_vars{payment_date} =~ /(\d\d):(\d\d):(\d\d)\s*(\w+)\s*(\d\d?),\s*(\d\d\d\d)/);
      $day = "0$day" if length($day) == 1;
      my $monthnum = $PREF{monthnum}{lc($month)};
      log_order_processing_error_and_die(qq`invalid monthnum "$monthnum"; is the \$PREF{monthnum} hash populated?`) unless $monthnum =~ /^\d+$/;
      my $paypal_date = timelocal($sec,$min,$hour,$day,($monthnum - 1),$year);
      log_order_processing_error_and_die("non-numeric ETime from PayPal IPN date") unless $paypal_date =~ /^\d+$/;

      my $paypal_date8 = $year . $monthnum . $day;
      log_order_processing_error_and_die("non-numeric date8 from PayPal IPN date") unless $paypal_date8 =~ /^\d+$/;

      my $transaction_cost = $ipn_vars{"mc_gross"};
      log_order_processing_error_and_die("invalid \$transaction_cost value '$transaction_cost'.") unless $transaction_cost =~ /^\d+(\.\d{2})?$/;

      my $item_number = $ipn_vars{item_number};
      sql_untaint($item_number);
      log_order_processing_error_and_die("not_sqlsafe(): \$item_number value '$item_number'.") if not_sqlsafe($item_number);

      my $item_name = $ipn_vars{item_name};
      sql_untaint($item_name);
      log_order_processing_error_and_die("not_sqlsafe(): \$item_name value '$item_name'.") if not_sqlsafe($item_name);

      my $userid = $ipn_vars{option_selection1};
      log_order_processing_error_and_die("non-numeric userid from IPN data") unless $userid =~ /^\d+$/;

      my $quantity = $ipn_vars{"quantity"};
      log_order_processing_error_and_die("non-numeric quantity from PayPal IPN") unless $quantity =~ /^\d+$/;

      my $buyer_email = $ipn_vars{payer_email};
      sql_untaint($buyer_email);
      log_order_processing_error_and_die("not_sqlsafe(): \$buyer_email value '$buyer_email'.") if not_sqlsafe($buyer_email);

      my $buyer_firstname = $ipn_vars{first_name};
      sql_untaint($buyer_firstname);
      log_order_processing_error_and_die("not_sqlsafe(): \$buyer_firstname value '$buyer_firstname'.") if not_sqlsafe($buyer_firstname);

      my $buyer_lastname = $ipn_vars{last_name};
      sql_untaint($buyer_lastname);
      log_order_processing_error_and_die("not_sqlsafe(): \$buyer_lastname value '$buyer_lastname'.") if not_sqlsafe($buyer_lastname);


				# Determine the type of account that was purchased:
				#
      my $typeno = '';
      my $item_number_valid = 0;
      foreach my $pref (sort keys %PREF) {
        if ($pref =~ /^paid_account_type_(\d+)_paypal_item_number$/) {
          if ($item_number eq $PREF{$pref}) {
            $typeno = $1;
            $item_number_valid = 1;
            last;
          }
        }
      }


				# Verify that a valid item number was purchased:
				#
      log_order_processing_error_and_die("invalid item number '$item_number'.") unless $item_number_valid;


				# Verify that the payment/post data hasn't been tampered with, by
				# making sure the paid amount is correct for the selected account
				# type:
				#
      if ($transaction_cost < $PREF{"paid_account_type_${typeno}_cost"}) {
        log_order_processing_error_and_die(qq`invalid transaction cost '$transaction_cost'; must be at least $PREF{"paid_account_type_${typeno}_cost"} for item number '$item_number'.`);
      }


				# Log the sale in the payments table:
				#
      my $statement =   "INSERT INTO `$PREF{payments_table}` "
        . 		"(`date`, `date8`, `paypal_date`, `paypal_date8`, `item_number`, `item_name`, `quantity`, `transaction_cost`, `txn_id`, `userid`, `buyer_email`, `buyer_firstname`, `buyer_lastname`) "
          . "VALUES('$date', '$date8', '$paypal_date', '$paypal_date8', '$item_number', '$item_name', '$quantity', '$transaction_cost', '$txn_id', '$userid', '$buyer_email', '$buyer_firstname', '$buyer_lastname')";

      enc_sql_insert($statement);


				# Mark the account as paid by adding it to the appropriate group:
				#
      my $groupname = $PREF{"paid_account_type_${typeno}_groupname"};
      my $username = get_user_name($userid);
      add_user_to_group($username, $groupname);


				# Disable the pending_payment flag for the account:
				#
      if (account_is_pending_payment($userid)) {
        enc_sql_update("UPDATE `$PREF{user_table}` SET `pending_payment` = 0 WHERE `id` = $userid") == 1 or log_order_processing_error_and_die("SQL returned something other than 1 while trying to set pending_payment to 0.");
      }


      print_http_headers();
      exit;
    } elsif ($res->content eq 'INVALID') {
      log_order_processing_error_and_die("IPN Returned INVALID.");
    } else {
      log_order_processing_error_and_die("unknown IPN error.");
    }
  }


sub log_order_processing_debug_message
  {
    my $msg = shift;
    my $caller = (caller 1)[3];
    $caller =~ s/^main:://;
    $msg = qq`$PREF{internal_appname}: process ID=$$ \n$caller(): $msg`;

    my $subject = "Store order processing debug message (PID=$$)";

    foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients})) {
      send_email($to, $PREF{script_email_address}, $subject, $msg, 'text/plain', '');
    }
  }


sub log_order_processing_error
  {
    my $msg = shift;
    my $payer_email = shift;
    my $caller = (caller 1)[3];
    $caller =~ s/^main:://;
    $msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;

    my $subject = "Error during store order processing ($payer_email)";

    foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients})) {
      send_email($to, $PREF{script_email_address}, $subject, $msg, 'text/plain', '');
    }
  }


sub log_order_processing_error_and_die
  {
    my $msg = shift;
    my $payer_email = shift;
    my $caller = (caller 1)[3];
    $caller =~ s/^main:://;
    $msg = qq`$PREF{internal_appname}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;

    my $subject = "Error during store order processing ($payer_email)";

    foreach my $to (split(/\s*,\s*/, $PREF{payment_notification_email_recipients})) {
      send_email($to, $PREF{script_email_address}, $subject, $msg, 'text/plain', '');
    }

    print STDERR "$subject - $msg";

    $msg =~ s!<!&lt;!g;
    $msg =~ s!>!&gt;!g;
    $msg =~ s!\n!<br />\n!g;
    exit_with_error "$subject - $msg";
  }


sub interpolate_userbase_variables
  {
    my $string = shift;         # required.
    my $userid = shift; # optional; if present, return info for this user, rather than the logged-in user.
    printd "interpolate_userbase_variables('$string')";

    if ($userid && check_id_for_sql_safeness($userid)) {
      $string =~ s/(%%(\w+?)%%)/db_column_exists($2,$PREF{user_table}) ? enc_sql_select("SELECT `$2` FROM `$PREF{user_table}` WHERE `id` = $userid") : $1/eg;
    } else {
      $string =~ s/%%username%%/$PREF{logged_in_username}/g;
      $string =~ s/%%userid%%/$PREF{logged_in_userid}/g;
      $string =~ s/%PREF{(\w+)}/$PREF{$1}/g;
      $string =~ s/%%(\w+?)%%/enc_sql_select("SELECT `$1` FROM `$PREF{user_table}` WHERE `id` = $PREF{logged_in_userid}")/eg;
    }
    return $string;
  }


sub create_filechucker_userdir($$$$)
  {
    return unless $PREF{create_filechucker_userdir_on_account_creation} =~ /yes/i;
    my ($uid,$username,$realname,$email) = @_;
	
    my $userdir		= $PREF{filechucker_userdir_template};
    my $using_username	= $userdir =~ /%%username%%/	&& $username;
    my $using_uid		= $userdir =~ /%%userid%%/	&& $uid;
    my $using_email		= $userdir =~ /%%email%%/	&& $email;
    exit_with_error qq`Your setting for \$PREF{filechucker_userdir_template} must contain at least one of: %%username%%, %%userid%%, or %%email%% (and the corresponding field must be a required field [i.e., never null]) in order to ensure that each userdir is unique.` if !$using_username && !$using_uid && !$using_email;

    $realname =~ s!\W!_!g; # mainly for spaces, but also for dashes, parens, etc, that might appear in the realname field values.
    $userdir =~ s/%%username%%/$username/g;
    $userdir =~ s/%%userid%%/$uid/g;
    $userdir =~ s/%%email%%/$email/g;
    $userdir =~ s/%%realname%%/$realname/g;

    my $dir = $PREF{filechucker_userdir_folder};
    my $slash =   $PREF{DOCROOT} !~ m![/\\]$! && $dir !~ m!^[/\\]!   ? '/' : '';
    $dir = $PREF{DOCROOT} . $slash . $dir if $PREF{filechucker_userdir_folder_is_in_docroot};

    $slash =   $dir !~ m![/\\]$! && $userdir !~ m!^[/\\]!   ? '/' : '';
    $dir = $dir . $slash . $userdir;

    create_dir_if_DNE($dir,$PREF{writable_dir_perms},'make_parents');
  }


# Note: this function's error messages should be written so that they
# don't display the name of the protected pages directory unless the
# visitor is an administrator.
#
sub display_protected_page($)
  {
    my $page_to_display = shift;
    enc_urldecode($page_to_display);
    $page_to_display = enc_untaint($page_to_display,'keep_path');
    my ($page_to_display_base, $page_to_display_ext) = ($page_to_display =~ /(.+)\.(.+)/);
    my $page_full = $PREF{protected_pages_directory} . '/' . $page_to_display;

    # Allow pages to be found regardless of file extension or case.
    #
    opendir(my $dirh, $PREF{protected_pages_directory}) or $PREF{admin_is_logged_in} ? die_nice(qq`error: could not open directory \$PREF{protected_pages_directory} ("$PREF{protected_pages_directory}"): $!`) : die_nice(qq`error: could not open directory \$PREF{protected_pages_directory}: $!`);
    my @protectedpages = grep { -f "$PREF{protected_pages_directory}/$_" && !/^\./ } readdir $dirh;
    closedir $dirh or die_nice(qq`error: could not close directory \$PREF{protected_pages_directory}: $!`);
    foreach my $protectedpage (@protectedpages) {
      my ($protectedpage_base,$protectedpage_ext) = ($protectedpage =~ /(.+)\.(.+)/);
      if ($protectedpage_base   &&   $page_to_display_base   &&   lc($protectedpage_base) eq lc($page_to_display_base)) {
        $page_full = $PREF{protected_pages_directory} . '/' . $protectedpage_base . '.' . $protectedpage_ext;
        last;
      }
    }

    if (! -e $page_full) {
      if ($PREF{admin_is_logged_in}) {
        die_nice(qq`error: file does not exist: "$page_full"`);
      } else {
        die_nice(qq`error: file does not exist: "$page_to_display"`);
      }
    }

    my $allowed = 0;
    my $page_content = '';

    open(my $infh, $page_full) or die_nice(qq`error: could not open file "$page_to_display" for reading: $!`);
    flock $infh, 1;
    seek $infh, 0, 0;
    while (<$infh>) {
      if (/<!-- allowed_usernames=(.*?) -->/) {
        my $allowed_users = $1;
        $allowed_users =~ s!\s*,\s*!,!g; # in case they put any spaces around their commas.
        my %allowed_users = map { $_ => 1 } split(/,/, $allowed_users);
        $allowed = 1 if $allowed_users{$PREF{logged_in_username}};
      } elsif (/<!-- allowed_groups=(.*?) -->/) {
        my $allowed_groups = $1;
        $allowed_groups =~ s!\s*,\s*!,!g; # in case they put any spaces around their commas.
        foreach my $allowed_group (split(/,/, $allowed_groups)) {
          $allowed = 1 if user_is_member_of_group($PREF{logged_in_userid},$allowed_group);
        }
      } else {
        $page_content .= $_;
      }
    }
    close($infh) or die_nice(qq`error: could not close file "$page_to_display" after reading: $!`);

    if ($allowed) {
      print_http_headers();
      print $page_content;
    } else {
      if ($PREF{member_is_logged_in}) {
        exit_with_needprivs();
      } else {
        my $msg = $TEXT{Please_login_first_};
        enc_urlencode($msg);
        my $go = "$PREF{login_url}?phasemsg=$msg&whence=" . $ENV{REQUEST_URI};
        enc_redirect($go);
      }
    }
  }




# Note: this function's error messages should be written so that they
# don't display the name of the protected pages directory unless the
# visitor is an administrator.
#
sub display_protected_page_simple($$)
  {
    my $pdir_num = shift;
    my $page_to_display = shift;
    enc_urldecode($page_to_display);
    $page_to_display = enc_untaint($page_to_display,'keep_path');
    my ($page_to_display_base, $page_to_display_ext) = ($page_to_display =~ /(.+)\.(.+)/);
    my $pdir = $PREF{"protected_directory_${pdir_num}"};
    my $page_full = $pdir . '/' . $page_to_display;
	
    die_nice qq`error: the setting \$PREF{"protected_directory_${pdir_num}"} does not exist.` unless $PREF{"protected_directory_${pdir_num}"};

    if (!user_is_allowed_to("access_protected_directory_${pdir_num}")) {
      if ($PREF{member_is_logged_in}) {
        exit_with_needprivs();
      } else {
        my $msg = $TEXT{Please_login_first_};
        enc_urlencode($msg);
        my $go = "$PREF{login_url}?phasemsg=$msg&whence=" . $ENV{REQUEST_URI};
        enc_redirect($go);
      }
    }

    if ($PREF{"protected_directory_${pdir_num}_ignore_file_extensions"} =~ /yes/i) {
      # Allow pages to be found regardless of file extension or case.
      #
      opendir(my $dirh, $pdir) or $PREF{admin_is_logged_in} ? die_nice(qq`error: could not open directory \$pdir ("$pdir"): $!`) : die_nice(qq`error: could not open directory \$PREF{protected_directory_${pdir_num}}: $!`);
      my @protectedpages = grep { -f "$pdir/$_" && !/^\./ } readdir $dirh;
      closedir $dirh or die_nice(qq`error: could not close directory \$PREF{protected_directory_${pdir_num}}: $!`);
      foreach my $protectedpage (@protectedpages) {
        my ($protectedpage_base,$protectedpage_ext) = ($protectedpage =~ /(.+)\.(.+)/);
        if ($protectedpage_base   &&   $page_to_display_base   &&   lc($protectedpage_base) eq lc($page_to_display_base)) {
          $page_full = $pdir . '/' . $protectedpage_base . '.' . $protectedpage_ext;
          last;
        }
      }
    } else {
      $page_full = $pdir . '/' . $page_to_display;
    }

    if (! -e $page_full) {
      if ($PREF{admin_is_logged_in}) {
        die_nice(qq`error: file does not exist: "$page_full"`);
      } else {
        die_nice(qq`error: file does not exist: "$page_to_display"`);
      }
    }

    #my $page_content = '';
    #open(my $infh, $page_full) or die_nice(qq`error: could not open file "$page_to_display" for reading: $!`);
    #flock $infh, 1;
    #seek $infh, 0, 0;
    #$page_content .= $_ while(<$infh>);
    #close($infh) or die_nice(qq`error: could not close file "$page_to_display" after reading: $!`);
    #
    #print_http_headers();
    #print $page_content;
    #
    # This needs to work for binary files too (PDFs, etc):
    #
    select STDOUT;
    $| = 1;
    my ($read,$buf) = ();
    my $size = (stat $page_full)[7];
    my $content_type = '';
    my $ext = lc(($page_full =~ /\.([^\.]+)$/)[0]);
    eval { require MIME::Types; }; $PREF{MIME_Types_error} = $@;
    if ($PREF{MIME_Types_error} || $PREF{dont_use_the_mime_types_module} =~ /yes/i) {
      $content_type = $PREF{"mimetype_for_${ext}"};
    } else {
      my $mimetypes = MIME::Types->new;
      my $the_type = $mimetypes->mimeTypeOf($ext);
      $content_type = $the_type;
    }
    $content_type ||= 'application/octet-stream';

    my $disposition = $content_type ne 'application/octet-stream' ? 'inline' : 'attachment';
    my (undef,$page_base) = split_path_and_filename($page_full);

    print	  qq`Content-Type: $content_type\n`
      . qq`Content-Disposition: $disposition; filename="$page_base"\n`
        . qq`Content-Length: $size\n`
          . qq`\n`;

    open(DOWNLOADFILEFH, $page_full) or die "$0: couldn't open file '$page_full' for reading: $!\n";
    my $infh = \*DOWNLOADFILEFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
    binmode $infh;
    my $blocksize = (stat $infh)[11] ? (stat $infh)[11] : 16384;
    while ($read = sysread($infh, $buf, $blocksize)) {
      unless(defined($read))
        {
          next if $! =~ /^Interrupted/;
          die "$0: download_file(): read error: $!\n";
        }

      my ($written,$offset) = (0,0);
      while ($read) {
        $written = syswrite(STDOUT, $buf, $read, $offset);
        unless(defined($written))
          {
            die "$0: download_file(): write error: $!\n";
          }

        $read -= $written;
        $offset += $written;
      }
    }
    close $infh or die "$0: couldn't close file '$page_full' after reading: $!\n";

  }


sub check_login()
  {
    # sleep $PREF{num_seconds_to_sleep_on_failed_login} unless $PREF{member_is_logged_in};
    my $group_memberships = '';
    my (@custom_fields, @custom_field_values) = ();

    if ($PREF{member_is_logged_in}) {
      my $groups = get_groups_hash($PREF{logged_in_userid});
      foreach my $group (sort keys %$groups) {
        $group_memberships .= $group . ',' if $$groups{$group}{is_member};
      }
      $group_memberships =~ s/,+$//;

      @custom_fields = get_custom_userbase_field_names($PREF{user_table});
      foreach my $customfield (@custom_fields) {
        my $value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}'");
        push @custom_field_values, $value;
      }
    }

    my $output = "admin=$PREF{admin_is_logged_in}:::::member=$PREF{member_is_logged_in}:::::username=$PREF{logged_in_username}:::::userid=$PREF{logged_in_userid}:::::group_memberships=${group_memberships}:::::realname=$PREF{logged_in_realname}:::::email=$PREF{logged_in_email}:::::";

    my $i = 0;
    foreach my $field (@custom_fields) {
      $output .= "${field}=$custom_field_values[$i]:::::";
      $i++;
    }

    $output .= "\n";

    if ($qs =~ /print=false/) {
      return $output;
    } else {
      print_http_headers();
      print $output;
    }
  }


sub do_web_config
  {
    exit_with_error("This feature is disabled.") unless $PREF{enable_web_config} =~ /yes/i;


  }


sub show_logins
  {
    my $tableprefname	= 'logins_table';
    my $viewerprefname	= 'logins';
    my $allowed_to_view	= user_is_allowed_to('view_logins_log');
    my $allowed_to_create	= 0;
    my $allowed_to_edit	= user_is_allowed_to('edit_logins_log');
    my $allowed_to_delete	= user_is_allowed_to('delete_logins_log_records');


    $PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 2, value => '' };
    $PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 4, value => '' };

    $PREF{"${viewerprefname}_viewer_value_transforms"}{username}	= qq`%%variable%% = get_user_name(%%user_id%%) || '(deleted)';`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;


    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub show_failed_logins
  {
    my $tableprefname	= 'failed_logins_table';
    my $viewerprefname	= 'failed_logins';
    my $allowed_to_view	= user_is_allowed_to('view_failed_logins_log');
    my $allowed_to_create	= 0;
    my $allowed_to_edit	= user_is_allowed_to('edit_failed_logins_log');
    my $allowed_to_delete	= user_is_allowed_to('delete_failed_logins_log_records');


    $PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 4, value => '' };

    $PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;


    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub show_password_activity
  {
    my $tableprefname	= 'password_activity_table';
    my $viewerprefname	= 'password_activity';
    my $allowed_to_view	= user_is_allowed_to('view_password_activity_log');
    my $allowed_to_create	= 0;
    my $allowed_to_edit	= user_is_allowed_to('edit_password_activity_log');
    my $allowed_to_delete	= user_is_allowed_to('delete_password_activity_log_records');


    $PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 3, value => '' };
    $PREF{"${viewerprefname}_viewer_extra_columns"}{updater}	= { position => 8, value => '' };
    $PREF{"${viewerprefname}_viewer_extra_columns"}{date}		= { position => 6, value => '' };

    $PREF{"${viewerprefname}_viewer_title_transforms"}{updater}	= 'Updated by';
    $PREF{"${viewerprefname}_viewer_title_transforms"}{ip_address}	= "Updater's IP";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{hostname}	= "Updater's hostname";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{browser}	= "Updater's browser";

    $PREF{"${viewerprefname}_viewer_value_transforms"}{username}	= qq`%%variable%% = get_user_name(%%user_id%%) || '(deleted)';`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{updater}	= qq`%%variable%% = %%user_who_did_update%% ? get_user_name(%%user_who_did_update%%) : "$TEXT{password_updater_special_cases}";`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{date}	= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{salt}	= qq`%%variable%% =~ s/</&lt;/g; %%variable%% =~ s/>/&gt;/g;`;


    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub show_userinfo_updates
  {
    my $tableprefname	= 'userinfo_updates_table';
    my $viewerprefname	= 'userinfo_updates';
    my $allowed_to_view	= user_is_allowed_to('view_userinfo_updates');
    my $allowed_to_create	= 0;
    my $allowed_to_edit	= user_is_allowed_to('edit_userinfo_updates');
    my $allowed_to_delete	= user_is_allowed_to('delete_userinfo_updates_records');


    $PREF{"${viewerprefname}_viewer_extra_columns"}{date}			= { position => 3, value => '' };
    $PREF{"${viewerprefname}_viewer_extra_columns"}{account_changed}	= { position => 4, value => '' };
    $PREF{"${viewerprefname}_viewer_extra_columns"}{changed_by}		= { position => 5, value => '' };

    $PREF{"${viewerprefname}_viewer_title_transforms"}{updater}		= 'Updated by';
    $PREF{"${viewerprefname}_viewer_title_transforms"}{ip_address}		= "Changer's IP";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{hostname}		= "Changer's hostname";
    $PREF{"${viewerprefname}_viewer_title_transforms"}{browser}		= "Changer's browser";

    $PREF{"${viewerprefname}_viewer_value_transforms"}{account_changed}	= qq`%%variable%% = get_user_name(%%changee_id%%) ? '<a href="$PREF{login_url}?action=edituser&amp;id=%%changee_id%%">' . get_user_name(%%changee_id%%) . '</a>' : '(deleted)';`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{changed_by}		= qq`%%variable%% = %%changer_id%% ? '<a href="$PREF{login_url}?action=edituser&amp;id=%%changer_id%%">' . get_user_name(%%changer_id%%) . '</a>' : "$TEXT{userinfo_updates_special_cases}";`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{date}		= qq`%%variable%% = strftime("%Y%m%d-%H%M",localtime(%%timestamp%%));`;


    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub show_event_calendar
  {
    my $tableprefname	= 'event_calendar_table';
    my $viewerprefname	= 'event_calendar';
    my $allowed_to_view	= user_is_allowed_to('view_event_calendar');
    my $allowed_to_create	= user_is_allowed_to('edit_event_calendar');
    my $allowed_to_edit	= user_is_allowed_to('edit_event_calendar');
    my $allowed_to_delete	= user_is_allowed_to('edit_event_calendar');


    $PREF{"${viewerprefname}_viewer_item_name"}				= 'event';
    $PREF{"${viewerprefname}_viewer_default_sort_field"}			||= 'date';

    if (user_is_allowed_to('view_all_user_event_calendars') && $qs !~ /calview=justme/) {
      $PREF{"${viewerprefname}_viewer_extra_columns"}{username}	= { position => 2, value => '' };
      $PREF{"${viewerprefname}_viewer_hidden_columns"}		||= 'id,userid';
      $PREF{"${viewerprefname}_viewer_footer_note"}			= qq`\n<p><em>Administrators, you can also <a href="$PREF{login_url}?action=calendar&amp;calview=justme">view just your own events</a>.</em></p>\n`;
    } else {
      $PREF{"${viewerprefname}_viewer_disabled_columns"}		||= 'id,userid';
      $PREF{"${viewerprefname}_viewer_selection_restrictions"}	= "WHERE `userid` = $PREF{logged_in_userid}";
    }

    # enc_client_custom:
    #$PREF{"${viewerprefname}_viewer_disabled_columns"}			= $PREF{"${viewerprefname}_viewer_disabled_columns"} ? $PREF{"${viewerprefname}_viewer_disabled_columns"} . ',time' : 'time';


    $PREF{"${viewerprefname}_viewer_title_transforms"}{reminder1}		||= 'Reminder';
    $PREF{"${viewerprefname}_creation_title_transforms"}{date}		||= 'Date (YYYY-MM-DD)';
    $PREF{"${viewerprefname}_editmode_title_transforms"}{date}		||= 'Date (YYYY-MM-DD)';

    $PREF{"${viewerprefname}_viewer_value_transforms"}{username}		= qq`%%variable%% = get_user_name(%%userid%%) ? '<a href="$PREF{login_url}?action=edituser&amp;id=%%userid%%">' . get_user_name(%%userid%%) . '</a>' : '(deleted)';`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{date}		= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)/$1-$2-$3/;';
    $PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{date}	= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)/$1-$2-$3/;';

    $PREF{"${viewerprefname}_viewer_force_textarea"}{description}		= 1;

    $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{reminder1}	= 30*1440 . "///30 days prior|||"
      . 10*1440 . "///10 days prior|||"
        . "0///On date of event";

    $PREF{"${viewerprefname}_creation_autoset_columns"}{userid}		= qq`%%variable%% = $PREF{logged_in_userid};`;
    $PREF{"${viewerprefname}_POST_value_transforms"}{date}			= qq`%%variable%% =~ s/\\D//g;`;



    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub show_event_calendar_reminderlog
  {
    my $tableprefname	= 'event_calendar_reminderlog_table';
    my $viewerprefname	= 'event_calendar_reminderlog';
    my $allowed_to_view	= user_is_allowed_to('view_all_user_event_calendars');
    my $allowed_to_create	= '';
    my $allowed_to_edit	= '';
    my $allowed_to_delete	= user_is_allowed_to('view_all_user_event_calendars');


    $PREF{"${viewerprefname}_viewer_item_name"}				= 'event reminder';
    $PREF{"${viewerprefname}_viewer_default_sort_field"}			||= 'date12';

    #$PREF{"${viewerprefname}_viewer_extra_columns"}{username}		= { position => 4, value => '' };
    #$PREF{"${viewerprefname}_viewer_extra_columns"}{event}			= { position => 5, value => '' };
    $PREF{"${viewerprefname}_viewer_hidden_columns"}			||= 'id,userid,eventid';


    $PREF{"${viewerprefname}_viewer_title_transforms"}{recipient}		||= 'Reminder Recipient';
    $PREF{"${viewerprefname}_viewer_title_transforms"}{eventname}		||= 'Event Name';
    $PREF{"${viewerprefname}_viewer_title_transforms"}{date12}		||= 'Reminder Date';
    #$PREF{"${viewerprefname}_editmode_title_transforms"}{date12}		||= 'Datestamp (YYYY-MM-DD)';

    $PREF{"${viewerprefname}_viewer_value_transforms"}{username}		= qq`%%variable%% = get_user_id('%%username%%') ? '<a href="$PREF{login_url}?action=edituser&amp;id=' . get_user_id('%%username%%') . '">%%username%%</a>' : '(deleted)';`;
    #$PREF{"${viewerprefname}_viewer_value_transforms"}{event}		= qq`%%variable%% = enc_sql_select("SELECT name FROM $PREF{event_calendar_table} WHERE id = %%eventid%%");`;
    $PREF{"${viewerprefname}_viewer_value_transforms"}{date12}		= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/$1-$2-$3 $4:$5/;';

    #$PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{date12}	= '%%variable%% =~ s/(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/$1-$2-$3 $4:$5/;';

    #$PREF{"${viewerprefname}_POST_value_transforms"}{date12}		= qq`%%variable%% =~ s/\\D//g;`;



    # Nothing below here should need to be edited in most cases:
    #
    # Call get_database_data() before starting any output in case we were POSTed
    # to and therefore we need to redirect instead of printing output.
    #
    my $output = get_database_data($tableprefname, $viewerprefname, $allowed_to_view, $allowed_to_create, $allowed_to_edit, $allowed_to_delete);
    start_html_output($PREF{"${viewerprefname}_viewer_title"});
    print $output;
    finish_html_output();
  }


sub send_event_calendar_reminders
  {
    return unless $PREF{enable_event_calendar} =~ /yes/i;

    my $today = strftime("%Y%m%d",localtime(time + $PREF{time_offset}));
    my $events = enc_sql_select_multi("SELECT * FROM `$PREF{event_calendar_table}`");
    foreach my $k (keys %$events) {
      my $eventid = $$events{$k}{id};
      my $userid = $$events{$k}{userid};

      my $eventdate = $$events{$k}{date};
      my $reminder_time_in_mins = $$events{$k}{reminder1}; # number of minutes before the event date.
      my $reminder_time_in_days = $reminder_time_in_mins / 1440;
      my $reminder_date = decrement_datestring_8($eventdate, $reminder_time_in_days);

      if ($today >= $reminder_date) {
        # we're not currently using the time field for our events, but we are using
        # a date12 in the reminderlog table for the reminder timestamp, so for now
        # just set all times to 0000.
        #
        my $reminder_date12 = $reminder_date . '0000';

        my $recipient_username = get_user_name($userid);
        my $recipient_email = get_email_address($userid);

        my $already_sent_reminder = enc_sql_select("SELECT COUNT(*) FROM `$PREF{event_calendar_reminderlog_table}` WHERE `date12` = $reminder_date12 AND `recipient` = '$recipient_email' AND `eventname` = '$$events{$k}{name}'");
        if (!$already_sent_reminder) {
          my $subject = $PREF{event_calendar_reminder_email_subject};
          my $message = $PREF{event_calendar_reminder_email_template};
				#encdebug qq`sending event reminder to $recipient_email for event $$events{$k}{name} dated $$events{$k}{date}`;
          for ($subject,$message) {
            s!%%eventname%%!$$events{$k}{name}!g;
            s!%%eventdate%%!$$events{$k}{date}!g;
            s!%%eventdescription%%!$$events{$k}{description}!g;
            s!%%eventid%%!$eventid!g;
            s!%%userid%%!$userid!g;
            interpolate_userbase_variables($_, $userid);
          }
          send_email($recipient_email, $PREF{event_calendar_reminder_email_sender}, $subject, $message, $PREF{event_calendar_reminder_email_format}, 'die_on_email_error');

          enc_sql_insert("INSERT INTO `$PREF{event_calendar_reminderlog_table}` (`username`, `recipient`, `eventname`, `date12`) VALUES('$recipient_username', '$recipient_email', '$$events{$k}{name}', '$reminder_date12')");
        } else {
				#encdebug qq`NOT sending event reminder (already sent it) to $recipient_email for event $$events{$k}{name} dated $$events{$k}{date}`;
        }
      }
    }
  }


sub setup_profile_image_thumbnail_prefs
  {
    my $j = 0;
    $PREF{smallest_thumbnail_size_for_profile_images} = '';
    $PREF{create_resized_copies_of_uploaded_images} = 'yes';
    foreach my $size (split(/\s*,\s*/, $PREF{profile_image_sizes_to_create})) {
      next unless $size =~ /^\d+$/;
      $j++;
      $PREF{smallest_thumbnail_size_for_profile_images} = $size if ($size < $PREF{smallest_thumbnail_size_for_profile_images}) || $PREF{smallest_thumbnail_size_for_profile_images} eq '';
      $PREF{"create_resized_copies_0${j}__imagemagick_size"}		= $size . 'x' . $size;
      $PREF{"create_resized_copies_0${j}__gd_size"}			= $size;
      $PREF{"create_resized_copies_0${j}__location_type"}		= 'relative';
      $PREF{"create_resized_copies_0${j}__folder_name"}		= $size . 'px';
      $PREF{"create_resized_copies_0${j}__new_filename"}		= '%%orig%%.%%ext%%';
      $PREF{"create_resized_copies_0${j}__skip_if_bigger_than"}	= 1024*1024*20; # in bytes, so "1024*1024*5" is 5 MB, etc.
      $PREF{"create_resized_copies_0${j}__serialize_or_overwrite"}	= 'overwrite';
    }
  }


sub change_profile_image()
  {
    exit_with_needprivs() unless user_is_allowed_to('change_profile_image');
    $PREF{on_page} = 'profileimage';

    if ($ENV{REQUEST_METHOD} =~ /post/i) {
      my $upload_field_name = "image_filenames";
      my $query = new CGI;
      my $num_files_uploaded = 0;
      my %uploadedfiles = ();
      foreach my $tmpfile ($query->upload($upload_field_name)) # what upload() returns is apparently both a handle and a filename?
        {
          $num_files_uploaded++;
          $uploadedfiles{$num_files_uploaded}{param}	= $query->param($upload_field_name);
          $uploadedfiles{$num_files_uploaded}{handle}	= $tmpfile;
          $uploadedfiles{$num_files_uploaded}{filename}	= $tmpfile;
        }

      foreach my $i (sort keys %uploadedfiles) {
        my $filename = $uploadedfiles{$i}{filename};
        $filename = lc($filename) unless $PREF{dont_convert_upload_filenames_to_lowercase} =~ /yes/i;
        $filename =~ s!.*?([^/\\]+)$!$1!;          # remove any path.
        $filename =~ s!\.{2,}!.!g; # condense any multi-dots.
        $filename =~ s![^\w\.-]!_!g; # remove any unusual stuff including spaces.

        my ($file_base,$file_ext) = ($filename =~ /(.+)\.(.+)/);
        die_nice qq`File base name must not be null.` unless $file_base;
        die_nice qq`File extension must be one of ($PREF{profile_image_supported_extensions}) but it's "$file_ext".` unless is_image($filename);

        my $path = $PREF{profile_images_folder_real}; $path .= '/' unless $path =~ m!/$!;
        my $output_file_full = $path . get_profile_image_basename() . '.' . lc($file_ext);
        #$output_file_full = serialize_filename_if_file_exists($output_file_full);
        $uploadedfiles{$i}{output_file_full} = $output_file_full;

        my $upload_filehandle = $uploadedfiles{$i}{handle};
        open(UPLOADFILE,">$output_file_full") or die_nice "couldn't create file '$output_file_full': $!\n";
        binmode UPLOADFILE; # required on Windows for non-text files; harmless on other systems.
        while (<$upload_filehandle>) {
          print UPLOADFILE;
        }
        close UPLOADFILE or die_nice "couldn't close file '$output_file_full': $!\n";
        chmod $PREF{writable_file_perms}, $output_file_full;
      }

      # Do the thumbnail-creation in a separate loop, so any errors here don't
      # prevent the upload itself from succeeding.  And note that the reason we're
      # creating thumbnails here in the first place is in case the user doesn't
      # visit the Manage Item Images page after the upload (it does auto-redirect
      # there after the upload, but due to pagination, the newly-uploaded image
      # might not be on the page the user ends up at).
      #
      foreach my $i (sort keys %uploadedfiles) {
        my ($path,$file) = split_path_and_filename($uploadedfiles{$i}{output_file_full});

        my $resize_details = join "\n<br />", do_automatic_resizing( {
          01 => { name => $file, realpath => $PREF{profile_images_folder_real}, force_overwrite => 1 }
        } );
      }

      enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=changeimage");
    } elsif (get_qs_var('subact') eq 'delete_image') {
      my $file = enc_untaint(get_qs_var('file'));
      foreach my $size (split(/\s*,\s*/, $PREF{profile_image_sizes_to_create})) {
        next unless $size =~ /^\d+$/;
        my $thumbnail_realpath = $PREF{profile_images_folder_real} . '/' . $size . 'px/' . $file;
        unlink($thumbnail_realpath) or die_nice qq`Couldn't delete profile image resized copy '$thumbnail_realpath': $!\n`;
      }
      my $image_realpath = $PREF{profile_images_folder_real} . '/' . $file;
      unlink($image_realpath) or die_nice qq`Couldn't delete profile image '$image_realpath': $!\n`;
      enc_redirect($ENV{HTTP_REFERER} || "$PREF{here_qsready}action=changeimage");
    } else {
      start_html_output("Profile Image Manager");

      print qq`
		<form name="upload_profile_image_form" id="upload_profile_image_form" method="post" enctype="multipart/form-data"
		 action="$ENV{SCRIPT_NAME}?action=changeimage" onsubmit="var btn = document.getElementById('upload_profile_image_submit'); btn.value='Uploading; please wait...'; btn.disabled='disabled'">
		<div id="form_controls">
		<input type="file" name="image_filenames" id="image_filenames" /><br /><br />
		<input type="submit" name="upload_profile_image_submit" id="upload_profile_image_submit" value="Upload Image" />
		</div>
		<div id="form_intro">Upload new profile image here.</div>
		</form>
		`;

      print qq`<table class="profile_image">\n`;
      if (my $file = get_current_profile_image_filename()) {
        my $thumbnail_url = $PREF{profile_images_folder_url} . '/' . $PREF{smallest_thumbnail_size_for_profile_images} . 'px/' . $file;
        my $fullsize_url = $PREF{profile_images_folder_url} . '/' . $file;

        my $resize_details = join "\n<br />", do_automatic_resizing( {
          01 => { name => $file, realpath => $PREF{profile_images_folder_real} }
        } );

        print qq`
				<tr>
					<td class="thumbnail"><a href="$fullsize_url"><img src="$thumbnail_url" alt="[thumbnail for $file]" /></a></td>
					<td class="filename">$file</td>
					<td class="resizedetails">$resize_details</td>
					<td class="deletelink"><a href="$PREF{here_qsready}action=changeimage&amp;subact=delete_image&amp;file=$file">Delete image</a></td>
				</tr>
			`;
      } else {
        print qq`<tr>\n<td class="noimage">$TEXT{no_profile_image_msg}</td>\n</tr>\n`;
      }
      print qq`</table>\n`;

      finish_html_output();
    }
  }


sub is_image
  {
    return $_[0] =~ /\.($PREF{profile_image_supported_extensions})$/i;
  }


sub get_profile_image_basename
  {
    my $userid = shift || $PREF{logged_in_userid}; die_unless_numeric($userid,'userid');
    return get_user_name($userid);
  }


sub get_current_profile_image_filename
  {
    my $userid = shift || $PREF{logged_in_userid}; die_unless_numeric($userid,'userid');
    my $basename = get_profile_image_basename($userid);
    foreach my $ext (split(/\s*\|\s*/, $PREF{profile_image_supported_extensions})) {
      my $filename = $basename . '.' . lc($ext);
      return $filename if -e $PREF{profile_images_folder_real} . "/" . $filename;
    }
    if (-e $PREF{default_profile_image}) {
      my $ext = ($PREF{default_profile_image} =~ /.+\.(.+)/)[0];
      my $filename = $basename . '.' . lc($ext);
      my $filename_real = $PREF{profile_images_folder_real} . "/" . $filename;
      copy($PREF{default_profile_image}, $filename_real) or die_nice qq`Couldn't copy default profile image file: $!`;
      chmod($PREF{writable_file_perms}, $filename_real) or die_nice qq`Couldn't chmod default profile image file with mode '$PREF{writable_file_perms}': $!`;
      return $filename if -e $filename_real;
    }
  }


sub get_profile_image
  {
    return undef unless $PREF{enable_profile_images} =~ /yes/i;

    my $optsref = shift; my %opts = %$optsref if $optsref;
    my $userid = $opts{userid} || $PREF{logged_in_userid}; die_unless_numeric($userid,'userid');
    my $size = $opts{size} || $PREF{smallest_thumbnail_size_for_profile_images};

    my %profile_image = ();
    if (my $file = get_current_profile_image_filename($userid)) {
      my $thumbnail_url = $PREF{profile_images_folder_url} . '/' . $size . 'px/' . $file;
      my $fullsize_url = $PREF{profile_images_folder_url} . '/' . $file;

      my $imagehash = {   01 => { name => $file, realpath => $PREF{profile_images_folder_real} }   };
      my $resize_details = join "\n<br />", do_automatic_resizing($imagehash);

      $profile_image{filename} = $file;
      $profile_image{thumbnail_url} = $thumbnail_url;
      $profile_image{fullsize_url} = $fullsize_url;
      $profile_image{thumbnail_html} = qq`<a href="$fullsize_url" class="thumb_link_to_full"><img src="$thumbnail_url" alt="[thumbnail for $file]" /></a>`;
      return \%profile_image;
    } else {
      return '';
    }
  }


sub show_user_profile
  {
    $PREF{on_page} = 'profile';
    my $uid = get_qs_var('uid') || $PREF{logged_in_userid};
    exit_with_error("Missing or invalid user ID ('$uid').") unless $uid =~ /^\d+$/;
    exit_with_needprivs() unless user_is_allowed_to($PREF{logged_in_userid}, 'view_profile_pages', get_user_name($uid));

    for ($PREF{user_profile_page_title}, $PREF{user_profile_page_template}) {
      s!(%%(\w+)%%)!db_column_exists($2,$PREF{user_table}) ? enc_sql_select("SELECT `$2` FROM `$PREF{user_table}` WHERE `id` = $uid") : $1!eg;
    }




    my $default_fields_block = '';
    my $sections = enc_sql_select_multi("SELECT * FROM `$PREF{field_sections_table}` ORDER BY `section_position`");

    # If there are no sections defined, or just one, then we'll display everything in a single section.
    #%$sections = ();
    my $just_one_section = 0;
    if (!%$sections || !$$sections{1}{id} || (enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`") == 1)) {
      $just_one_section = 1;
      %$sections = ();
      $$sections{1}{id} = enc_sql_select("SELECT `id` FROM `$PREF{field_sections_table}`") || 1; # there's only one id (or none) to return.
    }

    foreach my $j (sort { $$sections{$a}{section_position} <=> $$sections{$b}{section_position} } keys %$sections) {
      my $section_id = $$sections{$j}{id};

      my $template			= $PREF{user_profile_page_default_fields_block_template};
      #my $section_header_template	= $PREF{user_profile_section_header_template};

      my $allfields = '';
      my ($field_template) = ($template =~ m!%%%template:field%%%(.+?)%%%end-template:field%%%!gs);
      if ($PREF{show_builtin_fields_with_custom_fields_in_profile} =~ /yes/i) {
        foreach my $builtin_field ('username', 'name', 'email') {
          next unless ($section_id eq $PREF{show_builtin_fields_in_this_section_id}) || $just_one_section;
				#next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_view});
          next if $builtin_field eq 'name' && $PREF{use_builtin_realname_field} !~ /yes/i;
          next if $builtin_field eq 'email' && $PREF{use_builtin_email_field} !~ /yes/i;

          my $f_template = $field_template;

          $f_template =~ s!%%fieldname%%!$builtin_field!g;
          $f_template =~ s!%%fieldlabel%%!$PREF{"${builtin_field}_label"}!g;
          $f_template =~ s!%%fieldvalue%%!enc_sql_select("SELECT `$builtin_field` FROM `$PREF{user_table}` WHERE `id` = $uid")!eg;

          $allfields .= $f_template;
        }
      }
      if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`")) {
        my $fields = enc_sql_select_multi("SELECT * FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
        foreach my $k (sort { $a <=> $b } keys %$fields) {
          next unless ($$fields{$k}{enabled} && db_column_exists($$fields{$k}{fieldname}, $PREF{user_table}));
          next unless ($section_id eq $$fields{$k}{section}) || $just_one_section;
          next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$k}{groups_allowed_to_view});

          my $value = enc_sql_select("SELECT `$$fields{$k}{fieldname}` FROM `$PREF{user_table}` WHERE `id` = $uid");

          my $f_template = $field_template;

          $f_template =~ s!%%fieldname%%!$$fields{$k}{fieldname}!gs;
          $f_template =~ s!%%fieldlabel%%!$$fields{$k}{fieldlabel}!gs;
          $f_template =~ s!%%fieldvalue%%!$value!gs;

          $allfields .= $f_template;
        }
      }
      $template =~ s!%%%template:field%%%(.+?)%%%end-template:field%%%!$allfields!gs;


      my $show_builtin_fields		= $section_id eq $PREF{show_builtin_fields_in_this_section_id};
      #my $show_customfields		= $customfields && $display_custom_fields;
      next if !$allfields;      # no output in this section.

      $template =~ s!%%section_label%%!$$sections{$j}{label} || $PREF{section_label_for_sections_without_labels}!eg;

      $template =~ s!%%section_css_id%%!'section_' . ($$sections{$j}{name} || $j)!eg;

      $template =~ s!%%%if-use_builtin_realname_field%%%(.*?)%%%end-use_builtin_realname_field%%%!my $var = $1; $PREF{use_builtin_realname_field} =~ /yes/i ? $var : ''!egs;
      $template =~ s!%%%if-use_builtin_email_field%%%(.*?)%%%end-use_builtin_email_field%%%!my $var = $1; $PREF{use_builtin_email_field} =~ /yes/i ? $var : ''!egs;
      #$template =~ s!%%%if-show_grouplist%%%(.*?)%%%end-show_grouplist%%%!$grouplist ? $1 : ''!egs;
      $template =~ s!%%%if-show_builtin_fields%%%(.*?)%%%end-show_builtin_fields%%%!$show_builtin_fields ? $1 : ''!egs;
      #$template =~ s!%%%if-show_customfields%%%(.*?)%%%end-show_customfields%%%!$show_customfields ? $1 : ''!egs;
      #$template =~ s#%%%if-show_payment_options%%%(.*?)%%%end-show_payment_options%%%#my $var = $1; $mode eq 'user_signup' && $PREF{enable_paid_accounts} =~ /yes/i && !$PREF{all_accounts_are_paid_accounts_with_this_type} ? $var : ''#egs;

      #$template =~ s!%%user_profile_section_header%%!$section_header_template!g;

      $template =~ s!%PREF{(.+?)}!$PREF{$1}!g;

      #$template =~ s!%%(\w+)%%!$vars{$1}!g;
      $template =~ s!%%%if-(\w+)%%%(.*?)%%%end-\1%%%!!gs;

      $default_fields_block .= $template;
    }

    $PREF{user_profile_page_template} =~ s!%%default_fields_block%%!$default_fields_block!g;

    my $profile_image_ref = get_profile_image({userid=>$uid}); my %profile_image = %$profile_image_ref if $profile_image_ref;
    $PREF{user_profile_page_template} =~ s!%%smallest_profile_image_html%%!$profile_image{thumbnail_html}!g;





    start_html_output($PREF{user_profile_page_title});
    print $PREF{user_profile_page_template};
    finish_html_output();
  }


sub show_member_directory
  {
    $PREF{on_page} = 'memberdirectory';
    exit_with_needprivs() unless user_is_allowed_to('view_member_directory');
	
    my $member_directory_list = '';

    my $i = 0;
    my ($range_start,$range_end) = get_pagination_range($PREF{num_members_per_page_on_member_directory});

    my $users = get_users_belonging_to_group({ group=>'member', exclude_pending=>1, exclude_admins=>$PREF{exclude_admins_from_member_directory}=~/yes/i });
    foreach my $uid (sort { $$users{$a}{username} cmp $$users{$b}{username} } keys %$users) {
      $i++; next unless $range_start <= $i && $i <= $range_end;

      my $list_template = $PREF{member_directory_list_template};
      $list_template =~ s!(%%(\w+)%%)!db_column_exists($2,$PREF{user_table}) ? enc_sql_select("SELECT `$2` FROM `$PREF{user_table}` WHERE `id` = $uid") : $1!eg;

      my $default_fields_block = '';
      my $sections = enc_sql_select_multi("SELECT * FROM `$PREF{field_sections_table}` ORDER BY `section_position`");

      # If there are no sections defined, or just one, then we'll display everything in a single section.
      #%$sections = ();
      my $just_one_section = 0;
      if (!%$sections || !$$sections{1}{id} || (enc_sql_select("SELECT COUNT(*) FROM `$PREF{field_sections_table}`") == 1)) {
        $just_one_section = 1;
        %$sections = ();
        $$sections{1}{id} = enc_sql_select("SELECT `id` FROM `$PREF{field_sections_table}`") || 1; # there's only one id (or none) to return.
      }

      foreach my $j (sort { $$sections{$a}{section_position} <=> $$sections{$b}{section_position} } keys %$sections) {
        my $section_id = $$sections{$j}{id};

        my $template			= $PREF{member_directory_page_default_fields_block_template};
        #my $section_header_template	= $PREF{member_directory_section_header_template};

        my $allfields = '';
        my ($field_template) = ($template =~ m!%%%template:field%%%(.+?)%%%end-template:field%%%!gs);
        if ($PREF{show_builtin_fields_with_custom_fields_in_directory} =~ /yes/i) {
          foreach my $builtin_field ('username', 'name', 'email') {
            next unless ($section_id eq $PREF{show_builtin_fields_in_this_section_id}) || $just_one_section;
            #next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$j}{groups_allowed_to_view});
            next if $builtin_field eq 'name' && $PREF{use_builtin_realname_field} !~ /yes/i;
            next if $builtin_field eq 'email' && $PREF{use_builtin_email_field} !~ /yes/i;

            my $f_template = $field_template;

            $f_template =~ s!%%fieldname%%!$builtin_field!g;
            $f_template =~ s!%%fieldlabel%%!$PREF{"${builtin_field}_label"}!g;
            $f_template =~ s!%%fieldvalue%%!enc_sql_select("SELECT `$builtin_field` FROM `$PREF{user_table}` WHERE `id` = $uid")!eg;

            $allfields .= $f_template;
          }
        }
        if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`")) {
          my $fields = enc_sql_select_multi("SELECT * FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
          foreach my $k (sort { $a <=> $b } keys %$fields) {
            next unless ($$fields{$k}{enabled} && db_column_exists($$fields{$k}{fieldname}, $PREF{user_table}));
            next unless ($section_id eq $$fields{$k}{section}) || $just_one_section;
            next unless logged_in_user_belongs_to_one_of_these_group_ids($$fields{$k}{groups_allowed_to_view});

            my $value = enc_sql_select("SELECT `$$fields{$k}{fieldname}` FROM `$PREF{user_table}` WHERE `id` = $uid");

            my $f_template = $field_template;

            $f_template =~ s!%%fieldname%%!$$fields{$k}{fieldname}!gs;
            $f_template =~ s!%%fieldlabel%%!$$fields{$k}{fieldlabel}!gs;
            $f_template =~ s!%%fieldvalue%%!$value!gs;

            $allfields .= $f_template;
          }
        }
        $template =~ s!%%%template:field%%%(.+?)%%%end-template:field%%%!$allfields!gs;


        my $show_builtin_fields		= $section_id eq $PREF{show_builtin_fields_in_this_section_id};
        #my $show_customfields		= $customfields && $display_custom_fields;
        #my $no_output_in_this_section	= !($show_builtin_fields || $show_customfields);

        $template =~ s!%%section_label%%!$$sections{$j}{label} || $PREF{section_label_for_sections_without_labels}!eg;

        $template =~ s!%%section_css_id%%!'section_' . ($$sections{$j}{name} || $j)!eg;

        $template =~ s!%%%if-use_builtin_realname_field%%%(.*?)%%%end-use_builtin_realname_field%%%!my $var = $1; $PREF{use_builtin_realname_field} =~ /yes/i ? $var : ''!egs;
        $template =~ s!%%%if-use_builtin_email_field%%%(.*?)%%%end-use_builtin_email_field%%%!my $var = $1; $PREF{use_builtin_email_field} =~ /yes/i ? $var : ''!egs;
        #$template =~ s!%%%if-show_grouplist%%%(.*?)%%%end-show_grouplist%%%!$grouplist ? $1 : ''!egs;
        $template =~ s!%%%if-show_builtin_fields%%%(.*?)%%%end-show_builtin_fields%%%!$show_builtin_fields ? $1 : ''!egs;
        #$template =~ s!%%%if-show_customfields%%%(.*?)%%%end-show_customfields%%%!$show_customfields ? $1 : ''!egs;
        #$template =~ s#%%%if-show_payment_options%%%(.*?)%%%end-show_payment_options%%%#my $var = $1; $mode eq 'user_signup' && $PREF{enable_paid_accounts} =~ /yes/i && !$PREF{all_accounts_are_paid_accounts_with_this_type} ? $var : ''#egs;

        #$template =~ s!%%member_directory_section_header%%!$section_header_template!g;

        $template =~ s!%PREF{(.+?)}!$PREF{$1}!g;

        #$template =~ s!%%(\w+)%%!$vars{$1}!g;
        $template =~ s!%%%if-(\w+)%%%(.*?)%%%end-\1%%%!!gs;

        $default_fields_block .= $template; # unless $no_output_in_this_section;
      }

      $list_template =~ s!%%default_fields_block%%!$default_fields_block!g;

      my $profile_image_ref = get_profile_image({userid=>$uid}); my %profile_image = %$profile_image_ref if $profile_image_ref;
      $list_template =~ s!%%smallest_profile_image_html%%!$profile_image{thumbnail_html}!g;
      $list_template =~ s!%%profile_link%%!$PREF{here_qsready}action=viewuser&amp;uid=$uid!g;
      $member_directory_list .= $list_template;
    }

    my $pagelinks = get_pagination_links_mark2( {
      range_start => $range_start, range_end => $range_end,
      num_items => $i, items_per_page => $PREF{num_members_per_page_on_member_directory},
      itemname_singular => 'member',
      itemname_plural => 'members',
      #template => $PREF{filelist_pagination_links_template},
      hide_sort_links => 1,
      hide_when_single_page => 1
    } );


    start_html_output($PREF{member_directory_page_title});
    print $member_directory_list;
    print $pagelinks;
    finish_html_output();
  }


##############################################################################
### Shared-UB: ###############################################################
##############################################################################


sub load_external_prefs
  {
    my ($script_basename) = ($ENV{SCRIPT_NAME} =~ m!.*?[/\\]?([^/\\]+)\.[^/\\\.]+!);
    my ($script_dirname) = ($ENV{SCRIPT_NAME} =~ m!^(.+)/.*?$!);
    my $prefs_basename = $_[0] eq 'use_internal_filename' ? $PREF{internal_filename} : $script_basename;

    my @prefs_files = (	"encodable_shared_prefs___overrideable",
                        "${prefs_basename}_shared_prefs___overrideable",
                        "${prefs_basename}_prefs_new",
                        "${prefs_basename}_prefs",
                        "${prefs_basename}_prefs_extra",
                        "encodable_shared_prefs___nonoverrideable",
                        "${prefs_basename}_shared_prefs___nonoverrideable",
                      );

    my $critical_prefs_loaded = 0;
    foreach my $prefs_file (@prefs_files) {
      for ($prefs_file,
           "$PREF{DOCROOT}/cgi-bin/$prefs_file",		"$PREF{DOCROOT}/../cgi-bin/$prefs_file",
           "$PREF{DOCROOT}/cgi/$prefs_file",		"$PREF{DOCROOT}/../cgi/$prefs_file",
           "$PREF{DOCROOT}$script_dirname/$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/$prefs_file",

           # Also try the parent dir, mainly because it's a likely place for any shared prefs files:
           "$PREF{DOCROOT}$script_dirname/../$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/../$prefs_file", "../$prefs_file"
         ) {
        if (my $file = -e "${_}.cgi" ? "${_}.cgi" : -e "${_}.pl" ? "${_}.pl" : '') {
          my $prefs_contents = ();
          open(IN,"<$file") or die_nice("couldn't open prefs file '$file': $!");
          flock IN, 1;
          seek IN, 0, 0;
          while (<IN>) {
            $prefs_contents .= $_;
          }
          close IN or die_nice("couldn't close prefs file '$file': $!");
          $prefs_contents =~ /(.*)/s;
          $prefs_contents = $1; # cheap untaint since this is our own config file.
          eval $prefs_contents; die_nice("Error processing your prefs file ('$file'): $@") if $@;
          $critical_prefs_loaded = 1 unless $file =~ /(_shared_prefs_|_prefs_extra)/;
          $PREF{loaded_prefs_files} .= "$file, ";
          last;
        }
      }
    }

    $PREF{loaded_prefs_files} =~ s!, $!!;

    if (!$critical_prefs_loaded) {
      if ($_[0] ne 'use_internal_filename') {
        # First pass failed, so try again but use $PREF{internal_filename} as the prefs base.
        load_external_prefs('use_internal_filename');
      } else {
        # Second pass failed too; nothing else we can do.
        die_nice(
          "Error: couldn't find any prefs file to load.  You must put your $PREF{prefs_basename}_prefs.cgi file on the server with the $PREF{prefs_basename}.cgi file."
            . ($PREF{docroot_autodetection_error} ? qq` <br /><br />\nThis may be caused by or related to the following: $PREF{docroot_autodetection_error}` : '')
          );
      }
    }
  }


sub load_userbase_prefs
  {
    if ($PREF{integrate_with_userbase} =~ /yes/i   &&   $PREF{internal_appname} !~ /^userbase$/i) {
      # Try to load UserBase prefs from userbase_prefs.cgi to avoid
      # having to specify common prefs twice.

      my %ub_pref_names = (
        database_hostname				=> 1,
        database_name					=> 1,
        database_username				=> 1,
        database_password				=> 1,
        dbi_connection_string				=> 1,

        time_offset					=> 1,
        hide_poweredby					=> 1,

        site_session_cookie				=> 1,
        login_url					=> 1,

        user_table					=> 1,
        group_table					=> 1,
        custom_field_table				=> 1, # for backwards compatibility.
        custom_field_list_table				=> 1,

        max_username_length				=> 1,
        max_groupname_length				=> 1,
        max_hashedpw_length				=> 1,

        allow_spaces_in_usernames			=> 1,
        allow_atsigns_in_usernames			=> 1,
        allow_dots_in_usernames				=> 1,
        allow_dashes_in_usernames			=> 1,

        allow_spaces_in_groupnames			=> 1,
        allow_atsigns_in_groupnames			=> 1,
        allow_dots_in_groupnames			=> 1,
        allow_dashes_in_groupnames			=> 1,

        make_usernames_case_insensitive			=> 1,
        make_passwords_case_insensitive			=> 1,

        idle_timeout					=> 1,
        num_days_rememberme_cookie_lasts		=> 1,
        enable_ip_address_restriction			=> 1,
        force_ip_address_restriction			=> 1,
        disable_ip_restriction_for_AOL_users		=> 1,
        enable_forced_password_change			=> 1,
        admins_can_be_forced_to_change_their_own_pws	=> 1,
        prevent_multiple_simultaneous_logons_per_username => 1,

        subgroup_groupname_suffix			=> 1,
        groups_that_can_manage_subgroup_users		=> 1,
      );

      my $prefs_basename = $PREF{userbase_prefs_file_basename};
      my @prefs_files = ("${prefs_basename}_prefs_new.cgi", "${prefs_basename}_prefs_new.pl", "${prefs_basename}_prefs.cgi", "${prefs_basename}_prefs.pl", "${prefs_basename}_prefs_extra.cgi", "${prefs_basename}_prefs_extra.pl");
      push (@prefs_files, $PREF{userbase_prefs_file}) if $PREF{userbase_prefs_file}; # so we can specify it manually, including full path, if necessary.
      push (@prefs_files, $PREF{userbase_prefs_file_extra}) if $PREF{userbase_prefs_file_extra};
      my $prefs_loaded = 0;
      foreach my $prefs_file (@prefs_files) {
        for (get_likely_prefs_file_locations($prefs_file)) {
          if (-e $_) {
            my $file = $_;
            open(IN,"<$file") or die_nice("couldn't open prefs file '$file': $!");
            flock IN, 1;
            seek IN, 0, 0;
            while (<IN>) {
              if (/^\$PREF{(\w+)}\s*=\s*(.+)/) {
                my ($pref,$value) = ($1,$2);
                if ($ub_pref_names{$pref}) {
                  if ($value =~ /ENV\{SCRIPT_NAME\}/) {
                    # In userbase_prefs.cgi, any use of $ENV{SCRIPT_NAME} is intended to mean '/cgi-bin/userbase.cgi'
                    # (or whatever the path to userbase.cgi is), so we can't eval that here from FileChucker etc,
                    # because then it will end up being '/cgi-bin/filechucker.cgi' instead.  (This is primarily a
                    # problem for the $PREF{login_url} setting.)  So we'll try to figure out what the correct path to
                    # userbase.cgi is, and if we can't, then we'll just skip this line from the userbase_prefs.cgi file.

                    foreach my $likely_prefs_file (get_likely_prefs_file_locations($prefs_file)) {
                      my $script_name_full = $likely_prefs_file;
                      $script_name_full =~ s!_prefs(_(new|extra))?!!; # remove the _prefs/_prefs_new/_prefs_extra from the prefs filename to get the script name.

                      if (-e $script_name_full) {
                        if ($script_name_full =~ m!^$PREF{DOCROOT}(.+)!) # we only want the ones including the full path (i.e. just plain "userbase_prefs.cgi" doesn't help us here).
                          {
                            my $script_name = $1;
                            $script_name =~ s!\.\./!!g; # in case this is one of the paths containing a "../", which is OK in the filesystem but not in URLs.

                            my $updated_line = '';

                            if (/^\$PREF{\w+}\s*=\s*\$ENV{SCRIPT_NAME};$/) {
                              # If it's a simple "$PREF{foo} = $ENV{SCRIPT_NAME};" line, then we know we need to
                              # add quotes around the $script_name value that we interpolate back into it:
                              #
                              $updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!'$script_name'!g;
                              eval $updated_line;
                            } else {
                              # Otherwise, the original line may or may not have had the ENV{SCRIPT_NAME} variable
                              # within a quoted string, so we'll have to try this multiple ways:
                              #
                              $updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!$script_name!g;
                              eval $updated_line;
                              if ($@) {
                                $updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!'$script_name'!g;
                                eval $updated_line;
                                if ($@) {
                                  $updated_line = $_; $updated_line =~ s!(%|\$)ENV\{SCRIPT_NAME\}!"$script_name"!g;
                                  eval $updated_line;
                                  if ($@) {
                                    # We tried.
                                    die_nice(qq`Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\n(While processing line: "$updated_line") <br /><br />\n\nYou should get UserBase running first, then return here.`);
                                  }
                                }
                              }
                            }
                            last;
                          }
                      }
                    }
                  } else {
                    eval $_; die_nice(qq`Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\n(While processing line: "$_") <br /><br />\n\nYou should get UserBase running first, then return here.`) if $@;
                  }
                }
              } elsif (/^\$TEXT{(\w+)}\s*=\s*/) {
                eval $_; die_nice(qq`Error processing your UserBase prefs file ('$file'): $@ <br /><br />\n\n(While processing line: "$_") <br /><br />\n\nYou should get UserBase running first, then return here.`) if $@;
              }
            }
            close IN or die_nice("couldn't close prefs file '$file': $!");
            $PREF{loaded_userbase_prefs_files} .= "$file, ";
            $prefs_loaded = 1;
            last;
          }
        }
      }
      die_nice("Error: couldn't find any UserBase prefs file to load.  You must put your UserBase prefs file on the server with this script file.  This script will look in its own folder, in the cgi-bin folder, and in the login folder by default.  You can also add a new line to this script's prefs file setting \$PREF{userbase_prefs_file_extra} to the full filename (including path) of your UserBase prefs file.") unless $prefs_loaded;
    }
	
    $PREF{loaded_userbase_prefs_files} =~ s!, $!!;

    $PREF{custom_field_list_table} = $PREF{custom_field_table} if $PREF{custom_field_table} && !$PREF{custom_field_list_table}; # For backwards compatibility;
    $PREF{custom_field_table} = $PREF{custom_field_list_table} if $PREF{custom_field_list_table} && !$PREF{custom_field_table}; # this was just a renamed pref.
  }


sub get_likely_prefs_file_locations($)
  {
    my $prefs_file = shift;
    my ($script_dirname) = ($ENV{SCRIPT_NAME} =~ m!^(.+)/.*?$!);
    return($prefs_file,
           "$PREF{DOCROOT}/cgi-bin/$prefs_file",		"$PREF{DOCROOT}/../cgi-bin/$prefs_file",
           "$PREF{DOCROOT}/cgi/$prefs_file",		"$PREF{DOCROOT}/../cgi/$prefs_file",
           "$PREF{DOCROOT}/login/$prefs_file",		"$PREF{DOCROOT}/../login/$prefs_file",
           "$PREF{DOCROOT}$script_dirname/$prefs_file",	"$PREF{DOCROOT}/..$script_dirname/$prefs_file"
         );
  }


sub load_other_prefs_files
  {
    my @other_prefs_files = ();
    foreach my $num (sort keys %{$PREF{other_prefs_files}}) {
      my $name = $PREF{other_prefs_files}{$num}{shortcut_name};
      if ($qs =~ /(?:^|&)prefs=$name(?:&|$)/) {
        my $file = $PREF{other_prefs_files}{$num}{shortcut_target};
        if ($PREF{other_prefs_files_are_in_docroot} =~ /yes/i) {
          $file = "$PREF{DOCROOT}/$file";
          condense_slashes('leave_leading_UNC', $file);
        }
        die_nice("prefs file '$file' does not exist.") unless -e $file;
        push @other_prefs_files, $file;
      }
    }
    if ($PREF{enable_other_prefs_files_with_filename_on_URL} =~ /yes/i) {
      while ($qs =~ /(?:^|&)prefsfile=(.+?)(?:&|$)/g) {
        my $file = $1;
        if ($PREF{other_prefs_filenames_from_URL_can_contain_paths} =~ /yes/i) {
          $file = enc_untaint($file, 'keep_path');
        } else {
          $file = enc_untaint($file);
        }
        if ($PREF{other_prefs_files_are_in_docroot} =~ /yes/i) {
          $file = "$PREF{DOCROOT}/$file";
          condense_slashes('leave_leading_UNC', $file);
        }
        die_nice("prefs file '$file' does not exist.") unless -e $file;
        push @other_prefs_files, $file;
      }
    }
    foreach my $prefs_file (@other_prefs_files) {
      my $prefs_contents = ();
      open(IN,"<$prefs_file") or die_nice("couldn't open prefs file '$prefs_file': $!");
      flock IN, 1;
      seek IN, 0, 0;
      while (<IN>) {
        $prefs_contents .= $_;
      }
      close IN or die_nice("couldn't close prefs file '$prefs_file': $!");
      $prefs_contents =~ /(.*)/s;
      $prefs_contents = $1; # cheap untaint since this is our own config file.
      eval $prefs_contents; die_nice("Error processing your prefs file: $@") if $@;
    }
  }


sub do_preinit()
  {
    $PREF{app_start_time} = time;
    if ($ENV{QUERY_STRING} eq 'version') {
      print "Content-type: text/plain\n\n"; print "$version\n"; exit;
    }
    my ($cwd) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)/.*?$!);
    unless ($cwd) {
      $cwd = $ENV{PATH_TRANSLATED}; $cwd =~ s![^/\\]+$!!;
    }
    enc_chdir($cwd);
    $PREF{initial_cwd} = $cwd;
    $PREF{on_page} = 'default';
    $qs = $ENV{QUERY_STRING};
    populate_cookies_hash();
  }


sub verify_server_environment()
  {
    #print STDERR dumphash(\%ENV,"\n") . "\n";
    my ($SCRIPT_var_count, $SERVER_var_count) = (0, 0);
    my @all_vars = ();
    foreach my $var (sort keys %ENV) {
      $SCRIPT_var_count++ if $var =~ /^SCRIPT_/;
      $SERVER_var_count++ if $var =~ /^SERVER_/;
      push @all_vars, "$var: $ENV{$var}";
    }
    unless($SCRIPT_var_count > 0 && $SERVER_var_count > 0)
      {
        die qq`Error: it seems I've been executed on a command line, but that won't work, since I'm a web application and must be executed within a server environment.\n`; # . qq`\nAll vars: ` . (join "\n", @all_vars) . qq`\n\n`;
      }
  }


sub fix_server_environment()
  {
    # Fix the %ENV if necessary.
    #
    if (!$ENV{REQUEST_URI})     # IIS is crap.
      {
        $ENV{REQUEST_URI} = $ENV{PATH_INFO};
        $ENV{REQUEST_URI} .= '?' . $qs if $qs;
      }

    # On GoDaddy, for subdomains, they set DOCUMENT_ROOT incorrectly, and set SUBDOMAIN_DOCUMENT_ROOT to the real docroot.
    $ENV{DOCUMENT_ROOT} = $ENV{SUBDOMAIN_DOCUMENT_ROOT} if $ENV{SUBDOMAIN_DOCUMENT_ROOT};

    $PREF{DOCROOT} ||= $ENV{DOCUMENT_ROOT};
    if (!$PREF{DOCROOT}) {
      ($PREF{DOCROOT}) = ($ENV{SCRIPT_FILENAME} =~ m!^(.+)$ENV{SCRIPT_NAME}$!i);
      if (!$PREF{DOCROOT}) {
        # try to fix IIS garbage.
        my $path_translated = $ENV{PATH_TRANSLATED};
        my $is_unc = $path_translated =~ m!^\\\\!;
        $path_translated =~ s!\\\\!/!g;
        $path_translated =~ s!\\!/!g;
        $path_translated =~ s!^[/\\]+!\\\\! if $is_unc;
        if ($path_translated =~ m!^(.+)$ENV{PATH_INFO}$!i) {
          $PREF{DOCROOT} = $1;
        } else {
          $PREF{DOCROOT} = ($path_translated =~ m!(.+)/[^/]+!)[0];
        }
      }
      $PREF{docroot_autodetection_error} = "Error: couldn't set \$PREF{DOCROOT} from \$ENV{DOCUMENT_ROOT} ('$ENV{DOCUMENT_ROOT}'), \$ENV{SCRIPT_FILENAME} ('$ENV{SCRIPT_FILENAME}'), or \$ENV{PATH_TRANSLATED} ('$ENV{PATH_TRANSLATED}').\n" unless $PREF{DOCROOT};
    }
    $PREF{DOCROOT} =~ s![/\\]+$!! unless $PREF{DOCROOT} =~ m!^[/\\]+$!; # remove trailing slashes.

    # Fix another Network Solutions bug:
    if ($PREF{DOCROOT} =~ m!/usr/services/vux/apache/htdocs!   &&   $ENV{SCRIPT_FILENAME} =~ m!(/data/\d+/\d+/\d+/\d+/\d+/user/\d+)/cgi-bin!) {
      $PREF{DOCROOT} = "$1/htdocs";
    }

    my $default_scriptname = '/cgi-bin/' . $PREF{internal_filename} . '.cgi';
    $ENV{SCRIPT_NAME} ||= $default_scriptname;

    # Fix for broken Network Solutions servers:
    $ENV{SCRIPT_NAME} = $1 if $ENV{SCRIPT_NAME} =~ m!~\d+\.\d+/(/cgi-bin/.+)!;

    # Fix stupid servers that set our scriptname to the wrapper scriptname:
    $ENV{SCRIPT_NAME} = $default_scriptname if $ENV{SCRIPT_NAME} =~ /\.php/ && -e "$PREF{DOCROOT}/$default_scriptname";
    $ENV{SCRIPT_NAME} = $default_scriptname if $ENV{SCRIPT_NAME} =~ /\.php/ && -e "$PREF{DOCROOT}/../$default_scriptname";
  }


sub set_default_prefs_for_all_apps()
  {
    # Prefs that are needed by all apps, and that are (at least by default) set
    # to the same values in all apps.  And we don't need any "unless exists"
    # tests here because this sub is called before loading external prefs.

    $PREF{list_of_sql_safe_characters} = qq`ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789 !#%^&*()_=+ ~ []{}| ;:'" ,.<>/? \`\@\$\r\n\t\\-`; # dash, if present, must be last.

    $PREF{max_tablename_length}			= 80;

    $PREF{site_session_cookie}			= 'site_session';
    $PREF{non_userbase_login_cookie}		= 'enc_non_ub_login';
    $PREF{num_days_login_lasts}			= 14;
    $PREF{enc_visitor_id_cookie}			= 'encvisid';
    $PREF{enc_visitor_id_was_missing}		= 1 unless $COOKIE{ $PREF{enc_visitor_id_cookie} };
    $PREF{enc_visitor_id}				= $COOKIE{ $PREF{enc_visitor_id_cookie} } || generate_random_hash();

    $PREF{public_group_name}			= 'public';
    $PREF{member_group_name}			= 'member';
    $PREF{admin_group_name}				= 'admin';

    $PREF{writable_dir_perms}			= 0777;
    $PREF{writable_file_perms}			= 0666;

    $PREF{here}					= $ENV{SCRIPT_NAME};
    #$PREF{here_login}				= $ENV{SCRIPT_NAME}; # deprecated by figure_out_where_here_is (?)

    $PREF{needlogin_message}			= qq`%%js_auto_redirect%%<h1 class="pagetitle">Login Required</h1><p>Login required; <a href="%%login_url%%">click here</a> to continue.</p>`;
    $PREF{needprivs_message}			= qq`%%js_auto_redirect%%<h1 class="pagetitle">Access Denied</h1><p>Access denied.&nbsp; %%%if-notloggedin%%%Perhaps you need to <a href="%%login_url%%">login</a> first?%%%end-notloggedin%%%</p>`;
  }


sub check_for_enc_visitor_id()
  {
    # This check must occur before trying anything that could result in an error
    # like reading prefs files, checking whether datadirs exist, etc.  That's 
    # because in some cases, particularly when a client wants to use ENV variables
    # from PHP to set a path pref dynamically, an error due to a nonexistent path
    # would prevent us from setting the enc_visitor_id, but would also be *caused*
    # by a missing enc_visitor_id.  So, set_enc_visitor_id() is designed to not
    # depend on anything else (prefs, etc), so it can be called separately and
    # then exit, just to get the cookie in place.

    if ($qs =~ /(^|&)action=set_enc_visitor_id(&|$)/) {
      set_enc_visitor_id();
    }                           # exits early.
  }


sub load_webconfig_prefs
  {

  }


sub populate_cookies_hash()
  {
    foreach my $cookie (split(/;\s*/, $ENV{HTTP_COOKIE})) {
      my ($name,$value) = split(/=/, $cookie);
      $COOKIE{$name} = enc_urldecode_return($value);
    }
  }


sub settle_docroot_datadir_cgimodule_etc()
  {
    # DOCROOT must be one of the first things settled after loading the external prefs:
    #
    $PREF{DOCROOT} = enc_untaint($PREF{DOCROOT}, 'keep_path');
    exit_with_error("Error: you have set \$PREF{DOCROOT} to '$PREF{DOCROOT}', but that path does not exist.  You must create it now, or adjust this setting to point to the correct directory.") if ! -d $PREF{DOCROOT};


    # datadir should be settled right after DOCROOT:
    #
    $PREF{datadir} = 'encdata' unless $PREF{datadir};
    $PREF{datadir} = $PREF{DOCROOT} . $PREF{datadir} if $PREF{datadir_is_in_docroot} eq 'yes';
    create_dir_if_DNE($PREF{datadir}, $PREF{writable_dir_perms}, 'make_parents', 'ignore_errors');
    exit_with_error(qq`Error: your settings for \$PREF{datadir} and \$PREF{datadir_is_in_docroot} \nresult in \$PREF{datadir} being set to '$PREF{datadir}', \nbut that path does not exist.  You must create it, or adjust these \nsettings to point to the correct directory.`) unless -d $PREF{datadir};
    exit_with_error(qq`Error: the directory \$PREF{datadir}  ($PREF{datadir})  must be readable by this script (which usually means world-readable), but it isn't.`) if ! -r $PREF{datadir};
    exit_with_error(qq`Error: the directory \$PREF{datadir}  ($PREF{datadir})  must be writable by this script (which usually means world-writable), but it isn't.`) if ! -w $PREF{datadir};
    #
    # Append our per-app subdir onto datadir ($PREF{datadir} should be set to just 'encdata' by default):
    #
    $PREF{datadir_subdir_name} = $PREF{internal_appname} unless $PREF{datadir_subdir_name};
    $PREF{datadir} .= $PREF{datadir} =~ m![/\\]$! ? $PREF{datadir_subdir_name} : "/$PREF{datadir_subdir_name}";
    create_dir_if_DNE($PREF{datadir}, $PREF{writable_dir_perms});


    # Once $PREF{datadir} is settled, set $ENV{TMPDIR} to that, and THEN we can
    # import the CGI module via "require CGI;" and it will use our $ENV{TMPDIR}
    # setting as its temp space during uploads.
    #
    $ENV{TMPDIR} = $PREF{datadir} unless $PREF{dont_use_datadir_as_cgi_tmpdir} =~ /yes/i;
    $CGITempFile::TMPDIRECTORY = $PREF{datadir} unless $PREF{dont_use_datadir_as_cgi_tmpdir} =~ /yes/i; # necessary on some servers?
    #
    #use CGI; # DO NOT USE THIS!
    #
    require CGI;
    #
    #use CGI qw/:standard :param/; # DO NOT USE THIS!
    #use CGI qw(param); # DO NOT USE THIS!
    #
    import CGI ':standard';
    import CGI ':param';
    #
    use CGI::Cookie;            # "use" is OK for sub-modules.


    unless ($PREF{app_base_folder} =~ m!^/!) {
      $PREF{app_base_folder} = '/login'	if $PREF{internal_appname} eq 'userbase';
      $PREF{app_base_folder} = '/upload'	if $PREF{internal_appname} eq 'filechucker';
      $PREF{app_base_folder} = '/visitors'	if $PREF{internal_appname} eq 'visitorlog';
      $PREF{app_base_folder} = '/contact'	if $PREF{internal_appname} eq 'contactform';
      $PREF{app_base_folder} = '/mailylist'	if $PREF{internal_appname} eq 'mailylist';
      $PREF{app_base_folder} = '/store'	if $PREF{internal_appname} eq 'cornerstore';
    }
    exit_with_error("Error: \$PREF{app_base_folder} not set; it must be set to something like '/appname'.") unless $PREF{app_base_folder};


    # appdir is like datadir except a) it's servable and b) it's per-app (within the
    # app's base folder) rather than within the shared /cgi-bin/encdata folder.
    #
    $PREF{appdir_url}	= $PREF{app_base_folder} . ($PREF{app_base_folder} =~ m![/\\]$! ? '' : '/') . "appdata";
    $PREF{appdir_real}	= $PREF{DOCROOT} . $PREF{appdir_url};
    exit_with_error("$PREF{internal_appname_nice}'s appdata folder ('$PREF{appdir_url}') does not exist on your website; you must create it now, or else adjust the \$PREF{app_base_folder} setting.  This must be within your \$PREF{DOCROOT}, which is currently '$PREF{DOCROOT}'.") unless -d $PREF{appdir_real};

    unless ($PREF{skip_appdir_permissions_checks} =~ /yes/i) {
      my @all_dirs = ($PREF{appdir_real});
      push (@all_dirs, $PREF{appdir_real} . '/' . $_) for get_all_subdirs($PREF{appdir_real});
      foreach my $dir (@all_dirs) {
        exit_with_error("The '$dir' folder must be readable by this script (which usually means world-readable), but it isn't; you must adjust its permissions to make it so.") unless -r $dir;
        exit_with_error("The '$dir' folder must be writable by this script (which usually means world-writable), but it isn't; you must adjust its permissions to make it so.") unless -w $dir;
      }
    }
  }


sub figure_out_where_here_is
  {
    $PREF{here} ||= $ENV{SCRIPT_NAME};
    $PREF{here} = ($ENV{REQUEST_URI} =~ m!([^\?]+)!)[0] if $ENV{REQUEST_URI} && $PREF{here} eq 'auto';
    for ('here_static', 'here_login') {
      $PREF{$_} = $PREF{here} unless $PREF{$_}; # ($PREF{$_} && $PREF{$_} ne $ENV{SCRIPT_NAME});
      $PREF{$_} = $ENV{SCRIPT_NAME} unless $PREF{$_} =~ /./;

      $PREF{$_ . '_qsready'} = $PREF{$_} =~ /\?/ ? "$PREF{$_}&amp;" : "$PREF{$_}?";
    }
    $PREF{here_qsready} = $PREF{here} =~ /\?/ ? "$PREF{here}&amp;" : "$PREF{here}?";
    $PREF{login_url_qsready} = $PREF{login_url} =~ /\?/ ? "$PREF{login_url}&amp;" : "$PREF{login_url}?";
  }


sub do_blacklisting_and_whitelisting()
  {
    do_group_based_blacklisting_and_whitelisting();

    my $blocked = 0;

    my $ip_whitelisting_enabled = 0;
    my $user_matches_ip_whitelist = 0;
    foreach my $rule (sort keys %{$PREF{forced_whitelist_ip_addresses}}) {
      if (my $allowed_ip = $PREF{forced_whitelist_ip_addresses}{$rule}) {
        $ip_whitelisting_enabled = 1;
        $user_matches_ip_whitelist = 1 if $PREF{ip} =~ /$allowed_ip/;
      }
    }
    $blocked = 1 if $ip_whitelisting_enabled && !$user_matches_ip_whitelist;

    my $host_whitelisting_enabled = 0;
    my $user_matches_host_whitelist = 0;
    foreach my $rule (sort keys %{$PREF{forced_whitelist_hostnames}}) {
      if (my $allowed_host = $PREF{forced_whitelist_hostnames}{$rule}) {
        $host_whitelisting_enabled = 1;
        $user_matches_host_whitelist = 1 if $PREF{host} =~ /$allowed_host/i;
      }
    }
    $blocked = 1 if $host_whitelisting_enabled && !$user_matches_host_whitelist;

    foreach my $rule (sort keys %{$PREF{forced_blacklist_ip_addresses}}) {
      if (my $blocked_ip = $PREF{forced_blacklist_ip_addresses}{$rule}) {
        $blocked = 1 if $PREF{ip} =~ /$blocked_ip/;
      }
    }

    foreach my $rule (sort keys %{$PREF{forced_blacklist_hostnames}}) {
      if (my $blocked_host = $PREF{forced_blacklist_hostnames}{$rule}) {
        $blocked = 1 if $PREF{host} =~ /$blocked_host/;
      }
    }

    exit_with_error($TEXT{failed_black_or_white_list}) if $blocked;
  }


sub do_group_based_blacklisting_and_whitelisting()
  {
    foreach my $rule (sort keys %{$PREF{grouped_whitelist_ip_addresses}}) {
      if (my $allowed_ip = $PREF{grouped_whitelist_ip_addresses}{$rule}) {
        $PREF{user_is_encwhitelisted} = 1 if $PREF{ip} =~ /$allowed_ip/;
      }
    }

    foreach my $rule (sort keys %{$PREF{grouped_whitelist_hostnames}}) {
      if (my $allowed_host = $PREF{grouped_whitelist_hostnames}{$rule}) {
        $PREF{user_is_encwhitelisted} = 1 if $PREF{host} =~ /$allowed_host/i;
      }
    }

    foreach my $rule (sort keys %{$PREF{grouped_blacklist_ip_addresses}}) {
      if (my $blocked_ip = $PREF{grouped_blacklist_ip_addresses}{$rule}) {
        $PREF{user_is_encblacklisted} = 1 if $PREF{ip} =~ /$blocked_ip/;
      }
    }

    foreach my $rule (sort keys %{$PREF{grouped_blacklist_hostnames}}) {
      if (my $blocked_host = $PREF{grouped_blacklist_hostnames}{$rule}) {
        $PREF{user_is_encblacklisted} = 1 if $PREF{host} =~ /$blocked_host/;
      }
    }
  }


sub get_cookies()
  {
    my %cookies = fetch CGI::Cookie;
    return %cookies;
  }


sub get_cookie($)
  {
    my $which = shift;
    my %jar = get_cookies();
    my $value = '';

    if (exists $jar{$which}) {
      $value = $jar{$which}->value;
    } elsif ($which eq $PREF{site_session_cookie}) {
      if ($qs =~ /(?:^|&)ubsessioncode=(\w+)(?:&|$)/) {
        my $code = $1;

        # Accepting the session code from the URL should only be allowed as a last resort.
        # On decent servers this shouldn't be necessary because we can call UserBase
        # from PHP using virtual() and/or exec() both of which pass the cookies.  Even
        # on sub-par servers where we have to use include() with the full http:// URL,
        # we can reduce the security risk by requiring the remote IP to match the server
        # IP, i.e. ONLY allow the include(http://...) method to work: don't accept URL-
        # based session codes from any other IP.  As a last resort on totally sucky
        # servers where PHP is crippled and $ENV{SERVER_ADDR} DNE or is variable or
        # otherwise useless, proceed only by setting a PREF that indicates what a bad
        # idea it is.

        if ($PREF{ip} eq $ENV{SERVER_ADDR}) {
          $value = $code;
        } elsif ($PREF{my_server_sucks_so_use_less_secure_mode} =~ /yes/i) {
          sleep $PREF{sleeptime_for_less_secure_mode} || 3;
          $value = $code;
        }
      }
    }

    return $value;
  }


sub set_cookie($$$)
  {
    my $name = shift;
    my $value = shift;
    my $expiry = shift;
    my $cookie = undef;

    # The if/else for expiry is because setting "expires" to "" isn't
    # the same as not setting it.  Setting it to "" is the same as 
    # setting it to zero, which expires the cookie immediately
    # (i.e., deletes it).  But explicitly *not* setting the expiry
    # causes the cookie to persist until the end of the session.

    if ($PREF{cookie_domain}) {
      if ($expiry eq "") {
        $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/', -domain => $PREF{cookie_domain});
      } else {
        $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/', -domain => $PREF{cookie_domain}, -expires => $expiry);
      }
    } else {
      if ($expiry eq "") {
        $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/');
      } else {
        $cookie = new CGI::Cookie(-name => $name, -value => $value, -path => '/', -expires => $expiry);
      }
    }

    if ($PREF{output_started}) {
      print "<p>$PREF{internal_appname} warning: cannot set cookie '$name' => '$value' because the page output has already been started (perhaps debug is enabled?).</p>\n";
    } elsif ($PREF{we_are_virtual}) {
      print_http_headers();
      print "<p>$PREF{internal_appname} warning: cannot set cookie '$name' => '$value' because we are virtual.</p>\n";
    } else {
      print_p3p_header();
      print "Set-Cookie: $cookie\n";
    }
  }


sub determine_cookie_domain
  {
    if ($ENV{HTTP_HOST} =~ /\w+\.\w+/   &&   !is_ipv4_address($ENV{HTTP_HOST})   &&   !($PREF{never_specify_domain_when_setting_cookies} =~ /yes/i)) {
      # If we're running on a domain name, then specify it in our cookies.  This allows us
      # to put a dot at the start of the domain name, which causes the cookies to be set for
      # and accessible from the domain and all subdomains including www.  So we'll remove
      # any leading www first, as well as any port number.

      my $domain = $ENV{HTTP_HOST}; $domain =~ s!^www\.!!; $domain =~ s!:\d+$!!; $domain = ".$domain";
      $PREF{cookie_domain} = $domain;
    }
  }


sub get_qs_var
  {
    return enc_urldecode_return(   ($qs =~ /(?:^|&(?:amp;)?)$_[0]=([^&]*)/)[0]   );
  }


# APICHANGE: 201012: expand_custom_vars_in_prefs() no longer accepts a hashref,
# only an optional string.
#
sub expand_custom_vars_in_prefs
  {
    expand_custom_vars_in_prefs___inner(\%PREF, @_);
    expand_custom_vars_in_prefs___inner(\%TEXT, @_);
  }


sub expand_custom_vars_in_prefs___inner
  {
    my $hashref = shift;
    my $include_undefined = shift; $include_undefined = 0 unless $include_undefined eq 'include_undefined';

    # Execute this a few times without undefineds first, so that nested values can be
    # properly expanded (i.e. one setting contains %PREF{foo}, but $PREF{foo} itself
    # contains %PREF{bar}, etc).

    my $num_iterations = 5;
    for (my $i = 1; $i <= $num_iterations; $i++) {
      my $include_undefined_real = $include_undefined && $i == $num_iterations ? 1 : 0;

      foreach my $key (keys %$hashref) {
        if (ref($$hashref{$key}) eq 'HASH') # for prefs that are themselves hashes, i.e. $PREF{foo}{01} as in $PREF{foo}{01}{bar}.
          {
            expand_custom_vars_in_prefs___inner($$hashref{$key});
          } else {
				# from now on, use %%varname%% instead of $$varname$$, so that it doesn't
				# matter whether it gets put in double-quotes.

            next unless $$hashref{$key} && $$hashref{$key} =~ /(\$\$|%%|%PREF{|%TEXT{|%URL{|%COOKIE{|%SQL{|%ENV{|%DATE{)/;
            next if $PREF{"${key}___skip_init_var_expansion"} =~ /yes/i;

				# old way:
            $$hashref{$key} =~ s/\$\$server_name\$\$/$ENV{'SERVER_NAME'}/g;
            $$hashref{$key} =~ s/\$\$httphost_withport\$\$/$ENV{'HTTP_HOST'}/g;
            $$hashref{$key} =~ s/\$\$name_of_site\$\$/$$hashref{'name_of_site'}/g;

				# new way:
            $$hashref{$key} =~ s/%%server_name%%/$ENV{SERVER_NAME}/g;
            $$hashref{$key} =~ s/%%http_host%%/$ENV{HTTP_HOST}/g;
            $$hashref{$key} =~ s/%%name_of_site%%/$$hashref{name_of_site}/g;

				#interpolate_vars_from_URL_and_cookies($include_undefined, $$hashref{$key});
            do_standard_template_vars_processing($include_undefined, $$hashref{$key});
          }
      }
    }
  }


sub show_prefs
  {
    exit_with_needprivs() unless user_is_allowed_to('view_administration_page');
    $PREF{on_a_wide_page} = 1;
    start_html_output("Prefs");
    print qq`<div id="enc_prefs_list" class="enc_tbl">\n<table>\n<tr><th>Prefs</th></tr>\n`;
    my $oddeven = 1;
    my $allprefs = get_prefs('all');
    foreach my $pref (sort { lc($a) cmp lc($b) } keys %$allprefs) {
      print qq`<tr class="` . oddeven($oddeven) . qq`"><td><strong>$pref:</strong> $$allprefs{$pref}</td></tr>\n`;
    }
    print qq`</table>\n</div>\n`;
    finish_html_output();
  }


sub get_prefs
  {
    my $all = shift;
    my %prefs = ();
    foreach my $key (sort { lc($a) cmp lc($b) } keys %PREF) {
      #if($all   ||   ($key !~ /^(database_name|database_hostname|database_username|database_password|smtp_auth_username|smtp_auth_password)$/))
      #
      # It's not necessary to hide those sensitive values, since we're only
      # displaying all prefs in authenticated situations in the first place.
      #
      if (1) {
        my $value = $PREF{$key};
        $value =~ s!<!&lt;!g;
        $value =~ s!>!&gt;!g;
        $value =~ s!\n!\n<br />!g;
        $prefs{$key} = $value;
      }
    }
    return \%prefs;
  }


sub show_server_info
  {
    exit_with_needprivs() unless user_is_allowed_to('view_administration_page');

    start_html_output($TEXT{Server_Information});

    eval { require MIME::Lite; }; my $mimeliteversion = $@ ? qq`not installed` : $MIME::Lite::VERSION;

    my $old_cgi_text = $PREF{internal_appname} =~ /filechucker/i ? 'uploads' : 'some features';

    print	  qq`
		<div id="enc_server_info" class="enc_tbl">
		<table>
		<tr><th colspan="2">Server Information</th></tr>
		<tr><td>\$CGI::VERSION</td>		<td>$CGI::VERSION (if v3.02 or older, $old_cgi_text probably won't work, at least not reliably)</td></tr>
		<tr><td>\$] (Perl version)</td>		<td>$]</td></tr>
		<tr><td>\$MIME::Lite::VERSION</td>	<td>$mimeliteversion</td></tr>
		<tr><td>\$PREF{DOCROOT}</td>		<td>$PREF{DOCROOT}</td></tr>
		<tr><td colspan="2">Environment variables:</td></tr>
	`;

    foreach my $var (sort keys %ENV) {
      $ENV{$var} =~ s!<!&lt;!g;
      $ENV{$var} =~ s!>!&gt;!g;
      print qq`<tr><td>$var</td>	<td>$ENV{$var}</td></tr>\n`;
    }

    print	  qq`</table>\n</div>\n`;

    finish_html_output();
  }


sub store_keyed_message
  {
    my $new_message = shift;
    $new_message =~ s/\n/::ENCNL::/gs;

    my $one_day = 60*60*24*1;
    my $one_week = 60*60*24*7;
    my $current_time = offsettime();
    $PREF{max_age_for_keyed_messages} = $one_day unless $PREF{max_age_for_keyed_messages} =~ /^\d+/;

    my $key = md5_hex($new_message . $current_time . $$ . $ENV{REMOTE_PORT} . $PREF{ip} . $ENV{HTTP_USER_AGENT});
    my $uid = $PREF{logged_in_userid} =~ /^-?\d+$/ ? $PREF{logged_in_userid} : 0;

    my $mfile = add_initial_cwd_prefix($PREF{datadir} . '/' . "_$PREF{internal_appname}_keyed_messages.cgi");
    

    create_file_if_DNE($mfile,$PREF{writable_file_perms});
    my @messages = ();
    open(MFILE,"+<$mfile") or die_nice("could not open file '$mfile' for R/W: $!\n");
    flock MFILE, 2;
    seek MFILE, 0, 0;
    while (<MFILE>) {
      if (/^(\d+):/) {
        my ($time) = ($1);
        push (@messages,$_) if($time > ($current_time - $PREF{max_age_for_keyed_messages}));
      } elsif (/^[\s\n]*$/) {
        push (@messages, $_);
      }
    }
    seek MFILE, 0, 0;
    print MFILE @messages;
    print MFILE "${current_time}:${key}:${uid}:$PREF{ip}:$new_message\n\n\n"; # 3 newlines so the raw log is somewhat readable.
    truncate MFILE, tell MFILE;
    close MFILE or die_nice("could not close file '$mfile' after R/W: $!\n");

    return $key;
  }


sub get_keyed_message
  {
    my $key = shift;
    my $message = '';

    my $mfile = add_initial_cwd_prefix($PREF{datadir} . '/' . "_$PREF{internal_appname}_keyed_messages.cgi");
    create_file_if_DNE($mfile,$PREF{writable_file_perms});
    open(MFILE,"<$mfile") or die_nice("could not open file '$mfile' for reading: $!\n");
    flock MFILE, 1;
    seek MFILE, 0, 0;
    while (<MFILE>) {
      if (/^\d+:${key}:(-?\d+):([\d\.]+):(.*)/) {
        my ($uid_on_message,$ip_on_message,$msg) = ($1,$2,$3);
        if ($PREF{admin_is_logged_in}) {
          $message = $msg;
        } elsif ($PREF{member_is_logged_in} && $PREF{logged_in_userid} eq $uid_on_message) {
          $message = $msg;
        } elsif ($PREF{ip} eq $ip_on_message   &&   $uid_on_message =~ /^(0|-1)$/) # only allow IP-based auth if the owner is public.
          {
            $message = $msg;
          } else {
            $message = qq`Error: access denied based on userid and/or IP address.`;
          }
        last;
      }
    }
    close MFILE or die_nice("could not close file '$mfile' after reading: $!\n");

    $message =~ s/::ENCNL::/\n/gs;
    return $message || qq`Message expired.`;
  }


# Never call chdir directly; always call enc_chdir instead:
sub enc_chdir($)
  {
    my $dir = shift;
    $PREF{new_cwd} = $dir;
    chdir $dir or die_nice qq`Couldn't chdir to directory "$dir": $!\n`;
  }


# This is necessary for cases where we've chdir()ed somewhere other than the
# $PREF{initial_cwd}, after which we want to use $PREF{datadir}, which by
# default is not in DOCROOT and contains no path -- it's relative to the
# initial working directory.
#
sub add_initial_cwd_prefix($)
  {
    my $item = shift;
    if ($PREF{new_cwd} ne $PREF{initial_cwd}) {
      $item = $PREF{initial_cwd} . '/' . $item;
      condense_slashes('leave_leading_UNC', $item);
    }
    # return the input unchanged if we're still in the initial_cwd.
    return $item;
  }


# pass filename to create and optionally the mode to chmod it to.
# the mode must consist of 1-4 octal digits and must NOT be quoted.
# see "perldoc -f chmod" and "man chmod".
sub create_file_if_DNE
  {
    my $file = shift;
    my $mode = shift;

    return if -T $file;
    open(NEW,">$file") or die "$0: couldn't create new file $file: $!\n";
    close NEW or die "$0: couldn't close $file after creating it: $!\n";
    if ($mode) {
      chmod($mode,$file) or die "$0: couldn't chmod file \"$file\" with mode \"$mode\": $!\n";
    }
  }


sub create_dir_if_DNE
  {
    my $dir = shift;
    my $mode = shift;
    my $make_parents_if_necessary = shift; $make_parents_if_necessary = $make_parents_if_necessary eq 'make_parents';
    my $ignore_errors = shift; $ignore_errors = $ignore_errors eq 'ignore_errors';

    return if -d $dir;

    $dir =~ s!\\!/!g;
    if ($make_parents_if_necessary) {
      my $progressively_longer_path = '';
      my $i = 0;
      foreach my $individual_path_element (split(/\//, $dir)) {
        $i++;
        if ($i == 1) {
          if ($dir =~ m!^(\w:/)!) # Winders.
            {
              $progressively_longer_path = $1;
              next;
            } elsif (!$individual_path_element) # this means $dir starts with a slash.
              {
                $progressively_longer_path = '/';
                next;
              }
        }

        $progressively_longer_path .= $individual_path_element;
        unless(-d $progressively_longer_path)
          {
            mkdir($progressively_longer_path,$PREF{writable_dir_perms}) or $ignore_errors || die_nice("couldn't create path-portion '$progressively_longer_path' as part of dir '$dir': $!");
            if ($mode) {
              chmod($mode,$progressively_longer_path) or $ignore_errors || die_nice("couldn't chmod path-portion '$progressively_longer_path' as part of dir '$dir' with mode '$mode': $!");
            }
          }
        $progressively_longer_path .= '/';
      }
    } else {
      mkdir($dir,$PREF{writable_dir_perms}) or $ignore_errors || die_nice("couldn't create dir $dir: $!");
      if ($mode) {
        chmod($mode,$dir) or $ignore_errors || die_nice("couldn't chmod dir \"$dir\" with mode \"$mode\": $!");
      }
    }

    $ignore_errors || die_nice qq`dir does not exist after creation: '$dir'` unless -d $dir;
  }


sub mirror_dir_tree_and_contents($$)
  {
    my ($src,$dst) = @_;
    for (@_) {
      return(0, qq`error: does not exist: '$_'`) unless -e $_; return(0, qq`error: not a directory: '$_'`) unless -d $_;
    }
    my ($files, $subfolders) = get_items($src);

    my (@successes, @errors) = ();
    # start with the shortest pathname to ensure we create parents first.
    #
    foreach my $srcfolder (sort { length($a) <=> length($b) } @$subfolders) {
      my $mode = sprintf "%04o", (   (stat($srcfolder))[2] & 07777   );
      my $dstfolder = $dst . ($srcfolder =~ /^$src(.+)/)[0];
      if (mkdir($dstfolder, oct($mode))) {
        if (chmod(oct($mode), $dstfolder)) {
          push @successes, $dstfolder;
          copy_custom_folder_perms($srcfolder, $dstfolder) if $PREF{internal_appname} eq 'filechucker' && custom_folder_perms_enabled() && $PREF{when_copying_a_folder_also_copy_its_cust_perms} =~ /yes/i;
        } else {
          push @errors, qq`Couldn't chmod dir '$dstfolder' with mode '$mode': $!`;
        }
      } else {
        push @errors, qq`Couldn't mkdir '$dstfolder' with mode '$mode': $!`;
      }
    }

    foreach my $srcfile (@$files) {
      my $mode = sprintf "%04o", (   (stat($srcfile))[2] & 07777   );
      my $dstfile = $dst . ($srcfile =~ /^$src(.+)/)[0];
      if (copy($srcfile, $dstfile)) {
        if (chmod(oct($mode), $dstfile)) {
          push @successes, $dstfile;
        } else {
          push @errors, qq`Couldn't chmod file '$dstfile' with mode '$mode': $!`;
        }
      } else {
        push @errors, qq`Couldn't copy source file '$srcfile' to destination file '$dstfile': $!`;
      }
    }
	
    copy_custom_folder_perms($src, $dst) if $PREF{internal_appname} eq 'filechucker' && custom_folder_perms_enabled() && $PREF{when_copying_a_folder_also_copy_its_cust_perms} =~ /yes/i;

    return (\@successes, \@errors);
  }


# Note: we use "die" rather than "die_nice" throughout the send_email function,
# because most of the code is within eval{} blocks, so that we can catch the
# dies and then decide at the end what to do with them.
#
sub send_email
  {
    my ($to, $from, $subj, $msg, $mimetype, $die_on_error, $attachment_hashref, $dont_fork) = @_;
    $mimetype = $mimetype =~ /html/i ? 'text/html' : 'text/plain';

    $die_on_error = $die_on_error eq 'die_on_email_error' ? 1 : 0;
    $dont_fork = $dont_fork eq 'dont_fork' ? 1 : 0;
    my $do_fork = !$die_on_error; # if we want to die on error, we can't fork, or the die() will go unreported.
    $do_fork = 0 if $^O =~ /MSWin32/; # Windows' fork-fu is weak.
    $do_fork = 0 if $dont_fork;

    my ($mail_sent_successfully, $error_msg) = 0;

    # fork here because sending mail can be slow (and can block) sometimes.
    # Note: if we don't set $do_fork, perl won't even evaluate the &&'s second
    # half, so the fork won't happen, and the else{} will.
    my $forkpid = ();
    if ($do_fork   &&   ($forkpid = fork)) {
      # parent
    } else {
      # child

      use POSIX;

      if ($do_fork) {
        defined $forkpid or die_nice "$PREF{internal_appname}: fork error in send_email(): $@\n";

        POSIX::setsid() unless $^O =~ /MSWin32/;
        close STDOUT;
        close STDIN;
      }

      my @enc_headers = ();
      unless ($PREF{include_encodable_email_headers} =~ /no/i) {
        my $sentdate = strftime("%a%b%d,%Y,%I:%M%p",localtime(time + $PREF{time_offset}));
        push @enc_headers, qq`X-Originator-IP: $PREF{ip}`;
        push @enc_headers, qq`X-Originator-Host: $PREF{host}`;
        push @enc_headers, qq`X-Originator-UA: $ENV{HTTP_USER_AGENT}`;
        push @enc_headers, qq`X-Encodable-Sitename: $ENV{HTTP_HOST}`;
        push @enc_headers, qq`X-Encodable-Header: website-visitor`;
        push @enc_headers, qq`X-Encodable-Sent: $sentdate`;
      }

      my $msgid = '<' . time . '.' . md5_hex($to . $from . $subj . $msg . $$ . $ENV{REMOTE_PORT}) . '@' . $ENV{HTTP_HOST} . '>';

      my $smtp_error = '';
      if ($PREF{smtp_server}) {
        # Wrap this in an eval{} in case MIME::Lite is missing.
        # Then we can have the option of setting $PREF{'disable_all_email'}
        # so that the site still functions, sans email.
        eval
          {
            require MIME::Lite;

            my $type = ();
            if ($mimetype) {
              $type = $mimetype;
            } else {
              #my $type = $attachment_hashref ? 'multipart/mixed' : 'text/plain';
              $type = $attachment_hashref ? 'multipart/mixed' : 'text/plain; charset=ISO-8859-1; format=flowed';
            }

            my $mime_msg = MIME::Lite->new(To => $to, From => $from, Subject => $subj, Type => $type, Data => $msg);
            die "$PREF{internal_appname}: error creating MIME body: $!\n" unless($mime_msg);

            if ($PREF{generate_message_id_internally} =~ /yes/i) {
              $mime_msg->add('Message-ID' => $msgid);
            }

            for (@enc_headers) {
              my ($name, $value) = split(/: /);
              $mime_msg->add($name => $value);
            }

            if ($attachment_hashref) {
              foreach my $key (keys %$attachment_hashref) {
                my $mimetype			= $$attachment_hashref{$key}{mimetype}; # like 'application/x-gzip'
                my $filename			= $$attachment_hashref{$key}{filename};
                my $recommended_filename	= $$attachment_hashref{$key}{recommended_filename};

                $recommended_filename =~ s!^.*(\\|/)!!; # strip off any preceeding path

                # Attach the test file
                $mime_msg->attach(
                  Type => $mimetype,
                  Path => $filename,
                  Filename => $recommended_filename,
                  Disposition => 'attachment'
                ) or die "$PREF{internal_appname}: error attaching file to email: $!\n";
              }
            }


            $PREF{smtp_server} = enc_untaint($PREF{smtp_server});
            if ($PREF{smtp_auth_username} =~ /\S/ && $PREF{smtp_auth_password} =~ /\S/) {
              eval { MIME::Lite->send('smtp', $PREF{smtp_server}, Timeout=>30, AuthUser=>$PREF{smtp_auth_username}, AuthPass=>$PREF{smtp_auth_password}, Port=>$PREF{smtp_port}); };
            } else {
              eval { MIME::Lite->send('smtp', $PREF{smtp_server}, Timeout=>30, Port=>$PREF{smtp_port}); };
            }
            die "$PREF{internal_appname}: MIME::Lite->send failed: $@\n" if $@;

            eval { $mime_msg->send; };
            if ($@) {
              die "$PREF{internal_appname}: \$mime_msg->send failed: $@\n";
            } else {
              $mail_sent_successfully = 1;
            }


            if ($attachment_hashref) {
              foreach my $key (keys %$attachment_hashref) {
                unlink(  $$attachment_hashref{$key}{filename}  )   if   $$attachment_hashref{$key}{'delete-after-sending'} eq 'yes';
              }
            }
          };

        $smtp_error = $@;
      }

      my $sendmail_error = '';
      if ($PREF{path_to_sendmail}   &&   !$mail_sent_successfully) {
        if ($smtp_error) {
          enc_warn "$PREF{internal_appname}: send_email(): SMTP failed, so falling back to sendmail.  SMTP error was: $smtp_error\n";
        }

        eval
          {
            $PREF{path_to_sendmail} = enc_untaint($PREF{path_to_sendmail}, 'keep_path');

            open(SENDMAIL, "|$PREF{path_to_sendmail} -oi -t") or die "$PREF{internal_appname}: Can't fork for sendmail: $!\n";

            if ($attachment_hashref) {
              print SENDMAIL	  qq`MIME-Version: 1.0`
                . qq`\nFrom: $from`
                  . qq`\nTo: $to`
                    . qq`\nSubject: $subj`
                      . ($PREF{generate_message_id_internally} =~ /yes/i ? "\nMessage-Id: $msgid" : '')
                        . (@enc_headers ? "\n" . (join "\n", @enc_headers) : '')
                          . qq`\nContent-Type: multipart/mixed; boundary=encindboundarystring`
                            . qq`\n`
                              . qq`\n--encindboundarystring`
                                . qq`\nContent-Type: ` . ($mimetype ? $mimetype : 'text/plain')
                                  . qq`\n`
                                    . qq`\n$msg`;

              foreach my $key (keys %$attachment_hashref) {
                my $mimetype			= $$attachment_hashref{$key}{mimetype}; # like 'application/x-gzip'
                $mimetype			= 'application/octet-stream' unless $mimetype;
                my $filename			= $$attachment_hashref{$key}{filename};
                my $recommended_filename	= $$attachment_hashref{$key}{recommended_filename};

                $recommended_filename =~ s!^.*(\\|/)!!; # strip off any preceeding path

                my $atch = `uuencode $filename $filename`; # UUencode it so we can send it as an attachment

                print SENDMAIL	  qq`\n____________________`
                  . qq`\nAttachment: $filename:`
                    . qq`\n`
                      . qq`\n--encindboundarystring`
                        . qq`\nContent-Type: $mimetype; name="$filename"`
                          . qq`\nContent-Transfer-Encoding: x-uuencode`
                            . qq`\nContent-Disposition: attachment; filename="$recommended_filename"`
                              . qq`\n`
                                . qq`\n$atch`
                                  . qq`\n`
                                    . qq`\n--encindboundarystring`;
              }

              print SENDMAIL	  qq`\n--encindboundarystring--\n`
            } else              # no attachment.
              {
                print SENDMAIL	  qq`From: $from`
                  . qq`\nTo: $to`
                    . qq`\nSubject: $subj`
                      . ($PREF{generate_message_id_internally} =~ /yes/i ? "\nMessage-Id: $msgid" : '')
                        . (@enc_headers ? "\n" . (join "\n", @enc_headers) : '')
                          . qq`\nContent-Type: $mimetype`
                            . qq`\n`
                              . qq`\n$msg`;
              }

            close(SENDMAIL) or $PREF{die_on_sendmail_close_error} =~ /yes/i
              ? die		"$PREF{internal_appname}: sendmail didn't close nicely: $!\n"
                : warn		"$PREF{internal_appname}: sendmail didn't close nicely: $!\n";
          };

        if ($@) {
          $sendmail_error = $@;
        } else {
          $mail_sent_successfully = 1;
        }
      }

      my $blat_error = '';
      if ($PREF{path_to_blat}   &&   $PREF{smtp_server}   &&   !$mail_sent_successfully) {
        printd "in blat loop...\n";
        if ($sendmail_error) {
          enc_warn "$PREF{internal_appname}: send_email(): sendmail failed, so trying blat.  sendmail error was: $sendmail_error\n";
        }

        my $blat_output = '';
        eval
          {
				#$PREF{path_to_blat} = enc_untaint($PREF{path_to_blat}, 'keep_path');

            my $subj_for_blat = $subj;
            my $msg_for_blat = $msg;
            s!"!\\"!gs for ($subj_for_blat, $msg_for_blat);

            my $u	= "-u $PREF{smtp_auth_username}"	if $PREF{smtp_auth_username};
            my $pw	= "-pw $PREF{smtp_auth_password}"	if $PREF{smtp_auth_password};

            my ($debug,$x) = ('','');
				#$debug = "-debug";
				#$x = qq`-x "X-Custom-header: some header value..."`;

            $blat_output = `$PREF{path_to_blat} - -to $to -f $from -subject "$subj_for_blat" -body "$msg_for_blat" -server $PREF{smtp_server}:$PREF{smtp_port} $u $pw $debug $x`;

            printd "blat output: $blat_output\n";
          };

        if ($@ || !$blat_output) {
          $blat_error = "Blat error: '$@'.  Blat output was: '$blat_output'";
        } else {
          $mail_sent_successfully = 1;
        }
      }

      unless($mail_sent_successfully)
        {
          if ($smtp_error) {
            $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email() while trying to use MIME::Lite with SMTP server '$PREF{smtp_server}'. Error was: '$smtp_error' <br /><br />\n\n";
          }
          if ($sendmail_error) {
            $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email() while trying to use sendmail with path '$PREF{path_to_sendmail}'. Error was: '$sendmail_error' <br /><br />\n\n";
          }
          if ($blat_error) {
            $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email() while trying to use blat with path '$PREF{path_to_blat}'. Error was: '$blat_error' <br /><br />\n\n";
          }

          if (!$error_msg) {
            $error_msg .= "$PREF{internal_appname}: couldn't send email: error in send_email(): perhaps you need to adjust \$PREF{smtp_server} (currently '$PREF{smtp_server}') or \$PREF{path_to_sendmail} (currently '$PREF{path_to_sendmail}'). <br /><br />\n\n";
          }

          $error_msg .= qq` [[ message details: to='$to', from='$from', subject='$subj' ]] <br /><br />\n\n`;

          if ($die_on_error) {
            die_nice	$error_msg;
          } else {
            warn		$error_msg;
          }
        }

      if ($do_fork) {
        exit;                   # exit the child process.
      }
    }

    return ($mail_sent_successfully, $error_msg);
  }


sub enc_untaint
  {
    my $item = shift || '';
    my $original_item = $item;
    my $keep_path = shift || '';
    #printd "enc_untaint($item)\n";

    # Regardless of whether we're keeping the path, dots surrounded by slashes are never allowed.
    #
    #$item =~ s!(^|/|\\)\.+(/|\\|$)!$1!g;
    $item =~ s!\\!/!g; # Need to remove MS garbage beforehand, otherwise an input like .\\StupidCGI.tmp will break this.
    while ($item =~ m!((?:^|/|\\)\.+(?:/|\\|$))!) {
      $item =~ s!$1!/!;
    }

    #printd "removed slashdots: $item\n";

    if (  $item =~ m!(/|\\)!  &&  !$keep_path) {
      $item =~ s!^.*[/\\]+([^/\\]+)!$1!; # remove any path from the front.
      #printd "removed path from front: $item\n";
      $item =~ s!^([^/\\]+)[/\\]+!$1!; # ...and the back.
    }

    $item =~ s![`\*\?\|<>]!!g; # remove some other potentially-unsafe stuff.

    my $leading_UNC_slashes = '';
    if ($item =~ m!^//!  &&  $keep_path) {
      $leading_UNC_slashes = '//';
      $item =~ s!^/+!!;
    }
    $item =~ s![/\\]{2,}!/!g;   # condense any multiples.
    $item = $leading_UNC_slashes . $item; # add back any UNC slashes.

    ($item) = ($item =~ /(.*)/); # untaint.

    # In case anything slips through, die as a security precaution.
    #
    die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m![/\\]! && !$keep_path;
    die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!(?:^|/|\\)\.+(?:/|\\|$)!;
    die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!^\.+$!;
    die qq`$0: couldn't untaint "$original_item" [called from: ` . (caller 1)[3]  . qq`].\n` if $item =~ m!^\s*$!;

    #printd "untainted: $item\n\n";
    return $item;
  }


sub zeropad
  {
    # args: 1. string to pad, 2. length to pad to (i.e. final length).
    enc_pad(@_, 0);
  }


sub enc_pad
  {
    # args: 1. string to pad, 2. length to pad to (i.e. final length), 3. char to use for padding.
    $_[0] = ($_[2] x $_[1]) . $_[0];
    $_[0] =~ s!.*(.{$_[1]})!$1!;
  }


sub enc_urlencode
  {
    for (@_) {
      s/([^\w()'*~!.-])/sprintf '%%%02x', ord $1/eg if $_;
    }
    ;
  }


sub enc_urldecode
  {
    # assuming the input really was URL-encoded, then any plus-signs that were originally there
    # are now in their hex form, so any plus-signs STILL there were converted from spaces by the
    # browser.  so they must be converted back BEFORE restoring any original plus-signs from the
    # hex codes.
    convert_plus_signs_back_to_spaces_in_var_from_GET_method(@_);
    for (@_) {
      s/%([a-fA-F\d]{2})/chr hex $1/eg  if $_;
    }
  }


sub zeropad_return { my $string = shift; zeropad($string, @_); return $string; }
sub enc_pad_return { my $string = shift; enc_pad($string, @_); return $string; }
sub enc_urlencode_return { my $string = shift; enc_urlencode($string); return $string; }
sub enc_urldecode_return { my $string = shift; enc_urldecode($string); return $string; }


sub convert_plus_signs_back_to_spaces_in_var_from_GET_method
  {
    for (@_) {
      s/\+/ /g  if $_;
    }
  }


sub enc_redirect
  {
    my $destination = shift;

    if ($destination =~ /^referr?er$/i) {
      $destination = $ENV{HTTP_REFERER} ? $ENV{HTTP_REFERER} : $PREF{redirection_backup_address};
    }

    unless($destination =~ m!^https?://!)
      {
        $destination = $PREF{protoprefix} . $ENV{HTTP_HOST} . $destination;
      }

    my $destination_raw = $destination;
    $destination_raw =~ s!&amp;!&!g;

    if ($PREF{output_started}) {
      if ($PREF{use_javascript_redirect_when_necessary} !~ /no/i) {
        print qq`\n<script type="text/javascript">location.href="$destination_raw";</script>\n`;
      } else {
        print qq`<p>$PREF{internal_appname} warning: cannot redirect because output has already started (perhaps debug is enabled?).&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
      }
    } elsif ($PREF{we_are_virtual}) {
      if ($PREF{use_javascript_redirect_when_necessary} !~ /no/i) {
        print_http_headers();
        print qq`\n<script type="text/javascript">location.href="$destination_raw";</script>\n`;
      } else {
        enc_warn "$0: enc_redirect(): cannot redirect because we are virtual.\n";
        print_http_headers();
        print qq`<p>$PREF{internal_appname} warning: cannot redirect because we are virtual.&nbsp; <a href="$destination">Click here to continue</a>.</p>\n`;
      }
    } else {
      if ($ENV{SERVER_SOFTWARE} =~ /microsoft-iis/i || $PREF{always_use_meta_for_redirects} =~ /yes/i) {
        # A bug in IIS v5 (and lower, probably) makes cookie-setting fail
        # when combined with a header-based redirect:
        #
        #	"BUG: Set-Cookie Is Ignored in CGI When Combined With Location"
        #	http://support.microsoft.com/kb/q176113/
        #
        # So use a meta-redirect instead.
        #
        print "Content-type: text/html\n\n";
        print qq`<html><head><meta http-equiv="refresh" content="0;url=$destination"></head><body></body></html>\n`;
      } else {
        print "Location: $destination_raw\n\n";
      }
    }

    exit;
  }


sub kmsg_redirect
  {
    # Any $PREF{extra_debug} will be lost on redirect unless we store it with the keyed message.
    enc_redirect(   ($PREF{here_static} || $PREF{here}) . "?kmsg=" . store_keyed_message($_[0] . get_extra_debug_output()) . $PREF{default_url_vars}   );
  }


sub smsg_redirect
  {
    # smsg: static message.  This only needs to be used in situations where we were
    # POSTed to and we want the static message to appear within the page we're
    # embedded into; for non-POST situations we can just use exit_with_error().
    # (And we could use a kmsg instead here, but that does involve some amount
    # of overhead, so for static messages we might as well avoid it.)
    #
    enc_redirect(   ($PREF{here_static} || $PREF{here}) . "?smsg=$_[0]" . $PREF{default_url_vars}   );
  }


sub enc_redirect_to_ref
  {
    # try to redirect to HTTP_REFERER, falling back to the URL
    # specified by ?whence=foo, then to any passed-in URL, and
    # finally to $PREF{here}.

    my $go = shift;
    if ($ENV{HTTP_REFERER}) {
      $go = $ENV{HTTP_REFERER};
    } elsif ($qs =~ /(?:^|&)whence=(.+)/) {
      $go = $1;
      enc_urldecode($go);
    }
    $go = $PREF{here} if !$go;
    enc_redirect($go);
  }


sub get_extra_debug_output
  {
    if (	$PREF{extra_debug_always}
                  ||
                    user_is_allowed_to('view_extra_debug_output')
                      ||
                        ($PREF{extra_debug_usernames_list} && $PREF{logged_in_username} &&   ($PREF{extra_debug_usernames_list} =~ /(^|,)\s*$PREF{logged_in_username}\s*(,|$)/))
                          ||
                            ($PREF{extra_debug_ips_list} &&   ($PREF{extra_debug_ips_list} =~ /(^|,)\s*$PREF{ip}\s*(,|$)/))
                          ) {
      my $style = $PREF{extra_debug_css} || qq`margin: 20px; padding: 10px; border: 1px solid #999; background: #ddd; color: #333; text-align: left;`;
      $PREF{extra_debug} =~ s/</&lt;/g;
      $PREF{extra_debug} =~ s/>/&gt;/g;
      $PREF{extra_debug} =~ s!\n! <br />\n!g;
      my $extra_debug = qq`<div style="$style">$PREF{extra_debug}</div>\n` unless !$PREF{extra_debug} && $PREF{hide_extra_debug_container_if_empty} =~ /yes/i;
      my $extra_debug_raw = qq`<div style="$style">$PREF{extra_debug_raw}</div>\n` if $PREF{extra_debug_raw};
      return qq`$extra_debug\n$extra_debug_raw`;
    }
  }


sub encdebug { $PREF{extra_debug} .= time . ": elapsed time " . (time - $PREF{app_start_time}) . " sec: " . (caller 1)[3] . ": " . join("\n",@_) . "\n"; }


sub condense_slashes
  {
    s!\\!/!g;
    my $leave_leading_UNC = 0;
    for (@_) {
      if (/^leave_leading_UNC$/) {
        $leave_leading_UNC = 1;
        next;
      }
      if ($leave_leading_UNC) {
        my $leading_UNC_slashes = '';
        if (m!^//!) {
          $leading_UNC_slashes = '//';
          s!^/+!!;
        }
        s!/{2,}!/!g;            # condense any multiples.
        $_ = $leading_UNC_slashes . $_; # add back any UNC slashes.
      } else {
        s!/{2,}!/!g;
      }
    }
  }


sub slashify	{   fooify('/', @_); }
sub deslashify	{ defooify('/', @_); }
sub commaify	{   fooify(',', @_); }
sub decommaify	{ defooify(',', @_); }
sub spaceify	{   fooify(' ', @_); }
sub despaceify	{ defooify(' ', @_); }


sub fooify
  {
    # add leading and trailing foos and condense duplicates.
    my $foo = shift;
    $_ = $foo . $_ . $foo for @_;
    s!$foo{2,}!$foo!g for @_;
  }


sub defooify
  {
    # remove leading and trailing foos and condense duplicates.
    my $foo = shift;
    s!$foo{2,}!$foo!g for @_;
    s!^$foo!!g for @_;
    s!$foo$!!g for @_;
  }


sub die_unless_numeric
  {
    die_nice("error: non-numeric value '$_[0]' for $_[1]. [called from: " . (caller 1)[3]  . "]\n") unless $_[0] =~ /^\d+$/;
  }


sub die_nice
  {
    my $msg = shift;
    my $caller = (caller 1)[3];
    $caller =~ s/^main:://;
    $msg = qq`$PREF{internal_appname_nice}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
    exit_with_error($msg);
  }


sub enc_warn
  {
    # Never call the built-in warn() function directly, because some (lame) servers (IIS) choke
    # on it (and on printing to STDERR), and in bad ways, such as prompting the user to download
    # a file (the script output with the error message) rather than just displaying an error.
    #
    return if $^O =~ /MSWin/i;

    my $msg = shift;
    my $caller = (caller 1)[3];
    $caller =~ s/^main:://;
    $msg = qq`$PREF{internal_appname_nice}: $caller(): $msg` unless $msg =~ /^$PREF{internal_appname}: $caller(): /;
    warn $msg;
  }


sub print_http_headers
  {
    return if $PREF{output_started} || $PREF{xml_output_started};

    $PREF{output_started} = 1;

    # Don't print the P3P header from here normally, because we'll pick it up automatically
    # from the site's main .htaccess file.  The only time a script needs to explicitly
    # include it is when setting cookies (and possibly when delivering JS code which is
    # used to set cookies?).
    # 
    #print_p3p_header();

    my $noprint = shift;
    my $headers = '';
    $headers .= "Cache-Control: no-store, no-cache\n";
    $headers .= "Connection: close\n"; # workaround for a Safari bug that causes uploads to fail about 50% of the time.
    $headers .= "Content-type: text/html\n\n";
    $noprint ? return $headers : print $headers;
  }


  sub print_xml_headers()
  {
    return if $PREF{output_started} || $PREF{xml_output_started};
    $PREF{xml_output_started} = 1;

    print "Cache-Control: no-store, no-cache\n";
    print "Content-type: text/xml\n";
    print "Connection: close\n"; # workaround for a Safari bug that causes uploads to fail about 50% of the time.
    print "\n";
  }


sub print_p3p_header
  {
    # If you need to set third-party cookies, you'll need to use the P3P
    # privacy policy system, or else IE will reject the cookies.  The system
    # consists of a /w3c folder on your website containing a p3p.xml file
    # and a policy.html file, and then having your server send a P3P header,
    # both in the main .htaccess file and anytime a script needs to output
    # headers.  The value should be something like this:
    #
    #	$PREF{p3p_header} = qq`P3P: CP="ALL DSP COR NID", policyref="/w3c/p3p.xml"`;
    #
    # Or, you can leave off the policyref:
    #
    #	$PREF{p3p_header} = qq`P3P: CP="ALL DSP COR NID"`;
    #
    # You may want to use a service like http://p3pedit.com/ to create your
    # XML and privacy files.  And you can use www.w3.org/P3P/validator.html
    # to validate your setup.

    return if $PREF{p3p_header_printed};

    $PREF{p3p_header_printed} = 1;
    my $noprint = shift;
    my $headers = '';
    $headers .= "$PREF{p3p_header}\n" if $PREF{p3p_header};
    $noprint ? return $headers : print $headers;
  }


  sub offsettime	{ return time + $PREF{time_offset}; }
sub date17	{ return strftime("%Y%m%d-%H:%M:%S", localtime(shift || offsettime())); }


sub offset_etime($$)
  {
    my ($etime, $offset) = @_;
    my ($operation, $amount, $multiplier_code) = ($offset =~ /([\+-])(\d+)([smhdb])/);
    my $multiplier = $multiplier_code eq 'm' ? 60 : $multiplier_code eq 'h' ? 3600 : $multiplier_code eq 'd' ? 86400 : 1;
    if ($multiplier_code eq 'b') {
      while ($amount) {
        do { $etime = $operation eq '+' ? $etime + 86400 : $etime - 86400; } while is_weekend($etime);
        $amount--;
      }
    } else {
      $etime = $operation eq '+' ? $etime + ($amount * $multiplier) : $etime - ($amount * $multiplier);
    }
    return $etime;
  }


sub is_weekend($)
  {
    return (localtime($_[0]))[6] =~ /[06]/; # (localtime($etime))[6] is the weekday, with 0 being Sunday and 6 being Saturday.
  }


sub sql_untaint
  {
    s/"/&quot;/g for @_;
    s/'/&#39;/g for @_;
    s/`/&#96;/g for @_;
    s/\\/&#92;/g for @_;
  }


sub sql_un_untaint
  {
    s/&quot;/"/g for @_;
    s/&#39;/'/g for @_;
    s/&#96;/`/g for @_;
    s/&#92;/\\/g for @_;
  }


sub enc_hash
  {
    return $PREF{use_md5_for_hashes} =~ /yes/i ? md5_hex(@_) : sha1_hex(@_);
  }


sub not_sqlsafe
  {
    #print STDERR "not_sqlsafe: got: $_[0]\n";

    # Escape any dashes or closing brackets, as per perlre:
    #
    # 	If you want either "-" or "]" itself to be a member of a class,
    #	put it at the start of the list (possibly after a "^"), or escape
    #	it with a backslash.
    #
    my $list_of_sql_safe_characters = $PREF{list_of_sql_safe_characters};
    $list_of_sql_safe_characters =~ s/\]/\\]/g;
    $list_of_sql_safe_characters =~ s/-/\\-/g;

    return $_[0] =~ /[^$list_of_sql_safe_characters]/;
  }


sub die_unless_sqlsafe
  {
    #print STDERR "die_unless_sqlsafe: got: $_[0]\n";

    # Escape any dashes or closing brackets, as per perlre:
    #
    # 	If you want either "-" or "]" itself to be a member of a class,
    #	put it at the start of the list (possibly after a "^"), or escape
    #	it with a backslash.
    #
    my $list_of_sql_safe_characters = $PREF{list_of_sql_safe_characters};
    $list_of_sql_safe_characters =~ s/\]/\\]/g;
    $list_of_sql_safe_characters =~ s/-/\\-/g;

    for (@_) {
      if (/[^$list_of_sql_safe_characters]/) {
        exit_with_error(qq`Not SQL-safe: called from ` . (caller 1)[3] . qq`: the following value is not SQL-safe: $_`);
      }
    }
  }


sub replace_nonsqlsafe_chars_with
  {
    my $replacement = shift;

    # Escape any dashes or closing brackets, as per perlre:
    #
    # 	If you want either "-" or "]" itself to be a member of a class,
    #	put it at the start of the list (possibly after a "^"), or escape
    #	it with a backslash.
    #
    my $list_of_sql_safe_characters = $PREF{list_of_sql_safe_characters};
    $list_of_sql_safe_characters =~ s/\]/\\]/g;
    $list_of_sql_safe_characters =~ s/-/\\-/g;

    for (@_) {
      if (/[^$list_of_sql_safe_characters]/) {
        enc_warn "sanitizing the following non-SQL-safe value: $_\n";
        s/[^$list_of_sql_safe_characters]/$replacement/g;
      }
    }
  }


sub oddeven
  {
    $_[0] = 0 unless $_[0] && $_[0] =~ /^\d+$/;
    $_[0]++ unless $_[1] eq 'dont_inc';
    return $_[1] && $_[1] eq 'reset' ? 'odd' : $_[0] % 2 == 0 ? 'even' : 'odd';
  }


sub enc_sql_select($)
  {
    verify_db_connection();
    my $statement = shift;
    my $sth = $PREF{dbh}->prepare($statement);
    $sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL select statement [[$statement]]: $DBI::errstr\n");
    return $sth->fetchrow;
  }


sub enc_sql_select_multi($)
  {
    verify_db_connection();
    my $statement = shift;
    my $sth = $PREF{dbh}->prepare($statement);
    $sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL select statement [[$statement]]: $DBI::errstr\n");
    my $i = 1;
    my %hash = ();
    my $rowhashref = '';
    while ($rowhashref = $sth->fetchrow_hashref) {
      foreach my $field (keys %$rowhashref) {
        $hash{$i}{$field} = $$rowhashref{$field};
      }
      $i++;
    }
    return \%hash;
  }


sub enc_sql_select_array
  {
    my $statement = shift;
    my $sth = $PREF{dbh}->prepare($statement);
    $sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL select statement [[$statement]]: $DBI::errstr\n");
    my @results = ();
    while (my $ref = $sth->fetchrow_arrayref()) {
      push @results, @{$ref};
    }
    return @results;
  }


sub enc_sql_update($)
  {
    verify_db_connection();
    my $statement = shift;
    my $sth = $PREF{dbh}->prepare($statement);
    my $numrows = $sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL update statement [[$statement]]: $DBI::errstr\n");
    return $numrows;
  }


sub enc_sql_insert($)
  {
    verify_db_connection();
    my $statement = shift;
    my $sth = $PREF{dbh}->prepare($statement);
    $sth->execute() or die_nice("called from " . (caller 1)[3]  . ": error while executing SQL insert statement: $DBI::errstr.  Statement was: [[ $statement ]]\n");
  }


sub enc_sql_delete($)
  {
    verify_db_connection();
    my $statement = shift;
    my $sth = $PREF{dbh}->prepare($statement);
    my $retval = $sth->execute();
    die_nice("called from " . (caller 1)[3]  . ": error while executing SQL delete statement: $DBI::errstr.  Statement was: [[ $statement ]]\n") if $retval =~ /^(0|0E0)$/; # execute() returns '0E0' if no rows were affected by the statement.
  }


sub enc_sys_call
  {
    # TODO: this doesn't always work.

    my $cmd = shift;
    my ($msg,$success) = ();

    if (my $timeout = $PREF{sys_call_timeout}) {
      eval
        {

          local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
          alarm $timeout;

          # Note: don't change this without changing the matching block below.
          system($cmd);
          if ($? == -1) {
            $success = 0; $msg = "error: failed to execute: $!";
          } elsif ($? & 127) {
            $success = 0; $msg = sprintf "error: child died with signal %d, %s coredump", ($? & 127),  ($? & 128) ? 'with' : 'without';
          } else {
            $success = 1; $msg = sprintf "child exited with value %d", $? >> 8;
          }

        };

      if ($@) {
        if ($@ eq "alarm\n") {
				# timed out.
          $success = 0; $msg = "error: timeout while executing: $!";
        } else {
				# propagate unexpected errors.
          $success = 0; $msg = "unexpected error while executing: $@";
        }
      } else {
        # didn't time out.
      }
    } else {
      # Note: don't change this without changing the matching block above.
      system($cmd);
      if ($? == -1) {
        $success = 0; $msg = "error: failed to execute: $!";
      } elsif ($? & 127) {
        $success = 0; $msg = sprintf "error: child died with signal %d, %s coredump", ($? & 127),  ($? & 128) ? 'with' : 'without';
      } else {
        $success = 1; $msg = sprintf "child exited with value %d", $? >> 8;
      }
    }

    $msg = "enc_sys_call(): command was [[ $cmd ]]; result was [[ $msg ]];";
    printd "$msg\n";

    $PREF{sys_call_timeout} = 0; # always reset this so it's disabled by default, and the caller can choose to set it before calling us if necessary.
    return ($success, $msg);
  }


sub exit_with_success { exit_with___generic($PREF{success_message_template}, @_); } # Success messages that the end-user is supposed to see.
sub exit_with_notice { exit_with___generic($PREF{notice_message_template}, @_); } # Non-error messages that the end-user is supposed to see.
sub exit_with_error { exit_with___generic($PREF{error_message_template}, @_); } # Errors that the end-user is supposed to see.
sub exit_with_output { exit_with___generic('', @_); } # For any output; no template will be used.


sub exit_with___generic
  {

    my $template = shift;
    my $message = join '', @_;
    #print STDERR $message;
    $template =~ s/%%message%%/$message/g;
    $message = $template =~ /\Q$message\E/ ? $template : $message; # in case prefs haven't been loaded yet.
    if (!$PREF{we_are_virtual} && $PREF{here} ne $ENV{SCRIPT_NAME} && $ENV{REQUEST_METHOD} =~ /post/i) {
      # 20081213: added method=post requirement; otherwise, if $PREF{here} is set to something other than
      # $ENV{SCRIPT_NAME}, then visiting the script directly will trigger this, which isn't what we want.
      # TODO: should method=post be the ONLY requirement for this if()?

      # Any $PREF{extra_debug} will be lost on redirect unless we store it with the keyed message.
    my $redirect_url = ($PREF{here_static} || $PREF{here}) . "?kmsg=" . store_keyed_message($message . get_extra_debug_output());
    enc_redirect( $redirect_url );
    } else {
      start_html_output('');
      print $message;
      finish_html_output();
    }
    exit;
  }


sub exit_with_kmsg
  {
    start_html_output('');
    print get_keyed_message($_[0]);
    finish_html_output();
    exit;
  }


sub exit_with_needlogin
  {
    start_html_output('');
    $PREF{needlogin_message} =~ s/%%login_url%%/$PREF{login_url}/g;
    print $PREF{needlogin_message};
    finish_html_output();
    exit;
  }


sub exit_with_needprivs
  {
    my $whenceqs = $qs; $whenceqs =~ s!&!_ANAMP_!g;
    my $login_url = '';
    if (userbase_available() || $PREF{integrate_with_existing_login_system} =~ /yes/i) {
      $login_url = $PREF{login_url_qsready};
    } else {
      $login_url = "$PREF{here_login_qsready}action=" . ($PREF{internal_appname} =~ /visitorlog/i ? 'vllogin' : 'login') . '&amp;';
    }
    $login_url .= ($PREF{default_url_vars} ? "$PREF{default_url_vars}&amp;" : "") . "needprivs=true&amp;whence=$PREF{REQ_URI_SANS_QS}" . ($whenceqs ? "_THEQS_$whenceqs" : '');
    $login_url = "$PREF{protoprefix}$ENV{HTTP_HOST}$login_url" unless $login_url =~ /^https?:/;
    my $js_login_url = $login_url; $js_login_url =~ s!&amp;!&!g;

    my $auto_redirect = qq`<script type="text/javascript">location.href="$js_login_url";</script>\n`;

    $PREF{needprivs_message} =~ s/%%login_url%%/$login_url/g;
    $PREF{needprivs_message} =~ s/%%js_auto_redirect%%/$PREF{member_is_logged_in} ? '' : $auto_redirect/eg;
    $PREF{needprivs_message} =~ s/%%%if-notloggedin%%%(.+?)%%%end-notloggedin%%%/$PREF{member_is_logged_in} ? '' : $1/egs;

    start_html_output('Authentication Required');
    print $PREF{needprivs_message};
    finish_html_output();
    exit;
  }


sub printd
  {
    my $msg = shift;
    chomp $msg;
    $msg = "$PREF{internal_appname}-debug: " . (offsettime()) . ": $msg";
    if ($PREF{debug} || $PREF{force_debug} =~ /yes/i || $debuglog) {
      enc_warn "$msg\n";
      encdebug $msg;
      print $debuglog "$msg\n" if $debuglog;
    }
    if ($PREF{debug}) {
      #print_http_headers();
      #print "<!-- $msg -->\n";
    }
  }


# Some SQL implementations support other nonsense in the table names; we'll restrict to a sensible set of characters.
#
sub tablename_is_valid				{ return ($_[0] =~ /^\w+$/	&&						length($_[0]) <= $PREF{max_tablename_length});		}
sub check_tablename_for_sql_safeness		{ die_nice("Invalid tablename: '$_[0]'") unless tablename_is_valid($_[0]); 								}


sub get_db_connection
  {
    eval { require DBI; require DBD::mysql; }; die_nice qq`error while trying to load the DBI module.&nbsp; You probably need to <a href="http://encodable.com/perl_modules/" target="_blank">install the Perl module</a> for it.&nbsp; The error message was: <br /><br />\n\n $0: $@\n` if $@;
    if (!$PREF{dbh}   ||   $_[0] eq 'force') {
      my $dbname = $PREF{database_name};
      $dbname .= ":$PREF{database_hostname}" if $PREF{database_hostname};
      $PREF{dbi_connection_string} =~ s!%%dbname%%!$dbname!g;

#      print "<p><tt>DBI->connect($PREF{dbi_connection_string}, $PREF{database_username}, $PREF{database_password})</tt></p>\n";
      $PREF{dbh} = DBI->connect($PREF{dbi_connection_string}, $PREF{database_username}, $PREF{database_password})
        or exit_with_error("Error: $DBI::errstr <br /><br />\n\nPlease verify your settings for the following preferences: \$PREF{database_hostname}, \$PREF{database_name}, \$PREF{database_username}, \$PREF{database_password}.");

      # 20090425: there's a bug somewhere in the Perl MySQL stack which causes the
      # database connection to be silently dropped in some cases, resulting in the
      # Perl script simply dying (segfaulting?) when attempting to use the connection.
      # This happens even though mysql_auto_reconnect is enabled; disabling that
      # causes the script to die with the "MySQL server has gone away" error, instead
      # of dying silently.  Furthermore, with mysql_auto_reconnect enabled, the Perl
      # script will also segfault if you call $dbh->ping() after the connection has
      # been lost, making it totally worthless for its intended purpose.  The root
      # cause of this issue may be the following DBD-mysql bug:
      #
      #	http://rt.cpan.org/Public/Bug/Display.html?id=37027
      #
      # That bug report hasn't been updated since October of 2008, and the bug still
      # exists as of April 2009, so as a workaround, we'll disable mysql_auto_reconnect
      # and then always do a $dbh->ping() before every database communication.
      #
      $PREF{dbh}->{mysql_auto_reconnect} = 0;
    }
  }


sub verify_db_connection
  {
    get_db_connection('force') unless $PREF{dbh} && $PREF{dbh}->ping;
  }


sub db_column_exists($$)
  {
    my $column_to_find = shift;
    my $table_name = shift;

    verify_db_connection();
    check_tablename_for_sql_safeness($table_name);

    my ($column_name, $temp) = ('','');
    my $sth = $PREF{dbh}->prepare("SHOW COLUMNS FROM `$table_name`;");
    $sth->execute() or die_nice "Error: $DBI::errstr\n";
    $sth->bind_columns(\$column_name, \$temp, \$temp, \$temp, \$temp, \$temp);
    while ($sth->fetchrow_arrayref) {
      #print STDERR "column_name='$column_name', column_to_find='$column_to_find'\n";

      #return 1 if $column_name eq $column_to_find;
      #
      # MySQL returns a "Duplicate column name" error if you try to create a column
      # named (for example) "Color" when there's already one named "color":
      #
      return 1 if lc($column_name) eq lc($column_to_find);
    }
    return 0;
  }


sub db_table_exists($)
  {
    my ($table_to_check, $table, $table_exists) = (shift, '', 0);
    my $sth = $PREF{dbh}->prepare(qq`show tables;`);
    $sth->execute();
    $sth->bind_columns(\$table);
    while ($sth->fetchrow_arrayref) {
      if ($table eq $table_to_check) {
        $table_exists = 1;
        last;
      }
    }
    return $table_exists;
  }


sub get_db_colnames($)
  {
    my $table = shift;
    check_tablename_for_sql_safeness($table);
    my $colnames = '';
    my $column_name = '';
    my $temp = '';
    my $sth = $PREF{dbh}->prepare("SHOW COLUMNS FROM `$table`;");
    $sth->execute() or die_nice "$0: Error: db_column_exists(): $DBI::errstr\n";
    $sth->bind_columns(\$column_name, \$temp, \$temp, \$temp, \$temp, \$temp);
    while ($sth->fetchrow_arrayref) {
      $colnames .= $column_name . ',';
    }
    $colnames =~ s/,$//;
    return $colnames;
  }


sub get_ip_and_host
  {
    # Some hosting companies (Yahoo) set REMOTE_ADDR to their own IP (it's a cache or proxy or something)
    # and then set the true end-user IP in a different ENV var, so if those exist, use them instead.
    #
    my $ip = $ENV{HTTP_YAHOOREMOTEIP} || $ENV{HTTP_X_FORWARDED_FOR} || $ENV{HTTP_CLIENT_IP} || $ENV{REMOTE_ADDR};
    my $host = $ENV{REMOTE_HOST};

    if ((!$host) || ($host !~ /\w\.\w/)) {
      $host = $ip;
    }
    if ($host eq $ip) {
      use Socket;
      $host = gethostbyaddr(inet_aton($ip), AF_INET);
    }
    if ((!$host) || ($host !~ /\w\.\w/)) {
      $host = $ip;
    }

    return ($ip, $host);
  }


sub populate_month_conversion_hashes
  {
    $PREF{monthnum}{jan}='01';
    $PREF{monthnum}{feb}='02';
    $PREF{monthnum}{mar}='03';
    $PREF{monthnum}{apr}='04';
    $PREF{monthnum}{may}='05';
    $PREF{monthnum}{jun}='06';
    $PREF{monthnum}{jul}='07';
    $PREF{monthnum}{aug}='08';
    $PREF{monthnum}{sep}='09';
    $PREF{monthnum}{oct}='10';
    $PREF{monthnum}{nov}='11';
    $PREF{monthnum}{dec}='12';

    $PREF{monthnum}{january}='01';
    $PREF{monthnum}{february}='02';
    $PREF{monthnum}{march}='03';
    $PREF{monthnum}{april}='04';
    $PREF{monthnum}{may}='05';
    $PREF{monthnum}{june}='06';
    $PREF{monthnum}{july}='07';
    $PREF{monthnum}{august}='08';
    $PREF{monthnum}{september}='09';
    $PREF{monthnum}{october}='10';
    $PREF{monthnum}{november}='11';
    $PREF{monthnum}{december}='12';

    $PREF{monthname}{"01"} = 'Jan';
    $PREF{monthname}{"02"} = 'Feb';
    $PREF{monthname}{"03"} = 'Mar';
    $PREF{monthname}{"04"} = 'Apr';
    $PREF{monthname}{"05"} = 'May';
    $PREF{monthname}{"06"} = 'Jun';
    $PREF{monthname}{"07"} = 'Jul';
    $PREF{monthname}{"08"} = 'Aug';
    $PREF{monthname}{"09"} = 'Sep';
    $PREF{monthname}{"10"} = 'Oct';
    $PREF{monthname}{"11"} = 'Nov';
    $PREF{monthname}{"12"} = 'Dec';
  }


sub save_php_var_to_cache($$)
  {
    my $new_var = shift;
    my $new_value = shift;
    my $new_date = offsettime();
    my $new_sessid = get_cookie($PREF{php_session_cookie_name});
    die_nice qq`couldn't determine PHP session ID from cookie; perhaps you need to adjust \$PREF{php_session_cookie_name} (currently '$PREF{php_session_cookie_name}')?` unless $new_sessid; # if there's no sessionid, we have no way to index into the cache file.
    for ($new_var, $new_value, $new_date, $new_sessid) {
      s/:::::/ENCFIVECOLONS/g;
      s/\n/ENCNEWLINE/g;
    }
    my ($session_found, $var_found) = ();

    create_file_if_DNE($PREF{php_session_cache_file},$PREF{writable_file_perms});
    my @new_contents = ();
    open(CACHEFH,"+<$PREF{php_session_cache_file}") or die_nice("couldn't open cache file '$PREF{php_session_cache_file}' for R/W: $!\n");
    my $iofh = \*CACHEFH;
    flock $iofh, 2;
    seek $iofh, 0, 0;
    while (<$iofh>) {
      if (/^date=(\d+?):::::sessid=(\w+?):::::.+/) {
        chomp;
        my ($date, $sessid) = ($1, $2);
        if ($new_date - $date < $PREF{php_session_cache_ttl}) {
          if ($sessid ne $new_sessid) {
            # If this record doesn't belong to the current user, don't bother processing it.
            push (@new_contents, "$_\n");
          } else {
            $session_found = 1;
            my $new_line = "date=${date}:::::sessid=${sessid}:::::";
            foreach my $var (split(/:::::/)) {
              my ($name,$value) = ($var =~ /(\w+)=(.*)/);
              next if $name =~ /^(date|sessid)$/i;
              if ($name eq $new_var) {
                $new_line .= "$name=${new_value}:::::"; $var_found = 1;
              } else {
                $new_line .= "$name=${value}:::::";
              }
            }
            $new_line .= "$new_var=${new_value}:::::" if !$var_found;
            push (@new_contents, "$new_line\n");
          }
        }
      }
    }
    push (@new_contents, "date=${new_date}:::::sessid=${new_sessid}:::::$new_var=${new_value}:::::\n") if !$session_found;
    seek $iofh, 0, 0;
    print $iofh @new_contents;
    truncate $iofh, tell $iofh;
    close $iofh or die_nice("couldn't close cache file '$PREF{php_session_cache_file}' after R/W: $!\n");
  }


sub get_php_var_from_cache($)
  {
    my $new_var = shift;
    my $new_value = '';
    my $new_date = offsettime();
    my $new_sessid = get_cookie($PREF{php_session_cookie_name});
    die_nice qq`couldn't determine PHP session ID from cookie; perhaps you need to adjust \$PREF{php_session_cookie_name} (currently '$PREF{php_session_cookie_name}')?` unless $new_sessid; # if there's no sessionid, we have no way to index into the cache file.
    for ($new_var, $new_value, $new_date, $new_sessid) {
      s/:::::/ENCFIVECOLONS/g;
      s/\n/ENCNEWLINE/g;
    }

    create_file_if_DNE($PREF{php_session_cache_file},$PREF{writable_file_perms});
    open(CACHEFH,"<$PREF{php_session_cache_file}") or die_nice("couldn't open cache file '$PREF{php_session_cache_file}' for reading: $!\n");
    my $infh = \*CACHEFH;
    flock $infh, 1;
    seek $infh, 0, 0;
    while (<$infh>) {
      if (/^date=(\d+?):::::sessid=(\w+?):::::.+/) {
        my ($date, $sessid) = ($1, $2);
        if ($new_date - $date < $PREF{php_session_cache_ttl}   &&   $sessid eq $new_sessid) {
          if (/(?:^|:::::)$new_var=(.*?)(?::::::|$)/) {
            $new_value = $1;
          }
        }
      }
    }
    close $infh or die_nice("couldn't close cache file '$PREF{php_session_cache_file}' after reading: $!\n");
    return $new_value;
  }


sub do_email_test
  {
    my $to		= $PREF{email_test_recipient};
    my $from	= $PREF{email_test_sender};
    my $subj	= 'test message - ' . time . " - $ENV{HTTP_HOST}";
    my $format	= $PREF{mailtest_email_format} || $PREF{global_email_format};
    my $die		= 'die_on_email_error';

    my $authname	= $PREF{smtp_auth_username} ? 'not null' : 'null';
    my $authpass	= $PREF{smtp_auth_password} ? 'not null' : 'null';

    eval { require MIME::Lite; };
    my $mimelite_available = $@ ? "it's not" : "it is";

    my $sendmail_available = -e $PREF{path_to_sendmail} ? "it does" : "it doesn't";

    my $msg		= qq`this is only a test.
email settings:
\$PREF{smtp_server}		='$PREF{smtp_server}'
\$PREF{path_to_sendmail}	='$PREF{path_to_sendmail}'
\$PREF{smtp_auth_username}	is $authname.
\$PREF{smtp_auth_password}	is $authpass.
`;

    send_email($to, $from, $subj, $msg, $format, $die);

    exit_with_notice(qq`Sent test message from "$from" to "$to"; no immediate error occurred. <br /><br />\n\nIf the MIME::Lite Perl module is installed ($mimelite_available) and if \$PREF{smtp_server} is not null (it's "$PREF{smtp_server}"), then we tried to send the email using SMTP. <br /><br />\n\nIf your sendmail executable exists ($sendmail_available) (specified by \$PREF{path_to_sendmail}, currently "$PREF{path_to_sendmail}"), then we tried to send the email using sendmail, too.`);
  }


sub add_text_to_file($$$)
  {
    # Note: this function doesn't automatically insert any newlines; it
    # only inserts precisely what it receives in the $text parameter.

    my ($text, $file, $position) = @_;
    open(my $iofh, "+<$file") or die_nice "$PREF{internal_appname}: add_text_to_file(): couldn't open file '$file' for R/W: $!\n";
    flock $iofh, 2;

    if ($position eq 'start') {
      seek $iofh, 0, 0;
      my @contents = <$iofh>;
      seek $iofh, 0, 0;
      print $iofh $text;
      print $iofh @contents;
    } else {
      seek $iofh, 0, 2;
      print $iofh $text;
    }

    truncate $iofh, tell $iofh;
    close $iofh or die_nice "$PREF{internal_appname}: add_text_to_file(): couldn't close file '$file' after R/W: $!\n";
  }


sub get_database_data
  {
    $PREF{on_page} = 'default';
    my ($tableprefname,$viewerprefname,$allowed_to_view,$allowed_to_create,$allowed_to_edit,$allowed_to_delete) = @_;
    my $dbtable = $PREF{$tableprefname} || $tableprefname; # "$tableprefname" can be the name of the pref OR of the table.
    my $createmode = 0;
    my $editmode = 0;
    my $row_id_to_edit = 0;

    if ((my $ref = $ENV{HTTP_REFERER}) && $qs !~ /(?:^|&)dbvwrwhence=.+/) {
      $ref =~ s!\?!_encrplcdqm_!g;
      $ref =~ s!&!_encrplcdamp_!g;
      $ref =~ s!^https?://!!;
      $ref =~ s!^$ENV{HTTP_HOST}!!;
      $ref .= '_dbvwrwhncend_';
      $qs .= "&dbvwrwhence=$ref";
      $ENV{REQUEST_URI} .= $ENV{REQUEST_URI} =~ /\?/ ? "&dbvwrwhence=$ref" : "?dbvwrwhence=$ref"
    }
    if ($qs =~ /(?:^|&)dbvwrwhence=(.+)_dbvwrwhncend_/) {
      $PREF{dbvwrwhence} = $1;
      $PREF{dbvwrwhence} =~ s!_encrplcdqm_!?!g;
      $PREF{dbvwrwhence} =~ s!_encrplcdamp_!&!g;
    }

    my $hiddencols			= $PREF{"${viewerprefname}_viewer_hidden_columns"};
    my $disabledcols		= $PREF{"${viewerprefname}_viewer_disabled_columns"};
    my $display_length		= $PREF{"${viewerprefname}_viewer_max_display_length"} || 500;
    my $pagetitle			= $PREF{"${viewerprefname}_viewer_title"};
    my $template			= $PREF{"${viewerprefname}_viewer_template"} || qq`\n%%header_note%%\n%%%if-db_view_controls%%%<p>[ %%db_view_controls%% ]</p>\n%%%end-db_view_controls%%%<br />\n%%output%%\n<p>%%pagelinks%%</p>\n%%search_form%%\n%%footer_note%%\n`;
    my @template_viewcontrols	= $PREF{"${viewerprefname}_viewer_template_viewcontrols"} || (qq`%%horizlink:text=Horizontal%%`, qq`%%vertlink:text=Vertical%%`, qq`%%viewalllink:text=View All%%`);
    my $template_viewcontrols_sep	= $PREF{"${viewerprefname}_viewer_template_viewcontrols_separator"} || ' | ';
    $template			=~ s!%%header_note%%!<div class="database_header_note">$PREF{"${viewerprefname}_viewer_header_note"}</div>!g;
    $template			=~ s!%%footer_note%%!$PREF{"${viewerprefname}_viewer_footer_note"}!g;
    my $itemsperpage		= $PREF{"${viewerprefname}_viewer_itemsperpage"} || 10;
    my $extra_columns		= \%{$PREF{"${viewerprefname}_viewer_extra_columns"}};
    my %db_update_details		= ( table => $dbtable, viewerprefname => $viewerprefname );

    my $creation_title_transforms	= \%{$PREF{"${viewerprefname}_creation_title_transforms"}};
    my $editmode_title_transforms	= \%{$PREF{"${viewerprefname}_editmode_title_transforms"}};
    my $viewer_title_transforms	= \%{$PREF{"${viewerprefname}_viewer_title_transforms"}};
    my $viewer_value_transforms	= \%{$PREF{"${viewerprefname}_viewer_value_transforms"}};
    my %custom_titles		= ();

    my $selection_restrictions	= $PREF{"${viewerprefname}_viewer_selection_restrictions"};
    my $editmode_restrictions	= $PREF{"${viewerprefname}_editmode_restrictions"};
	
    $PREF{"${viewerprefname}_viewer_db_url"}	||= "$PREF{here_qsready}action=" . get_qs_var('action');
    $PREF{"${viewerprefname}_viewer_db_url_full"}	||= $PREF{protoprefix} . $ENV{HTTP_HOST} . $PREF{"${viewerprefname}_viewer_db_url"}; # for within emails, etc.

    # extra_columns have a position within the displayed table, and a value, although
    # the value will often be null because it'll instead be set by a transform.  set
    # their position to >1000 in order to put them at the end of the table.
    #
    # title_transforms just change the header text for the specified column.
    #
    # value_transforms use "%%variable%%" to refer to the name/value of their own column, and
    # can also use %%foo%%, where foo is the name of any other column in the same table.
    #
    # _editmode_frontend_value_transforms are viewer transforms specifically for edit-mode;
    # they transform the values that pre-populate the form when editing a record.  So they
    # don't transform the backend (i.e. the POST side) at all.
    #
    # You can pass ?raw$columnname=yes on the URL to display that column's values in their
    # raw form, with any viewer transformations disabled.

    my ($range_start,$range_end,$sql_range_start) = get_pagination_range($itemsperpage);

    if ($allowed_to_create) {
      $createmode = 1 if get_qs_var('createmode') eq 'true';
    }

    if ($allowed_to_edit) {
      # Nothing in here should need editing.
      if (get_qs_var('editmode') eq 'true'   &&   get_qs_var('editid') =~ /^(\d+)$/) {
        $editmode = 1;
        $row_id_to_edit = $1;
      } elsif (!$createmode) {
        $$extra_columns{edit} = { position => 1 };
        $$viewer_value_transforms{edit} = qq`%%variable%% = '<a href="$PREF{REQ_URI_SANS_QS}?$qs&editmode=true&amp;editid=%%id%%&amp;format=vert">$TEXT{Edit}</a>';`;
      }
    }
    $PREF{db_editor_mode} = $createmode ? 'create' : $editmode ? 'edit' : '';

    die_unless_sqlsafe($dbtable);
    die_unless_numeric($row_id_to_edit, '$row_id_to_edit');
    $db_update_details{record_id} = $row_id_to_edit;
    my $live_data_fingerprint = md5_hex($ENV{HTTP_HOST} . $ENV{HTTP_USER_AGENT} . join('',enc_sql_select("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit")));

    my $restriction = '';
    my $num_cols = 0;

    my $db_colnames = get_db_colnames($dbtable);
    $num_cols += ($db_colnames =~ tr/,//) + 1;

    # If any extra (i.e. not straight from the DB) columns were specified,
    # get or assign their positions:
    #
    my %extra_column_names = ();
    foreach my $colname (keys %$extra_columns) {
      my $requested_pos = $$extra_columns{$colname}{position};
      if (!$requested_pos || ($requested_pos < 1000)) {
        my $pos = $$extra_columns{$colname}{position} =~ /^(\d+)$/ ? $1 : $num_cols;
        $pos++ while exists $extra_column_names{$pos};
        $extra_column_names{$pos} = $colname;
        $num_cols++;
      }
    }

    # Create the combined @column_list from the actual DB columns and
    # the extra columns with their specified positions:
    #
    my $j = 0;
    my @column_list = ();
    for (my $i = 1; $i <= $num_cols; $i++) {
      if ($extra_column_names{$i}) {
        push @column_list, $extra_column_names{$i};
      } else {
        push @column_list, (split(/,/, $db_colnames))[$j++];
      }
    }

    # Now go through the extra columns again, for any that requested to
    # be at the end of the table (by specifying a position >1000):
    #
    foreach my $colname (keys %$extra_columns) {
      my $requested_pos = $$extra_columns{$colname}{position};
      if ($requested_pos >= 1000) {
        push @column_list, $colname;
        $num_cols++;
      }
    }

    my $column_list = join ',', @column_list;

    my $vertical = $qs =~ /(?:^|&)format=vert(?:&|$)/ || ($PREF{"${viewerprefname}_viewer_default_mode"} =~ /vertical/i && $qs !~ /(?:^|&)format=horiz(?:&|$)/);
    $vertical = 0 if $PREF{"${viewerprefname}_viewer_forced_mode"} =~ /horiz/i;
    $vertical = 1 if $PREF{"${viewerprefname}_viewer_forced_mode"} =~ /vert/i;
    my %columns = map { $_ => 1 } split(/,/, $column_list);
    my %hidden_columns = map { $_ => 1 } split(/\s*,\s*/, $hiddencols);
    my %disabled_columns = map { $_ => 1 } split(/\s*,\s*/, $disabledcols);
    my %hidden_cells = ();

    my %uncreatable_columns = map { $_ => 1 } split(/\s*,\s*/, $PREF{"${viewerprefname}_viewer_uncreatable_columns"});
    my %uneditable_columns = map { $_ => 1 } split(/\s*,\s*/, $PREF{"${viewerprefname}_viewer_uneditable_columns"});
    my %autoset_columns = %{$PREF{"${viewerprefname}_creation_autoset_columns"}} if $PREF{"${viewerprefname}_creation_autoset_columns"};
    $uneditable_columns{id} = $uncreatable_columns{id} = 1;

    $PREF{"${viewerprefname}_viewer_item_name"} = $PREF{"${viewerprefname}_viewer_item_name"} || 'record';
    $PREF{"${viewerprefname}_viewer_item_name_plural"} = $PREF{"${viewerprefname}_viewer_item_name_plural"} || $PREF{"${viewerprefname}_viewer_item_name"}.'s';
    s!%%itemname%%!$PREF{"${viewerprefname}_viewer_item_name"}!g for ($TEXT{database_create_button}, $TEXT{database_create_button_2}, $TEXT{database_delete_successful}, $TEXT{database_deleter_title}, $TEXT{database_deleter_checkbox}, $TEXT{database_deleter_button});


    # Set any viewer/editor options that apply to all modes (view/create/edit):
    #
    foreach my $column (split(/,/, $column_list)) {
      my $fieldtype_already_set = 0;
      if (my ($fieldtype,$label,$listitems,$defaultvalue) = field_structure_managed_by_us($column)) {
        $custom_titles{$column} = $label if $label;
        $PREF{"${viewerprefname}_creation_default_value"}{lc($column)} = $defaultvalue if $defaultvalue;
        if ($fieldtype eq 'dropdown') {
          $listitems =~ s!\n!\|\|\|!g; # our field structure manager uses newline as separator; this function uses "|||".
          $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)} = $listitems;
          $fieldtype_already_set = 1;
        } elsif ($fieldtype eq 'checkbox') {
          $PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} = 1;
          $fieldtype_already_set = 1;
        } elsif ($fieldtype eq 'radio') {
          $listitems =~ s!\n!\|\|\|!g; # our field structure manager uses newline as separator; this function uses "|||".
          $PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)} = $listitems;
          $fieldtype_already_set = 1;
        } elsif ($fieldtype eq 'freeformmulti') {
          $PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)} = 1;
          $fieldtype_already_set = 1;
        }
      }
      if (datatype_is_bool($dbtable,$column) && !$fieldtype_already_set) {
        $PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} = 1;
        $fieldtype_already_set = 1;
      }
    }


    # Note: early return.
    if ($ENV{REQUEST_METHOD} =~ /post/i) {
      my $return_url_base = param('enc_post_return_url') || $PREF{REQ_URI_SANS_QS};
		
      my $wholequery = new CGI();
      my %allparams = $wholequery->Vars;
      my %multiboxes = ();
      foreach my $param (sort keys %allparams) {
        if (my ($col,$val) = ($param =~ /^encdb_multibox_col_(.+)_val_(.+)/)) {
          enc_urldecode($val);
          $multiboxes{$col} .= $val . '|||';
        }
      }
      foreach my $col (keys %multiboxes) {
        $multiboxes{$col} =~ s!\|\|\|$!!;
      }                         # strip the final trailing '|||'.

      if (param('searchmode') eq 'true') {
        exit_with_needprivs() unless $PREF{"${viewerprefname}_allowed_to_search"};

        my $redirect_url = get_return_url_for_dbviewer($return_url_base) . '&';

        my $searchquery = new CGI(); # must happen if we were POSTed to, or there's a weird delay between client/server after the script finishes.
        my %params = $searchquery->Vars;
        foreach my $param (sort keys %params) {
				#print "$param: $params{$param}<br />\n";
          if (my ($field) = ($param =~ /^srch_(.+)/)) {
            my $value = $params{$param};
            my $srchmode = $params{"srchmode_${field}"};
            $redirect_url =~ s!srch[1234]_${field}=[^&]+!!g; # remove any previous values for this field from the url.
            $redirect_url .= "srch${srchmode}_${field}=$value&" unless $srchmode == 4; # 4 means ignore-this-field.
          }
        }

        defooify('&', $redirect_url);
        enc_redirect($redirect_url);		
      } elsif ($editmode) {
        exit_with_needprivs() unless $allowed_to_edit;

        my $data_fingerprint_before_editing = param('enc_form_dfp');
        exit_with_error(qq`Error: data fingerprint mismatch; the data changed while you were editing it.&nbsp; Go back, reload the page, and try again.`) unless $live_data_fingerprint eq $data_fingerprint_before_editing;

        # We're only dealing with a single row here, but we'll use _multi to get the named fields into a hash.
        my $existingdata = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit $editmode_restrictions");

        if ($qs =~ /editdelete=true/) {
          exit_with_needprivs() unless $allowed_to_delete;

          $db_update_details{action} = 'delete'; $db_update_details{action_pasttense} = 'deleted';

          foreach my $col (keys %{$$existingdata{1}}) {
            exit_with_error("Error: this record cannot be deleted.") if exists $PREF{"${viewerprefname}_viewer_undeletable_rows"}{lc($col)}{   $$existingdata{1}{$col}   };
          }

          if (param('confirmdeleterecord') =~ /on/i) {
            my $values = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit LIMIT 1");
            enc_sql_delete("DELETE FROM `$dbtable` WHERE `id` = $row_id_to_edit LIMIT 1");

            if (my $code = $PREF{"${viewerprefname}_deletion_oncomplete_code"}) {
              $code =~ s/%%(\w+)%%/$$values{1}{$1}/g;
              eval $code; die_nice $@ if $@;
            }

            $db_update_details{deleted_record} = $existingdata;
            send_notification_emails_for_database_update(\%db_update_details) if $PREF{"${viewerprefname}_emailalert_on_updates"} =~ /yes/i;
            enc_redirect(get_return_url_for_dbviewer($return_url_base));
          } else {
            $qs =~ s!editdelete=true!!g;
            defooify('&',$qs);
            enc_redirect($return_url_base . ($qs ? "?$qs" : ''));
          }
        } else {
          $db_update_details{action} = 'edit'; $db_update_details{action_pasttense} = 'edited';

          my %values = ();
          foreach my $column (keys %{$$existingdata{1}}) {
            my $value = param("encdb_$column");
            $value =~ s!\r\n!\n!g;

            if (my $code = $PREF{"${viewerprefname}_POST_value_transforms"}{lc($column)}) {
              my %values_temp = { $column => '' };
              transform_value_according_to_code($dbtable, $value, \%values_temp, $code, $column, 2, undef);
              $value = $values_temp{$column};
            } elsif ($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)}) {
              $value = param("encdb_" . $column) =~ /on/i ? 1 : 0;
            } elsif ($PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)}) {
              $value = $multiboxes{$column};
            }

            replace_nonsqlsafe_chars_with($PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column}, $value) if exists $PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column};

            $values{$column} = $value;
          }

				# A second version of the same loop, but this time %values is full, so that 
				# verify_new_database_value() can use it, in case the caller has used the
				# _viewer_value_verifications mechanism with embedded %%foo%% variables which
				# require accessing other column values.
				#
          my $col_i = 0;
          foreach my $column (keys %values) {
            next if $disabled_columns{$column} || $column =~ /^enchddn_/i || $$existingdata{1}{enchddn_uneditable_cols_in_this_row} =~ /$column/i;
            next if $uneditable_columns{lc($column)};
            next if exists $PREF{"${viewerprefname}_viewer_uneditable_values"}{lc($column)}{   $$existingdata{1}{$column}   };

            my $value = $values{$column};
            verify_new_database_value($dbtable,$viewerprefname,$column,$value,$row_id_to_edit,\%values);

            sql_untaint($value,$column);
            die_unless_sqlsafe($value,$column);

            $col_i++;
            unless ($value eq $$existingdata{1}{$column}) {
              $db_update_details{changed_record}{$col_i}{column} = $column;
              $db_update_details{changed_record}{$col_i}{old_value} = $$existingdata{1}{$column};
              $db_update_details{changed_record}{$col_i}{new_value} = $value;

              $value = $value eq '' ? qq`NULL` : qq`'$value'`;
              my $success = enc_sql_update("UPDATE `$dbtable` SET `$column` = $value WHERE `id` = $row_id_to_edit");
              die_nice("SQL returned '$success' instead of '1' while updating '$column'.") unless $success == 1;
            }
          }

          if (my $code = $PREF{"${viewerprefname}_editmode_oncomplete_code"}) {
            $code =~ s/%%(\w+)___old%%/$$existingdata{1}{$1}/g;
            $code =~ s/%%(\w+)%%/$values{$1}/g;
            eval $code; die_nice $@ if $@;
          }

          $db_update_details{whole_changed_record} = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $row_id_to_edit");
          send_notification_emails_for_database_update(\%db_update_details) if $PREF{"${viewerprefname}_emailalert_on_updates"} =~ /yes/i;
          enc_redirect(get_return_url_for_dbviewer($return_url_base));
        }
      } else {
        exit_with_needprivs() unless $allowed_to_create;

        $db_update_details{action} = 'create'; $db_update_details{action_pasttense} = 'created';

        my @namelist = my @valuelist = ();

        # Do this twice, because we might need to interpolate a variable value from a
        # late column into an early column, which won't be set the first time through.
        #
        my %values = ();
        my %creation_autoset_columns___done = ();
        my %POST_value_transforms___done = ();
        foreach my $pass (1,2) {
          foreach my $column (split(/,/, $db_colnames)) {
            my $value = '';
            if (my $code = $PREF{"${viewerprefname}_creation_autoset_columns"}{lc($column)}) {
              # TODO: for clarity, should the $value param here be '' instead of $value?
              transform_value_according_to_code($dbtable, $value, \%values, $code, $column, $pass, \%creation_autoset_columns___done);
            } elsif (my $code = $PREF{"${viewerprefname}_POST_value_transforms"}{lc($column)}) {
              $value = param("encdb_" . $column);
              transform_value_according_to_code($dbtable, $value, \%values, $code, $column, $pass, \%POST_value_transforms___done);
            } elsif ($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)}) {
              $values{$column} = param("encdb_" . $column) =~ /on/i ? 1 : 0;
            } elsif ($PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)}) {
              $value = $multiboxes{$column};
            } else {
              $values{$column} = param("encdb_" . $column);
            }
            $values{$column} =~ s!\r\n!\n!g;
          }
        }

        foreach my $column (keys %values) {
          next if $uncreatable_columns{$column};
          next if $column =~ /^enchddn_/i;
          next if $disabled_columns{$column} && !$autoset_columns{$column}; # don't allow disabled columns to be set, except via autoset values.

          my $value = $values{$column};
          replace_nonsqlsafe_chars_with($PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column}, $value) if exists $PREF{"${viewerprefname}_replace_nonsqlsafe_chars_with"}{$column};
          verify_new_database_value($dbtable,$viewerprefname,$column,$value,'',\%values);
          $values{$column} = $value; # want the sqlsafe version but not the sql_untainted version.
          sql_untaint($value);
          die_unless_sqlsafe($value);
          push @namelist, "`$column`";
          push @valuelist, "'$value'";
        }

        my $statement = "INSERT INTO `$dbtable` (" . (join ',', @namelist) . ") VALUES(" . (join ',', @valuelist) . ")";
        enc_sql_insert($statement);
        my $id = enc_sql_select("SELECT LAST_INSERT_ID() FROM `$dbtable`");
        $values{id} = $db_update_details{record_id} = $id;

        if (my $code = $PREF{"${viewerprefname}_creation_oncomplete_code"}) {
          $code =~ s/%%(\w+)%%/$values{$1}/g;
          eval $code; die_nice $@ if $@;
        }

        $db_update_details{created_record} = enc_sql_select_multi("SELECT * FROM `$dbtable` WHERE `id` = $id");
        send_notification_emails_for_database_update(\%db_update_details) if $PREF{"${viewerprefname}_emailalert_on_updates"} =~ /yes/i;
        if (my $template = $PREF{"${viewerprefname}_creation_complete_page_template"}) {
          $template =~ s/%%(\w+)%%/$values{$1}/g; kmsg_redirect($template);
        } elsif (my $redirect = $PREF{"${viewerprefname}_creation_complete_redirection_url"}) {
          $redirect =~ s/%%(\w+)%%/$values{$1}/g; enc_redirect($redirect);
        } else {
          enc_redirect(get_return_url_for_dbviewer($return_url_base));
        }
      }
    }




    my ($toggles,$headers_horiz_string,%headers_horiz,%headers_vert,$firstcol) = ('','',undef,undef,undef,'');
    foreach my $column (split(/,/, $column_list)) {
      next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
      next if $uncreatable_columns{$column} && $createmode;
      next if $$extra_columns{$column} && $createmode;

      $firstcol = $column unless $firstcol;
      my $name = my $title = $column;
      if ($$creation_title_transforms{$column} && $createmode) {
        $title = $$creation_title_transforms{$column};
      } elsif ($$editmode_title_transforms{$column} && $editmode) {
        $title = $$editmode_title_transforms{$column};
      } elsif ($$viewer_title_transforms{$column}) {
        $title = $$viewer_title_transforms{$column};
      } elsif ($custom_titles{$column}) {
        $title = $custom_titles{$column};
      } else {
        $title =~ s/^(\w)/\u$1/; $title =~ s/_/ /g unless $PREF{dont_convert_underscores_to_spaces_in_db_titles} =~ /yes/i;
      }
      my $strike = qq`style="text-decoration: line-through;"` if $hidden_columns{$name};
      $toggles .= qq`<a href="#" onclick="toggle_column('col_$name'); return false" id="link-col_$name" $strike>$title</a>&nbsp; `;

      $hidden_cells{$name} = qq`style="display: none;"` if $hidden_columns{$name} && !$createmode; # don't hide them in createmode, where the user must be able to see them to enter values for them.

      my $new_qs = $qs;
      #$new_qs =~ s/(^|&)$qs_id(&|$)/$1$2/g;
      $new_qs =~ s/(^|&)sort=\w+?(&|$)/$1$2/g;
      $new_qs =~ s/(^|&)reverse=\d(&|$)/$1$2/g;
      $new_qs =~ s/(^|&)phase=\w+?(&|$)/$1$2/g;
      $new_qs .= "&sort=$name";
      if ($qs =~ /(?:^|&)reverse=1(?:&|$)/) {
        $new_qs .= "&reverse=0";
      } else {
        $new_qs .= "&reverse=1";
      }
      defooify('&',$new_qs);
      $new_qs =~ s/&/&amp;/g;

      my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{"${column}_header"} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{"${column}_header"};
      my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{"${column}_header"} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{"${column}_header"};
      #my $link = $self =~ /\?/ ? "$self&$new_qs" : "$self?$new_qs";
      my $link = "$PREF{REQ_URI_SANS_QS}?$new_qs";
      $headers_horiz_string	.= qq`<th class="col_$name" $hidden_cells{$name} $style_horiz><a href="$link">$title</a></th>`;
      $headers_horiz{$name}	 = qq`<th class="col_$name" $hidden_cells{$name} $style_horiz><a href="$link">$title</a></th>`;
      $headers_vert{$name}	 = qq`<td class="col_$name verthead" $hidden_cells{$name} $style_vert><a href="$link">$title</a></td>`;
    }

    my $output = '';
    my $there_were_some_results = 0;

    if ($createmode) {
      $output .= qq`<form method="post" action="$ENV{SCRIPT_NAME}?$qs" style="margin: 0; padding: 0;">\n`;
      $output .= qq`<div id="${dbtable}_table" class="enc_tbl enc_create_tbl">\n<table>\n`;
      $output .= qq`<tr class="headers">$headers_horiz_string</tr>\n` unless $vertical;

      my $i = 0;
      my $numcols = 1;
      my $oddeven = oddeven($i);
      $output .= qq`<tr class="$oddeven">` unless $vertical;
      foreach my $column (split(/,/, $column_list)) {
        next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
        next if $uncreatable_columns{$column};
        next if $$extra_columns{$column};
        next if $autoset_columns{$column};

        my $value = '';
        if (my $default = $PREF{"${viewerprefname}_creation_default_value"}{lc($column)}) {
          if ($default eq 'preset:date8') {
            $value = strftime("%Y%m%d",localtime(offsettime()));
          } elsif ($default eq 'preset:date17') {
            $value = strftime("%Y%m%d-%H:%M:%S",localtime(offsettime()));
          } elsif ($default eq 'preset:etime') {
            $value = offsettime();
          } elsif ($default =~ /%URL\{\w+\}/) {
            interpolate_vars_from_URL_and_cookies($default); $value = $default;
          } else {
            $value = $default;
          }
        }

        #my $readonly = $uneditable_columns{lc($column)};
        my $readonly = '';

        my $readonly__still_submitted = 'readonly="readonly"' if $PREF{"${viewerprefname}_readonly_value__still_submitted"}{lc($column)};


        # Process viewer/editor options:
        #
        if ($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} && !$readonly) {
          $value = qq`<input type="checkbox" name="encdb_$column" ` . ($value ? qq`checked="checked"` : '') . qq` />`;
        } elsif (exists $PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} && !$readonly) {
          my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
          $value  = qq`<select name="encdb_$column">`
            . qq`<option value="1"` . ($value  ? ' selected="selected"' : '') . qq`>$yes</option>`
              . qq`<option value="0"` . (!$value ? ' selected="selected"' : '') . qq`>$no</option>`
                . qq`</selected>`;
        } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)}) {
          my $dropdown = qq`<select name="encdb_$column">`;
          my $value_is_in_list = 0;
          foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
            my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
            my $selected = '';
            if ($submitted_value eq $value) {
              $selected = 'selected="selected"';
              $value_is_in_list = 1;
            }
            $dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
          }
          $dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
          $dropdown .= qq`</select>`;
          $value = $dropdown;
        } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)}) {
          my %allvalues = map { $_ => 1 } split(/\|\|\|/, $value);
          my @boxes = ();
          my $value_is_in_list = 0;
          foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
            my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
            my $checked = '';
            if ($allvalues{$submitted_value}) {
              $checked = 'checked="checked"';
              $value_is_in_list = 1;
            }
            my $submitted_value_for_paramname = enc_urlencode_return($submitted_value);
            my $boxid = "encdb_multibox_col_${column}_val_${submitted_value_for_paramname}";
            push @boxes, qq`<input type="checkbox" name="$boxid" id="$boxid" $checked /><label for="$boxid">$displayed_value</label>`;
          }
          push @boxes, qq`$value (error: not in list!)` if !$value_is_in_list && $value;
          my $separator = $PREF{"db_viewer_multibox_separator___$column"} || $PREF{db_viewer_multibox_separator___global} || '<br />';
          $value = join $separator, @boxes;
        } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)}) {
          my $item_i = 1;
          my @buttons = ();
          my $value_is_in_list = 0;
          foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
            my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
            my $checked = '';
            if ($submitted_value eq $value) {
              $checked = 'checked="checked"';
              $value_is_in_list = 1;
            }
            push @buttons, qq`<input type="radio" name="encdb_$column" id="encdb_radio_${column}_${item_i}" value="$submitted_value" $checked /><label for="encdb_radio_${column}_${item_i}">$displayed_value</label>`;
            $item_i++;
          }
          my $separator = $PREF{"db_viewer_radiobutton_separator___$column"} || $PREF{db_viewer_radiobutton_separator___global} || '<br />';
          $value = join $separator, @buttons;
        } elsif (my $query = $PREF{"${viewerprefname}_creation_dropdown_from_SQL"}{lc($column)}) {
				# The value of this query pref must start with: SELECT foo,bar FROM [...].
				# The first column will be the submitted value and the second the displayed value.

          my ($col1,$col2) = ($query =~ /^SELECT (\w+),(\w+) FROM /);
          my $dropdown = qq`<select name="encdb_$column">`;
          my $value_is_in_list = 0;
          my $results = enc_sql_select_multi($query);
          foreach my $k (sort { $a <=> $b } keys %$results) {
            my $submitted_value = $$results{$k}{$col1};
            my $displayed_value = $$results{$k}{$col2};
            my $selected = '';
            if ($submitted_value eq $value) {
              $selected = 'selected="selected"';
              $value_is_in_list = 1;
            }
            $dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
          }
          $dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
          $dropdown .= qq`</select>`;
          $value = $dropdown;
        } elsif (my $folder = $PREF{"${viewerprefname}_file_list"}{lc($column)}) {
          my @files = get_all_files($folder);
          my $dropdown = qq`<select name="encdb_$column"><option selected="selected" value=""></option>`;
          foreach my $file (@files) {
            $dropdown .= qq`<option value="$file">$file</option>`;
          }
          $dropdown .= qq`</select>`;
          $value = $dropdown;
        } else {
          my $textlength = 'longtext';
          my $force_textarea = $PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)};

          $value = $readonly
            ? qq`<div class="readonly">$value</div>`
              : (length($value) > 50 || $force_textarea)
                ? qq`<textarea name="encdb_$column" class="text $textlength" $readonly__still_submitted>$value</textarea>`
                  : qq`<input type="text" name="encdb_$column" class="text" value="$value" $readonly__still_submitted />`;
        }

        my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
        my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
        my $style = $vertical ? $style_vert : $style_horiz;
        my $vertclass = 'vertcell' if $vertical;
        $output .= qq`<tr class="$oddeven vertrow">` if $vertical;
        $output .= $headers_vert{$column} if $vertical;
        $output .= qq`<td class="col_$column $vertclass" $hidden_cells{$column} $style>$value</td>`;
        $output .= qq`</tr>\n` if $vertical;
        $numcols++;
      }
      $output .= qq`</tr>\n` unless $vertical;

      $output .= qq`<tr class="` . oddeven($i) . qq`">`;
      $output .= qq`<td colspan="$numcols" class="button"><input type="submit" class="button" value="$TEXT{database_create_button_2}" /></td>`;
      $output .= qq`</tr>\n`;

      $output .= qq`</table>\n</div>\n`;
      $output .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n`;
      $output .= qq`</form>\n`;
    } else {
      my $editclass = $editmode ? 'enc_edit_tbl' : '';
      my $quicksort_class = quicksort_is_active() ? 'enc_sortable' : '';
      $output .= qq`<form method="post" action="$ENV{SCRIPT_NAME}?$qs" style="margin: 0; padding: 0;">\n` if $editmode;
      $output .= qq`<div id="columntoggles">Show/hide:&nbsp; $toggles</div>\n` unless $PREF{"${viewerprefname}_viewer_hide_column_toggles"} =~ /yes/i;
      $output .= qq`<div id="${dbtable}_table" class="enc_tbl $editclass">\n<table class="$quicksort_class" id="db_viewer_table">\n` unless $vertical;
      $output .= qq`<tr class="headers">$headers_horiz_string</tr>\n` unless $vertical;

      # 20090429: changed the query from this:
      #
      #	SELECT * FROM `$dbtable` LIMIT $sql_range_start, $range_end
      #
      # ...to this:
      #
      #	SELECT * FROM `$dbtable` $DESC LIMIT $sql_range_start, $range_end
      #
      # ...where $DESC = $reverse ? 'ORDER BY `id` DESC' : ''.
      # This is so that, when sorting in reverse with multiple pages of records (with
      # for example 25 records per page), page #1 shows the *last* 25 records, rather
      # than the first 25 but in reverse order.  But, shouldn't we be using $sortkey,
      # as in the original now-commented-out query, rather than hard-coding it to `id`?

      my $sortkey = $qs =~ /(?:^|&)sort=(\w+?)(?:&|$)/ ? $1
        : $PREF{"${viewerprefname}_viewer_default_sort_field"} ? $PREF{"${viewerprefname}_viewer_default_sort_field"} 
          : exists $columns{id} ? 'id'
            : $firstcol;
      my $reverse = $qs =~ /(?:^|&)reverse=1(?:&|$)/ ? 1 : 0; # toggle the 1s and 0s to reverse by default or not.
      #my $DESC = $reverse ? 'ORDER BY `id` DESC' : '';
      my $DESC = $reverse ? 'DESC' : '';
      enc_urldecode($sortkey);
      die_unless_sqlsafe($sortkey);

      # 20110823: moving the querystring-based result restriction logic up here, so we can
      # make it part of the actual SQL query, and thus have the result count and pagination
      # numbers etc be correct, as opposed to before when this was done just after the SQL
      # query by simply hiding (skipping) result rows that didn't match the qs-specified
      # restrictions.
      #
      foreach my $column (split(/,/, $column_list)) {
        if ($qs =~ /(?:^|&)$column=([^&]*)(?:&|$)/i) {
          my $url_specified_value = $1;
          enc_urldecode($url_specified_value);
          sql_untaint($url_specified_value);
          die_unless_sqlsafe($url_specified_value);
          $selection_restrictions .= $selection_restrictions ? " AND " : " WHERE ";
          $selection_restrictions .= "`$column` = '$url_specified_value'";
        }
      }

      while ($qs =~ /(?:^|&)srch([123])_([^=]+)=([^&]+)/g) {
        my ($srchmode, $srchfield, $srchvalue) = ($1, $2, $3);
        $srchvalue = enc_urldecode_return($srchvalue);
        sql_untaint($srchfield,$srchvalue);
        die_unless_sqlsafe($srchfield,$srchvalue);
        $selection_restrictions .= $selection_restrictions ? " AND " : " WHERE ";
        if ($srchmode == 1)     # exact.
          {
            $selection_restrictions .= "`$srchfield` = '$srchvalue'";
          } elsif ($srchmode == 2) # partial.
            {
              $selection_restrictions .= "`$srchfield` LIKE '%$srchvalue%'";
            } elsif ($srchmode == 3) # invert.
              {
                $selection_restrictions .= "`$srchfield` NOT LIKE '%$srchvalue%'";
              }
      }
		
      #my $rows = enc_sql_select_multi("SELECT * FROM `$dbtable` ORDER BY `$sortkey` LIMIT $sql_range_start, $range_end");
      my $mainquery = "SELECT * FROM `$dbtable` $selection_restrictions ORDER BY `$sortkey` $DESC LIMIT $sql_range_start, $itemsperpage";
      #encdebug "query: $mainquery";
      my $rows = enc_sql_select_multi($mainquery);

      # Do a first pass so we can perform value_transforms, so the values are
      # set and then we can do the sorting properly in the second pass.
      #
      foreach my $row (keys %$rows) {
        # Actually, do this first pass twice, because we might need to interpolate
        # a variable value from a late column into an early column, which won't be
        # set the first time through.
        #
        my %already_transformed = ();
        foreach my $pass (1,2) {
          foreach my $column (split(/,/, $column_list)) {
            #next if $disabled_columns{$column}; # actually, don't skip disabled cols here; we want their values to be available for transforms for other cols.
            my $value = exists $$extra_columns{$column} ? $$extra_columns{$column}{value} : $$rows{$row}{$column};
            $$rows{$row}{"${column}___raw"} = $value if $pass==1;
            if ((my $code = $$viewer_value_transforms{$column})   &&   $qs !~ /(^|&)raw$column=yes(&|$)/i) {
              transform_value_according_to_code($dbtable, $value, \%{$$rows{$row}}, $code, $column, $pass, \%already_transformed);
            } elsif ((my $code = $PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{lc($column)})   &&   $qs !~ /(^|&)raw$column=yes(&|$)/i) {
              transform_value_according_to_code($dbtable, $value, \%{$$rows{$row}}, $code, $column, $pass, \%already_transformed);
            } else {
              $$rows{$row}{$column} = $value;
            }
          }
        }
      }

      my $there_was_some_output = 0;
      my $numcols = 0;
      my $i = 1;
      foreach my $row (sort
                         {
                           $$rows{$a}{$sortkey} =~ /^\d*$/ && $$rows{$b}{$sortkey} =~ /^\d*$/ && $reverse	? lc($$rows{$b}{$sortkey}) <=> lc($$rows{$a}{$sortkey})
                             : $$rows{$a}{$sortkey} =~ /^\d*$/ && $$rows{$b}{$sortkey} =~ /^\d*$/			? lc($$rows{$a}{$sortkey}) <=> lc($$rows{$b}{$sortkey})
                               : $reverse										? lc($$rows{$b}{$sortkey}) cmp lc($$rows{$a}{$sortkey})
                                 : 											  lc($$rows{$a}{$sortkey}) cmp lc($$rows{$b}{$sortkey})
                               }
                           keys %$rows) {
        my $failed_to_match_url_spec = my $row_is_hidden_via_value_regex = 0;
        foreach my $column (split(/,/, $column_list)) {
				# 20110823: moved to above the SQL query.
				#
				#if($qs =~ /(?:^|&)$column=([^&]*)(?:&|$)/i)
				#{
				#	my $url_specified_value = $1;
				#	enc_urldecode($url_specified_value);
				#	$failed_to_match_url_spec = 1 if $$rows{$row}{$column} ne $url_specified_value;
				#}

          if (exists $PREF{"${viewerprefname}_viewer_hidden_values_regex"}{lc($column)} && $qs !~ /showhiddenrows=true/) {
            my $regex = $PREF{"${viewerprefname}_viewer_hidden_values_regex"}{lc($column)};
            $row_is_hidden_via_value_regex ||= $regex && $$rows{$row}{$column} =~ /($regex)/i;
          }
        }
        next if $failed_to_match_url_spec || $row_is_hidden_via_value_regex;

        next if $editmode && $$rows{$row}{id} != $row_id_to_edit;

        $numcols = 0;
        my $oddeven = oddeven($i);
        $output .= qq`<div id="${dbtable}_table" class="enc_tbl $editclass">\n<table>\n` if $vertical;
        $output .= qq`<tr class="$oddeven">` unless $vertical;
        foreach my $column (split(/,/, $column_list)) {
          next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
          my $value = '';

          if ($editmode) {
            $value = $$rows{$row}{"${column}___raw"};
            my $transformed_value = $$rows{$row}{$column};

            # If *any* of the columns in this row are specified in _viewer_undeletable_rows,
            # then the whole row must be undeletable, so disable the $allowed_to_delete bit.
            #
            $allowed_to_delete = 0 if exists $PREF{"${viewerprefname}_viewer_undeletable_rows"}{lc($column)}{$value};
            #
            # Or if the table has an "enchddn_undeletable" column, and it's enabled for this
            # row, then disable the $allowed_to_delete bit.
            #
            $allowed_to_delete = 0 if $$rows{$row}{enchddn_undeletable};

            my $uneditable_value = exists $PREF{"${viewerprefname}_viewer_uneditable_values"}{lc($column)}{$value};
            my $readonly = $$extra_columns{lc($column)} || $uneditable_columns{lc($column)} || $uneditable_value;
            $readonly = 1 if $value ne $transformed_value && exists $PREF{"${viewerprefname}_viewer_readonly_if_transformed"}{lc($column)};
            $readonly = 1 if exists $$rows{$row}{enchddn_uneditable_cols_in_this_row} && $$rows{$row}{enchddn_uneditable_cols_in_this_row} =~ /$column/i;

            if ($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)} && !$readonly) {
              $value = qq`<input type="checkbox" name="encdb_$column" ` . ($value ? qq`checked="checked"` : '') . qq` />`;
            } elsif (exists $PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)} && !$readonly) {
              my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
              if ($transformed_value =~ /^[01]?$/) {
                $value  = qq`<select name="encdb_$column">`
                  . qq`<option value="1"` . ($value  ? ' selected="selected"' : '') . qq`>$yes</option>`
                    . qq`<option value="0"` . (!$value ? ' selected="selected"' : '') . qq`>$no</option>`
                      . qq`</selected>`;
              } else {
                # So we can use a transform to set the displayed value to 'N/A' (for example)
                # if necessary, for cases where the column shouldn't apply at all based on
                # other column values for this row.
                #
                $value = $transformed_value;
              }
            } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)}) {
              my $dropdown = qq`<select name="encdb_$column">`;
              my $value_is_in_list = 0;
              foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
                my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
                my $selected = '';
                if ($submitted_value eq $value) {
                  $selected = 'selected="selected"';
                  $value_is_in_list = 1;
                }
                $dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
              }
              $dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
              $dropdown .= qq`</select>`;
              $value = $dropdown;
            } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)}) {
              my %allvalues = map { $_ => 1 } split(/\|\|\|/, $value);
              my @boxes = ();
              my $value_is_in_list = 0;
              foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
                my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
                my $checked = '';
                if ($allvalues{$submitted_value}) {
                  $checked = 'checked="checked"';
                  $value_is_in_list = 1;
                }
                my $submitted_value_for_paramname = enc_urlencode_return($submitted_value);
                my $boxid = "encdb_multibox_col_${column}_val_${submitted_value_for_paramname}";
                push @boxes, qq`<input type="checkbox" name="$boxid" id="$boxid" $checked /><label for="$boxid">$displayed_value</label>`;
              }
              push @boxes, qq`$value (error: not in list!)` if !$value_is_in_list && $value;
              my $separator = $PREF{"db_viewer_multibox_separator___$column"} || $PREF{db_viewer_multibox_separator___global} || '<br />';
              $value = join $separator, @boxes;
            } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_radio_buttons"}{lc($column)}) {
              my $item_i = 1;
              my @buttons = ();
              my $value_is_in_list = 0;
              foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
                my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
                my $checked = '';
                if ($submitted_value eq $value) {
                  $checked = 'checked="checked"';
                  $value_is_in_list = 1;
                }
                push @buttons, qq`<input type="radio" name="encdb_$column" id="encdb_radio_${column}_${item_i}" value="$submitted_value" $checked /><label for="encdb_radio_${column}_${item_i}">$displayed_value</label>`;
                $item_i++;
              }
              my $separator = $PREF{"db_viewer_radiobutton_separator___$column"} || $PREF{db_viewer_radiobutton_separator___global} || '<br />';
              $value = join $separator, @buttons;
            } elsif (my $query = $PREF{"${viewerprefname}_editmode_dropdown_from_SQL"}{lc($column)}) {
              # The value of this query pref must start with: SELECT foo,bar FROM [...].
              # The first column will be the submitted value and the second the displayed value.

              my ($col1,$col2) = ($query =~ /^SELECT (\w+),(\w+) FROM /);
              my $dropdown = qq`<select name="encdb_$column">`;
              my $value_is_in_list = 0;
              my $results = enc_sql_select_multi($query);
              foreach my $k (sort { $a <=> $b } keys %$results) {
                my $submitted_value = $$results{$k}{$col1};
                my $displayed_value = $$results{$k}{$col2};
                my $selected = '';
                if ($submitted_value eq $value) {
                  $selected = 'selected="selected"';
                  $value_is_in_list = 1;
                }
                $dropdown .= qq`<option value="$submitted_value" $selected>$displayed_value</option>`;
              }
              $dropdown .= qq`<option selected="selected" value="$value">$value (error: not in list!)</option>` if !$value_is_in_list && $value;
              $dropdown .= qq`</select>`;
              $value = $dropdown;
            } elsif (my $folder = $PREF{"${viewerprefname}_file_list"}{lc($column)}) {
              my @files = get_all_files($folder);
              my $dropdown = qq`<select name="encdb_$column">`;
              my $value_is_in_list = 0;
              foreach my $file (@files) {
                my $selected = '';
                if ($file eq $value) {
                  $selected = 'selected="selected"';
                  $value_is_in_list = 1;
                }
                $dropdown .= qq`<option value="$file" $selected>$file</option>`;
              }
              $dropdown .= qq`<option selected="selected" value="$value">$value (error: file does not exist!)</option>` if !$value_is_in_list && $value;
              $dropdown .= qq`</select>`;
              $value = $dropdown;
            } else {
              $value = $transformed_value if $readonly; # display the transformed value, instead of the raw value, if it's not editable.
              $value = $transformed_value if $PREF{"${viewerprefname}_editmode_frontend_value_transforms"}{lc($column)};

              $value =~ s!"!&quot;!g unless $readonly;
              my $textlength = length($value) < 50 ? 'shorttext' : length($value) < 200 ? 'mediumtext' : 'longtext';
              my $force_textarea = $PREF{"${viewerprefname}_viewer_force_textarea"}{lc($column)};

              if (!$value && exists $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)}) {
                $value = $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)};
              }

              $value = $readonly
                ? qq`<div class="readonly">$value</div>`
                  : (length($value) > 50 || $force_textarea)
                    ? qq`<textarea name="encdb_$column" class="text $textlength">$value</textarea>`
                      : qq`<input type="text" name="encdb_$column" class="text" value="$value" />`;
            }
          } else {
            $value = $$rows{$row}{$column};

            # Value processing:
            #
            if ($PREF{"${viewerprefname}_viewer_column_is_checkbox"}{lc($column)}) {
              $value = $value ? $TEXT{boolean_true_string} : $TEXT{boolean_false_string};
            } elsif ($PREF{"${viewerprefname}_viewer_column_is_toggle"}{lc($column)}) {
              my ($yes,$no) = $PREF{"${viewerprefname}_viewer_column_toggle_values"}{lc($column)} =~ /(.+)\|(.+)/ ? ($1,$2) : ($TEXT{boolean_true_string}, $TEXT{boolean_false_string});
              $value = $value == 1 ? $yes : $value =~ /^0?$/ ? $no : $value;
            } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_predefined_list"}{lc($column)}) {
              foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
                my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
                $value = $displayed_value if $submitted_value eq $value;
              }
            } elsif (my $list = $PREF{"${viewerprefname}_viewer_column_is_multibox"}{lc($column)}) {
              my %allvalues = map { $_ => 1 } split(/\|\|\|/, $value);
              my @boxes = ();
              foreach my $item (split(/\s*\|\|\|\s*/, $list)) {
                my ($submitted_value, $displayed_value) = $item =~ m!(.*)///(.*)! ? ($1,$2) : ($item,$item);
                push(@boxes, $displayed_value) if $allvalues{$submitted_value};
              }
              my $sep = $PREF{"${viewerprefname}_viewer_column_multibox_separator"}{lc($column)} || '<br />';
              $value = join $sep, @boxes;
            }

            # Value correction/cleanup:
            #
            if (length($value) > $display_length && $value !~ m!</?\w+>!) # don't shorten values containing HTML, b/c it'll break the code.
              {
                my $abbreviated_value = $value;
                $abbreviated_value =~ s/^(.{$display_length}).*/$1.../;
                $value =~ s/"/\\"/g;
                $value = qq`<span title="$value">$abbreviated_value</span>`;
              }
            if (!$value && exists $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)}) {
              $value = $PREF{"${viewerprefname}_viewer_display_value_if_null"}{lc($column)};
            }
            if ($PREF{"${viewerprefname}_viewer_show_HTML_as_code"}{lc($column)}) {
              $value =~ s/</&lt;/g;
              $value =~ s/>/&gt;/g;
            }
            $value =~ s!\n!<br />\n!g;
          }

          my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
          my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
          my $style = $vertical ? $style_vert : $style_horiz;
          my $vertclass = 'vertcell' if $vertical;
          $output .= qq`<tr class="$oddeven vertrow">` if $vertical;
          $output .= $headers_vert{$column} if $vertical;
          $output .= qq`<td class="col_$column $vertclass" $hidden_cells{$column} $style>$value</td>`;
          $output .= qq`</tr>\n` if $vertical;
          $there_was_some_output = 1;
          $numcols++;
        }

        if ($vertical) {
          if ($editmode) {
            $output .= qq`<tr class="` . oddeven($i) . qq`">`;
            $output .= qq`<td colspan="$numcols" class="button"><input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" class="button" value="$TEXT{database_save_button}" /></td>`;
            $output .= qq`</tr>\n`;
          } elsif ($allowed_to_create) {
            $output .= qq`<tr class="` . oddeven($i) . qq` enc_sortbottom">`;
            $output .= qq`<td colspan="$numcols" class="addnew"><a href="$PREF{REQ_URI_SANS_QS}?$qs&amp;createmode=true&amp;format=vert">$TEXT{database_create_button}</a></td>`;
            $output .= qq`</tr>\n`;
          }
        }

        $output .= qq`</tr>\n` unless $vertical;
        $output .= qq`</table>\n</div>\n` if $vertical;
      }

      unless($numcols)
        {
          foreach my $column (split(/,/, $column_list)) {
            next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
            $numcols++;
          }
        }

      if (!$vertical) {
        if ($editmode) {
          $output .= qq`<tr class="` . oddeven($i) . qq`">`;
          $output .= qq`<td colspan="$numcols" class="button"><input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" class="button" value="$TEXT{database_save_button}" /></td>`;
          $output .= qq`</tr>\n`;
          $there_was_some_output = 1;
        } elsif ($allowed_to_create) {
          $output .= qq`<tr class="` . oddeven($i) . qq` enc_sortbottom">`;
          $output .= qq`<td colspan="$numcols" class="addnew"><a href="$PREF{REQ_URI_SANS_QS}?$qs&amp;createmode=true&amp;format=vert">$TEXT{database_create_button}</a></td>`;
          $output .= qq`</tr>\n`;
          $there_was_some_output = 1;
        }
      }

      unless($there_was_some_output)
        {
          $output .= qq`<div id="${dbtable}_table" class="enc_tbl">\n<table>\n` if $vertical;
          $output .= qq`<tr class="` . oddeven($i) . qq`">`;
          $output .= qq`<td colspan="$numcols">$TEXT{no_output_from_database}</td>`;
          $output .= qq`</tr>\n`;
          $output .= qq`</table>\n</div>\n` if $vertical;
        }

      $output .= qq`</table>\n</div>\n` unless $vertical;
      $output .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n` if $editmode;
      $output .= qq`</form>\n` if $editmode;


      if ($editmode && $allowed_to_delete) {
        $output .= qq`
					<form id="database_deleter" method="post" action="$ENV{SCRIPT_NAME}?$qs&amp;editdelete=true"><div class="enc_tbl"><table>
					<tr class="headers"><th>$TEXT{database_deleter_title}</th></tr>
					<tr class="` . oddeven($i) . qq`"><td><input type="checkbox" class="checkbox" name="confirmdeleterecord" id="confirmdeleterecord" /><label for="confirmdeleterecord">` . ($PREF{"${viewerprefname}_record_deletion_warning"} || $TEXT{database_deleter_checkbox}) . qq`</label></td></tr>
					<tr class="` . oddeven($i) . qq`"><td class="button"><input type="hidden" name="enc_form_dfp" value="$live_data_fingerprint" /><input type="submit" class="button" value="$TEXT{database_deleter_button}" /></td></tr>
					</table></div>
					<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />
					</form>
			`;
      }


      $output .= qq`

		<script type="text/javascript">

		function toggle_column(theclass)
		{
			var rows = document.getElementById('${dbtable}_table').getElementsByTagName('tr');

			var cells = new Array;
			for(i = 0; i < rows.length; i++)
			{
				var headers = rows[i].getElementsByTagName('th');
				for(j = 0; j < headers.length; j++)
				{
					//if(headers[j].className == theclass)
					//	cells.push(headers[j]);

					var re = new RegExp('(^| )' + theclass + '( |\$)', "i");
					if(headers[j].className.match(re))
						cells.push(headers[j]);
				}

				var nonheaders = rows[i].getElementsByTagName('td');
				for(j = 0; j < nonheaders.length; j++)
				{
					//if(nonheaders[j].className == theclass)
					//	cells.push(nonheaders[j]);

					var re = new RegExp('(^| )' + theclass + '( |\$)', "i");
					if(nonheaders[j].className.match(re))
						cells.push(nonheaders[j]);
				}
			}
			for(i = 0; i < cells.length; i++)
			{
				if(cells[i].style.display == 'none')
				{
					cells[i].style.display = navigator.userAgent.indexOf("MSIE") ==  -1 ? 'table-cell' : 'block'; // IE doesn't support table-cell...
					document.getElementById("link-" + theclass).style.textDecoration = '';
				}
				else
				{
					cells[i].style.display = 'none';
					document.getElementById("link-" + theclass).style.textDecoration = 'line-through';
				}
			}
		}
		
		</script>

		`;
    }


    my $search_form = '';
    if (!$editmode && !$createmode && $PREF{"${viewerprefname}_allowed_to_search"})
      #if(0) # this is in progress.
      {
        $search_form .= qq`<div id="${dbtable}_search_wrapper" class="db_search">\n<div id="search_title" onclick="showhide_element('db_search_form');">Search:</div>\n`;
        $search_form .= qq`<form method="post" id="db_search_form" action="$ENV{SCRIPT_NAME}?$qs" ` . ($qs !~ /(^|&)srch[123]_(\w+)/ ? qq`style="position: absolute; left: -7000px; height: 0; overflow: hidden;"` : '') . qq`>\n`;
        $search_form .= qq`<div id="${dbtable}_search_table" class="not_enc_tbl">\n<table class="" id="db_viewer_search_table">\n` unless $vertical;
        $search_form .= qq`<tr class="headers">%%headers_horiz_local%%</tr>\n` unless $vertical;

        my $i = 0;
        my $numcols = 0;
        my $oddeven = oddeven($i);
        my $headers_horiz_local = '';
        $search_form .= qq`<div id="${dbtable}_search_table" class="db_search">\n<table>\n` if $vertical;
        $search_form .= qq`<tr class="$oddeven">` unless $vertical;
        foreach my $column (split(/,/, $column_list)) {
          next if $disabled_columns{$column} || $column =~ /^enchddn_/i;
          next if $$extra_columns{$column}{position} == 1 && $column eq 'edit';
          $numcols++;
			
          $headers_horiz_local .= $headers_horiz{$column};

          my $style_horiz = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_horiz"}{$column} . qq`"`) if exists $PREF{"${viewerprefname}_viewer_style_horiz"}{$column};
          my $style_vert  = (qq`style="` . $PREF{"${viewerprefname}_viewer_style_vert"}{$column} . qq`"`)  if exists $PREF{"${viewerprefname}_viewer_style_vert"}{$column};
          my $style = $vertical ? $style_vert : $style_horiz;
          my $vertclass = 'vertcell' if $vertical;
          $search_form .= qq`<tr class="$oddeven vertrow">` if $vertical;
          $search_form .= $headers_vert{$column} if $vertical;
			
          $search_form .= qq`<td class="col_$column $vertclass" $hidden_cells{$column} $style><input type="text" class="srch_text" name="srch_$column" value="` . (get_qs_var("srch1_$column") || get_qs_var("srch2_$column") || get_qs_var("srch3_$column")) . qq`" />`;
          $search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_1" value="1" ` . ($qs =~ /(^|&)srch1_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_1">Must match exactly</label>`;
          $search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_2" value="2" ` . ($qs =~ /(^|&)srch2_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_2">Partial match OK</label>`;
          $search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_3" value="3" ` . ($qs =~ /(^|&)srch3_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_3">Must not match</label>`;
          $search_form .= qq`<br /><input type="radio" name="srchmode_$column" id="srchmode_${column}_4" value="4" ` . ($qs !~ /(^|&)srch[123]_${column}=/ ? qq`checked="checked"` : '')	. qq`/><label for="srchmode_${column}_4">Unused in this search</label>`;
          $search_form .= qq`</td>`;
			
          $search_form .= qq`</tr>\n` if $vertical;
        }
        $search_form =~ s!%%headers_horiz_local%%!$headers_horiz_local!;

        if (!$vertical) {
          $search_form .= qq`</tr>\n`; # unless $vertical;
        }

        #$search_form .= qq`<tr class="` . oddeven($i) . qq` enc_sortbottom">`;
        #$search_form .= qq`<td colspan="$numcols" class="search"><input type="submit" value="$TEXT{database_search_button}" /></td>`;
        #$search_form .= qq`</tr>\n`;
        #
        #$search_form .= qq`</table>\n</div>\n`;

        my $search_reset_url = $qs;
        $search_reset_url =~ s!(^|&)srch[1234]_[^=]+=[^&]+!!g;
        defooify('&', $search_reset_url);
        $search_reset_url = $PREF{REQ_URI_SANS_QS} . '?' . $search_reset_url;

        $search_form .= qq`</table>\n<input type="submit" value="$TEXT{database_search_button}" />\n`;
        $search_form .= qq`<input type="button" name="db_search_form_reset_button" id="db_search_form_reset_button" value="Reset" onclick='if(window.confirm("Really clear the search form?")) { location.href="$search_reset_url"; }' />\n`;
        $search_form .= qq`</div>\n`;

        $search_form .= qq`<input type="hidden" name="searchmode" value="true" />\n`;
        $search_form .= qq`<input type="hidden" name="enc_post_return_url" value="$PREF{REQ_URI_SANS_QS}" />\n`;
        $search_form .= qq`</form>\n</div>\n`;
      }


    $template =~ s!%%output%%!$output!;

    my $uri = $ENV{REQUEST_URI};
    $uri =~ s/(\?|&)format=(horiz|vert)/$1/gi;
    defooify('&', $uri);
    my $horizlink	= $uri . ($uri =~ /\?/ ? '&' : '?') . qq`format=horiz`;
    my $vertlink	= $uri . ($uri =~ /\?/ ? '&' : '?') . qq`format=vert`;
    $uri = $ENV{REQUEST_URI};
    $uri =~ s!editdelete=true!!g;
    $uri =~ s!(edit|create)mode=true!!g;
    $uri =~ s!editid=\d+!!g;
    clean_database_url($uri);
    defooify('&',$uri);
    defooify('\?',$uri);

    my @template_viewcontrols_pruned = ();
    for (@template_viewcontrols) {
      if ($PREF{"${viewerprefname}_viewer_forced_mode"} =~ /horiz|vert/) {
        s!%%(?:horiz|vert)link:text=([^%]+)%%!!g;
      } else {
        s!%%horizlink:text=([^%]+)%%!$vertical ? qq`<a href="$horizlink">$1</a>` : $1!eg;
        s!%%vertlink:text=([^%]+)%%!$vertical ? $1 : qq`<a href="$vertlink">$1</a>`!eg;
      }

      s!%%viewalllink:text=([^%]+)%%!$editmode || $createmode ? qq`<a href="$uri">$1</a>` : ''!eg;

      push(@template_viewcontrols_pruned, $_) if $_;
    }

    # For example:   %%%if-whence%%% %%whencelink:text=Back To Fields List%% | %%%end-whence%%%
    #
    $template =~ s!%%whencelink:text=([^%]+)%%!$PREF{dbvwrwhence} ? qq`<a href="$PREF{dbvwrwhence}">$1</a>` : ''!eg;
    $template =~ s!%%%if-whence%%%(.*?)%%%end-whence%%%!$PREF{dbvwrwhence} ? $1 : ''!egs;

    $template =~ s!%%%if-db_view_controls%%%(.*?)%%%end-db_view_controls%%%!@template_viewcontrols_pruned ? $1 : ''!egs;
    $template =~ s!%%db_view_controls%%!join $template_viewcontrols_sep, @template_viewcontrols_pruned!egs;

    my $numitems = enc_sql_select("SELECT COUNT(*) FROM `$dbtable` $selection_restrictions");
    my $pagelinks = get_pagination_links_mark2( { range_start => $range_start, range_end => $range_end, num_items => $numitems, items_per_page => $itemsperpage } ) unless $createmode || $editmode;
    $template =~ s!%%%if-pagelinks%%%(.*?)%%%end-pagelinks%%%!$pagelinks ? $1 : ''!egs;
    $template =~ s!%%pagelinks%%!$pagelinks!g;
    $template =~ s!%%search_form%%!$search_form!g;
    $template =~ s!%%itemname_plural%%!$PREF{"${viewerprefname}_viewer_item_name_plural"}!g;
	
    if (get_qs_var('srchvrfymode') eq 'true') {
      my $go = $there_were_some_results ? $PREF{"${viewerprefname}_search_verify_mode_redirection_url_for_matches"} : $PREF{"${viewerprefname}_search_verify_mode_redirection_url_for_misses"};;
      my %searchterms = ();
      while ($qs =~ /(?:^|&)srch[123]_([^=]+)=([^&]+)/g) {
        $searchterms{$1} = $2;
      }
      $go =~ s!%%(\w+)%%!$searchterms{$1}!g;
      if ($go) {
        enc_redirect($go);
      } else {
        my $srchmatch = $TEXT{db_search_verify_mode_match_text} || qq`Your search found a match.`;
        my $srchmiss = $TEXT{db_search_verify_mode_miss_text} || qq`Your search found no match.`;
        exit_with_notice($there_were_some_results ? $srchmatch : $srchmiss);
      }
    }

    # This is down here, instead of further up, because we want to allow the allowed_to_search
    # permission to allow access in the case where the search is just returning a matched/failed
    # result (not returning any actual database rows for viewing).  For example, in the situation
    # where a customer needs to be able to look up a license number, registration code, coupon
    # code, etc, and the site owner wants to allow that, but only for verification purposes, not
    # to display the database search result rows to the customer.
    #
    exit_with_needprivs() unless $allowed_to_view;

    return $template;
  }


sub send_notification_emails_for_database_update($)
  {
    my $details_ref = shift; my %details = %$details_ref;

    my $viewerprefname	= $details{viewerprefname};
    my $recipients		= $PREF{"${viewerprefname}_emailalert_recipients"};
    my $from		= $PREF{"${viewerprefname}_emailalert_sender"};
    my $subject		= $PREF{"${viewerprefname}_emailalert_subject"};
    my $body		= $PREF{"${viewerprefname}_emailalert_body"};
    my $format		= $PREF{"${viewerprefname}_emailalert_type"};
    my $failure_action	= $PREF{"${viewerprefname}_emailalert_failure_action"};

    my $changes_rows = '';
    if ($details{changed_record}) {
      foreach my $col_i (sort { $a <=> $b } keys %{$details{changed_record}}) {
        my $changes_template = $PREF{"${viewerprefname}_emailalert_changes_template"};
        $changes_template =~ s!%%column%%!$details{changed_record}{$col_i}{column}!g;
        $changes_template =~ s!%%old_value%%!$details{changed_record}{$col_i}{old_value}!g;
        $changes_template =~ s!%%new_value%%!$details{changed_record}{$col_i}{new_value}!g;
        $changes_rows .= $changes_template;
      }
    }

    my $all_rows = '';
    my $sorted_column_list = '';
    my $whole_record = $details{deleted_record} || $details{created_record} || $details{whole_changed_record};
    foreach my $col (sort { lc($a) cmp lc($b) } keys %{$$whole_record{1}}) {
      $sorted_column_list .= "$col," unless $PREF{"${viewerprefname}_emailalert_fields_to_hide"} =~ /(^|,)\s*$col\s*(,|$)/;
    }
    $sorted_column_list = $PREF{"${viewerprefname}_emailalert_fields_to_show"} if $PREF{"${viewerprefname}_emailalert_fields_to_show"};
    decommaify($sorted_column_list);
    foreach my $col (split(/\s*,\s*/, $sorted_column_list)) {
      my $allrows_template = $PREF{"${viewerprefname}_emailalert_record_template"};
      $allrows_template =~ s!%%column%%!$col!g;
      $allrows_template =~ s!%%value%%!$$whole_record{1}{$col}!g;
      $all_rows .= $allrows_template;
    }

    $body =~ s!%%username%%!$PREF{logged_in_username} || '(unknown)'!eg;
    $body =~ s!%%action%%!$details{action}!g;
    $body =~ s!%%action_pasttense%%!$details{action_pasttense}!g;
    $body =~ s!%%table%%!$details{table}!g;
    $body =~ s!%%record_id%%!$details{record_id}!g;
    $body =~ s!%%db_url%%!$PREF{"${viewerprefname}_viewer_db_url"}!g;
    $body =~ s!%%db_url_full%%!$PREF{"${viewerprefname}_viewer_db_url_full"}!g;
    $body =~ s!%%changes%%!$PREF{"${viewerprefname}_emailalert_changes_header"}$changes_rows!g;
    $body =~ s!%%record%%!$PREF{"${viewerprefname}_emailalert_record_header"}$all_rows!g;

    $body =~ s!%%%if-edit%%%(.*?)%%%endif-edit%%%!$details{action} eq 'edit' ? $1 : $2!egs;
    $body =~ s!%%%ifelse-deletion%%%(.*?)%%%else%%%(.*?)%%%endelse-deletion%%%!$details{action} eq 'delete' ? $1 : $2!egs;
	
    foreach my $to (split(/\s*,\s*/, $recipients)) {
      if ($to eq 'all_members_of_the_loggedin_users_custom_groups') {
        foreach my $to_inner (get_email_addresses_for_all_members_of_this_users_groups($PREF{logged_in_userid})) {
          send_email($to_inner, $from, $subject, $body, $format, $failure_action);
        }
      } else {
        send_email($to, $from, $subject, $body, $format, $failure_action);
      }
    }
  }


sub get_return_url_for_dbviewer($)
  {
    my $return_url_base = shift;
    my $qsl = $qs;
    $qsl =~ s!format=(horiz|vert)!!g if $qsl =~ /format=horiz/i && $qsl =~ /format=vert/i; # if both are present, remove both.
    $qsl =~ s!format=vert!!; # we always add 1 format=vert on the way to this page, so we should always remove 1 on the way back out.
    $qsl =~ s!editdelete=true!!g;
    $qsl =~ s!editmode=true!!g;
    $qsl =~ s!editid=\d+!!g;
    $qsl =~ s!createmode=true!!g;
    defooify('&',$qsl);
    return $return_url_base . ($qsl ? "?$qsl" : '');
  }


sub datatype_is_bool($$)
  {
    my ($table,$column) = @_;
    my $datatype = get_field_datatype($table,$column);
    return $datatype =~ /^(bool|tinyint\(1\))/i;
  }


sub get_field_datatype($$)
  {
    my ($table,$column) = @_;
    sql_untaint($table,$column);
    die_unless_sqlsafe($table,$column);

    # This fails on some older MySQL versions, which apparently don't allow the WHERE clause
    # on the SHOW COLUMNS query.  So we'll have to return all columns and manually search them.
    #my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table` WHERE `field` = '$column'");
    #return $$coltypetest{1}{Type} || $$coltypetest{1}{type};

    my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table`");
    foreach my $j (keys %$coltypetest) {
      return ($$coltypetest{$j}{Type} || $$coltypetest{$j}{type}) if ($$coltypetest{$j}{Field} =~ /^$column$/i || $$coltypetest{$j}{field} =~ /^$column$/i);
    }
  }


sub get_field_details_from_db($$)
  {
    my ($table,$column) = @_;
    sql_untaint($table,$column);
    die_unless_sqlsafe($table,$column);

    my %details = ();
    my $coltypetest = enc_sql_select_multi("SHOW COLUMNS FROM `$table`");
    foreach my $j (keys %$coltypetest) {
      if ($$coltypetest{$j}{Field} =~ /^$column$/i || $$coltypetest{$j}{field} =~ /^$column$/i) {
        $details{type}		= exists $$coltypetest{$j}{Type}	? $$coltypetest{$j}{Type}	: $$coltypetest{$j}{type};
        $details{null}		= exists $$coltypetest{$j}{Null}	? $$coltypetest{$j}{Null}	: $$coltypetest{$j}{null};
        $details{key}		= exists $$coltypetest{$j}{Key}		? $$coltypetest{$j}{Key}	: $$coltypetest{$j}{key};
        $details{default}	= exists $$coltypetest{$j}{Default}	? $$coltypetest{$j}{Default}	: $$coltypetest{$j}{default};
        $details{extra}		= exists $$coltypetest{$j}{Extra}	? $$coltypetest{$j}{Extra}	: $$coltypetest{$j}{extra};
		 	
        # For integer types, the returned value will be something like one of the following:
        #
        #	bigint(20)
        #	int(10) unsigned
        #
        # But the number in parentheses is added by MySQL automatically (i.e. even when you
        # don't specify it when creating the column, which you wouldn't in most cases), and
        # it is NOT an indicator of the field size, as the MySQL manual explains:
        #
        #	http://dev.mysql.com/doc/refman/5.0/en/numeric-types.html
        #	
        #	Numeric Type Attributes
        #	
        #	MySQL supports an extension for optionally specifying the display width of
        #	integer data types in parentheses following the base keyword for the type.
        #	For example, INT(4) specifies an INT with a display width of four digits.
        #	This optional display width may be used by applications to display integer
        #	values having a width less than the width specified for the column by
        #	left-padding them with spaces. (That is, this width is present in the
        #	metadata returned with result sets. Whether it is used or not is up to the
        #	application.)
        #	
        #	The display width does *not* constrain the range of values that can be stored
        #	in the column. Nor does it prevent values wider than the column display width
        #	from being displayed correctly. For example, a column specified as
        #	SMALLINT(3) has the usual SMALLINT range of -32768 to 32767, and values
        #	outside the range permitted by three digits are displayed in full using more
        #	than three digits. 
        #	
        # Therefore, for our purposes here, where in 99% of cases we didn't specify this number
        # explicitly, and therefore it's meaningless in the context of determining whether the
        # column type has changed, we will remove this number.
        #
        $details{type} =~ s!int\(\d+\)!int!;
		 	
        return \%details;
      }
    }
  }


sub get_field_details_from_creation_string($)
  {
    my ($creation_string) = @_;

    my %details = ();
    $details{type}		= ($creation_string =~ m!^(\S+( unsigned)?)!i)[0];
    $details{null}		= $creation_string =~ m!not null!i ? 'NO' : 'YES';
    $details{key}		= $creation_string =~ m!primary key!i ? 'PRI' : ''; # TODO: add detection of other key types.
    $details{default}	= $creation_string =~ m!default (\S+)!i ? $1 : ''; # TODO: some types have a default DEFAULT value other than NULL.
    $details{extra}		= $creation_string =~ m!auto_increment!i ? 'auto_increment' : ''; # TODO: potentially lots of other stuff here.
 	
    $details{type} =~ s!int\(\d+\)!int!; # see note in the get_field_details_from_db() sub.

    $details{default} =~ s!^'(.*)'$!$1!; # In case the specified default value is quoted, remove
    $details{default} =~ s!^"(.*)"$!$1!; # the quotes before actually using/comparing the value.
	 	
    return \%details;
  }


sub field_datatype_has_changed($$$)
  {
    my ($table,$fieldname,$creation_string) = @_;
    my $new_fieldtype = get_field_details_from_creation_string($creation_string);
    my $old_fieldtype = get_field_details_from_db($table,$fieldname);
	
    my $changed = 0;
    my ($old,$new) = ();
    foreach my $attrib (sort keys %$old_fieldtype) {
      $changed = 1 if lc($$old_fieldtype{$attrib}) ne lc($$new_fieldtype{$attrib});
      $old .= "old $attrib: " . lc($$old_fieldtype{$attrib}) . "; ";
      $new .= "new $attrib: " . lc($$new_fieldtype{$attrib}) . "; ";
    }

    if ($changed) {
      encdebug "datatype has changed for '$fieldname':\nold=$old\nnew=$new\n";
      return 1;
    } else {
      encdebug "datatype has NOT changed for '$fieldname':\nold=$old\nnew=$new\n";
      return 0;
    }
  }


sub clean_database_url
  {
    $_[0] =~ s!format=(horiz|vert)!!g if $_[0] =~ /format=horiz/ && $_[0] =~ /format=vert/; # if both are present, remove all.
    for ('horiz','vert') {
      if ($_[0] =~ /format=$_/) {
        $_[0] =~ s!format=$_!!g; $_[0] .= "&format=$_";
      }               # condense multiple occurrences of the same one.
    }
    $_[0] =~ s!\?&+!?!g;
  }


sub verify_new_database_value($$$$$$)
  {
    # Notes:
    #
    #	_viewer_unique_values and _viewer_unique_values_ignorecase require that
    # 	the table has a column called "id" which is unique and not null.
    #

    my ($dbtable,$viewerprefname,$column,$value,$rowid,$all_fields) = @_;
    sql_untaint($value,$column);
    die_unless_sqlsafe($value,$column);

    if (exists $PREF{"${viewerprefname}_viewer_unique_values"}{lc($column)}) {
      if ($rowid =~ /^\d+$/)    # edit mode.
        {
          if (enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE `$column` = '$value' AND `id` != $rowid")) {
            exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
          }
        } else                  # add-new-record mode.
          {
            if (enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE `$column` = '$value'")) {
              exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
            }
          }
    }

    if (exists $PREF{"${viewerprefname}_viewer_unique_values_ignorecase"}{lc($column)}) {
      if ($rowid =~ /^\d+$/)    # edit mode.
        {
          if (enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE LOWER(`$column`) = LOWER('$value') AND `id` != $rowid")) {
            exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
          }
        } else                  # add-new-record mode.
          {
            if (enc_sql_select("SELECT COUNT(*) FROM `$dbtable` WHERE LOWER(`$column`) = LOWER('$value')")) {
              exit_with_error(qq`Error: '$column' must be unique, but the one you entered ('$value') already exists.`);
            }
          }
    }

    # 201001: APICHANGE: $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)} was a string; now it's a hash.
    #
    if (exists $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)}) {
      foreach my $testnum (keys %{ $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)} }) {
        my $code = $PREF{"${viewerprefname}_viewer_value_verifications"}{lc($column)}{$testnum};
        if ($code =~ /^preset:(.+)/) {
          foreach my $preset (split(/\s*,\s*/, $1)) {
            my ($error,%vars) = ('',());
            if (($preset eq 'nonnull')		&& (!$value && ($value !~ /^0$/))) {
              $error = $TEXT{Error_input_null};
            } elsif (($preset eq 'alnum')		&& ($value !~ /^[[:alnum:]]*$/)) {
              $error = $TEXT{Error_input_not_alnum};
            } elsif (($preset eq 'word')		&& ($value !~ /^\w*$/)) {
              $error = $TEXT{Error_input_not_word};
            } elsif (($preset eq 'numeric')		&& ($value !~ /^\d*$/)) {
              $error = $TEXT{Error_input_not_numeric};
            } elsif (($preset =~ /^minvalue=(\d+)$/)	&& ($value < $1)) {
              $error = $TEXT{Error_input_too_small}; $vars{min} = $1;
            } elsif (($preset =~ /^maxvalue=(\d+)$/)	&& ($value > $1)) {
              $error = $TEXT{Error_input_too_large}; $vars{max} = $1;
            } elsif (($preset =~ /^minlength=(\d+)$/)	&& (length($value) < $1)) {
              $error = $TEXT{Error_input_too_short}; $vars{min} = $1;
            } elsif (($preset =~ /^maxlength=(\d+)$/)	&& (length($value) > $1)) {
              $error = $TEXT{Error_input_too_long}; $vars{max} = $1;
            }
            #print STDERR "column=$column, value=$value, preset=$preset, error=$error\n";

            if ($error) {
              $error =~ s/%%encfieldname%%/$column/g; $error =~ s/%%(\w+)%%/$vars{$1}/g; kmsg_redirect($error);
            }
          }
        } else {
          $code =~ s/%%variable%%/\$value/g;
          $code =~ s/%%encfieldname%%/$column/g;
          $code =~ s/%%(\w+)%%/$$all_fields{$1}/g;
          eval $code;           # modified $value directly.
          die $@ if $@;  # in case the custom code had an error in it.
          # die_from_eval: can accept a whole literal message, or "smsg_foo" which maps to $TEXT{smsg_foo} -- where possible, use static messages rather than keyed messages.
          if ($value =~ /die_from_eval:(.*)/) {
            my $msg = $1; $msg =~ m!^smsg_(.+)! ? smsg_redirect($1) : kmsg_redirect($msg);
          }
        }
      }
    }
  }


sub transform_value_according_to_code
  {
    my $dbtable		= shift;
    my $value		= shift;
    my $values		= shift; # hashref
    my $code		= shift;
    my $column		= shift;
    my $pass		= shift;
    my $already_transformed = shift; # hashref.

    if ($code =~ /^preset:(.+)/) {
      foreach my $preset (split(/\s*,\s*/, $1)) {
        if ($preset eq 'make_lowercase') {
          $value = lc($value);
        } elsif ($preset eq 'make_uppercase') {
          $value = uc($value);
        } elsif ($preset eq 'remove_nonalnum') {
          $value =~ s![^[:alnum:]]!!g;
        } elsif ($preset eq 'date8') {
          $value = strftime("%Y%m%d",localtime(offsettime()));
        } elsif ($preset eq 'date17') {
          $value = strftime("%Y%m%d-%H:%M:%S",localtime(offsettime()));
        } elsif ($preset eq 'etime') {
          $value = offsettime();
        } elsif ($preset eq 'next_int_if_null_or_zero' && !$value) {
          $value = enc_sql_select("SELECT MAX(`$column`) FROM `$dbtable`") =~ /^(\d+)$/ ? $1 : 0; $value++;
        }

        #print STDERR "column=$column, value=$value, preset=$preset\n";
      }
      $$values{$column} = $value;
    } else {
      $code =~ s/%%variable%%/\$value/g;
      $code =~ s/%%(\w+)%%/exists $$values{$1} || $pass==2 ? $$values{$1} : $&/eg;
      if ($code !~ /%%\w+%%/ || $pass==2) {
        if (!$$already_transformed{$column}) {
          $$already_transformed{$column} = 1;
          eval $code;           # modifies $value directly.
          $$values{$column} = $value;
        }
      }
    }
  }


sub get_pagination_range($)
  {
    my $items_per_page = $_[0];
    my $page_num = $qs =~ /(?:^|&)page=(\d+)(?:&|$)/ ? $1 : 1;
    my $range_start = ($items_per_page * ($page_num - 1)) + 1; # $range_start = 1 if $range_start < 1; # negative check not necessary if $page_num is guaranteed to be >= 1.
    my $range_end = $items_per_page * $page_num;
    my $sql_range_start = $range_start - 1; # because SQL's LIMIT is zero-based.

    ($range_start,$range_end,$sql_range_start) = (1,999999999,0) if $qs =~ /(?:^|&)pagination=off(?:&|$)/;

    # We need to adjust itemsperpage (in the caller), not just the range start & end, when
    # pagination=off, because SQL's 'LIMIT' uses range_start & itemsperpage (not range_end).
    $_[0] = 999999999 if $qs =~ /(?:^|&)pagination=off(?:&|$)/;

    return ($range_start,$range_end,$sql_range_start);
  }


sub get_pagination_links_mark2
  {
    ## first 4 args are mandatory; rest are optional.
    #my ($range_start, $range_end, $num_items, $items_per_page,
    #	$itemname_singular,
    #	$itemname_plural,
    #	$pagename_singular,
    #	$pagename_plural,
    #	$template,
    #	$num_pagelinks,
    #	$viewall_template
    #) = @_;
    #
    # 20110226: APICHANGE: args for this sub are now hash-based:
    #
    my $optsref = shift; my %opts = %$optsref if $optsref;

    $opts{template} ||= qq`
		<div class="pagelinks">
			<div class="text">
			<span class="bookend">{</span>%%num_items%% %%itemname%% on %%num_pages%% %%pagename%%.
			%%%if-show_opts_links%%%
				&nbsp;Options: &nbsp; %%alllink%% %%%if-show_sort_links%%%&nbsp; %%quicksortlink%% %%%end-show_sort_links%%%
			%%%end-show_opts_links%%%
			<span class="bookend">}</span>
			</div>

			%%%if-multiple_pages%%%
			<div class="links">
			%%%ifelse-frstlink%%% <a href="%%frstlink%%" class="first">&lt;&lt;</a>	%%%else%%% <span class="disabled first">&lt;&lt;</span>	%%%endelse-frstlink%%% %%spc%%
			%%%ifelse-prevlink%%% <a href="%%prevlink%%">&lt;</a>			%%%else%%% <span class="disabled">&lt;</span>		%%%endelse-prevlink%%% %%spc%%

			%%%template:linklist%%%
				%%%ifelse-currentpage%%%
					<span class="current">%%pagenum%%</span> %%spc%%
				%%%else%%%
					<a href="%%link%%">%%pagenum%%</a> %%spc%%
				%%%endelse-currentpage%%%
			%%%end-template:linklist%%%

			%%%ifelse-nextlink%%% <a href="%%nextlink%%">&gt;</a>			%%%else%%% <span class="disabled">&gt;</span>		%%%endelse-nextlink%%% %%spc%%
			%%%ifelse-lastlink%%% <a href="%%lastlink%%" class="last">&gt;&gt;</a>	%%%else%%% <span class="disabled last">&gt;&gt;</span>	%%%endelse-lastlink%%%
			</div>
			%%%end-multiple_pages%%%
		</div>
	`;

    $opts{viewall_template} ||= qq`
		<div class="pagelinks">
		(Viewing all %%num_items%% %%itemname%%.&nbsp; <a href="%%pageslink%%">View individual pages?</a>)
		</div>
	`;

    $opts{itemname_singular}	||= $TEXT{item}		|| 'item';
    $opts{itemname_plural}		||= $TEXT{items}	|| 'items';
    $opts{pagename_singular}	||= $TEXT{page}		|| 'page';
    $opts{pagename_plural}		||= $TEXT{pages}	|| 'pages';
    $opts{num_pagelinks}		||= 8;
    my $spacer			= $PREF{pagination_links_spacer} || '';

    my $num_pages = int($opts{num_items}/$opts{items_per_page});
    $num_pages++ if $num_pages < ($opts{num_items}/$opts{items_per_page});
    return '' if $opts{hide_when_single_page} && $num_pages =~ /^(0|1)$/ && get_qs_var('pagination') ne 'off';

    my $viewall_active	= (get_qs_var('pagination') eq 'off') || ($num_pages == 1);
    my $viewall_unclickable	= (get_qs_var('pagination') ne 'off') && ($num_pages == 1);

    my ($link_template) = ($opts{template} =~ m!%%%template:linklist%%%(.+?)%%%end-template:linklist%%%!gs);
    my $link_template_output = '';
    my %pagelinks = ();

    #if($qs =~ /pagination=off/)
    #if($viewall_active)
    if (0) {
      my $uri = $ENV{REQUEST_URI};
      $uri =~ s/pagination=off//g;
      defooify('&', $uri);
      $opts{viewall_template} =~ s!%%pageslink%%!$uri!g;
      $opts{viewall_template} =~ s!%%num_items%%!$opts{num_items}!g;
      $opts{viewall_template} =~ s!%%itemname%%!$opts{num_items} == 1 ? $opts{itemname_singular} : $opts{itemname_plural}!eg if $opts{itemname_singular} && $opts{itemname_plural};
      return $opts{viewall_template};
    }
    #elsif($opts{range_start} != 1   ||   $opts{num_items} > $opts{range_end})
    elsif (1) {
      my $uri = $ENV{REQUEST_URI};

      # Remove any existing phase/resultmsg, and page number, from the
      # URI, because we don't want to include those on each new page.
      #
      $uri =~ s/(\?|&)page=(\d+)/$1/g;
      $uri =~ s/(\?|&)phase=(\w+)/$1/g;
      $uri =~ s/(\?|&)rsltmsg=(\w+)/$1/g;

      my $uri_for_quicksort_link = my $uri_for_pagination_link = $uri;
      $uri_for_quicksort_link =~ s/(\?|&)quicksort=(on|off)/$1/g;
      $uri_for_pagination_link =~ s/(\?|&)pagination=(on|off)/$1/g;

      for ($uri, $uri_for_quicksort_link, $uri_for_pagination_link) {
        $_ .= '?' unless $_ =~ /\?/;
        $_ .= '&' if $_ =~ /\?.+/ && $_ !~ /&$/;
        $_ =~ s/&{2,}/&/g;
        $_ =~ s/\?&/?/g;
      }

      my $current_page = 1;
      for (my $j = 1; $j <= $num_pages; $j++) {
        my $is_currentpage = ($ENV{REQUEST_URI} =~ /page=$j/ || ($ENV{REQUEST_URI} !~ /page=\d+/ && $j==1));
        $current_page = $j if $is_currentpage;

        my $link_template_local = $link_template;
        $link_template_local =~ s!%%pagenum%%!$j!g;
        $link_template_local =~ s!%%link%%!${uri}page=$j!g;
        $link_template_local =~ s!%%%ifelse-currentpage%%%(.*?)%%%else%%%(.*?)%%%endelse-currentpage%%%!$is_currentpage ? $1 : $2!egs;
        $pagelinks{$j} = $link_template_local;
      }

      foreach my $page (sort { $a <=> $b } keys %pagelinks) {
        $link_template_output .= $pagelinks{$page} if (($page - int($opts{num_pagelinks}/2 + .5)) <= $current_page) && ($current_page <= ($page + int($opts{num_pagelinks}/2 + .5)));
      }

      my $prevlink = $current_page > 1 ? $current_page - 1 : 1;
      my $nextlink = $current_page < $num_pages ? $current_page + 1 : $num_pages;
      $opts{template} =~ s!%%prevlink%%!${uri}page=$prevlink!g;
      $opts{template} =~ s!%%nextlink%%!${uri}page=$nextlink!g;
      $opts{template} =~ s!%%alllink%%!$viewall_unclickable ? qq`<span class="disabled">view all</span>` : $viewall_active ? qq`<a href="${uri_for_pagination_link}">view pages</a>` : qq`<a href="${uri_for_pagination_link}pagination=off">view all</a>`!eg;
      $opts{template} =~ s!%%quicksortlink%%!quicksort_is_active() ? qq`<a href="${uri_for_quicksort_link}quicksort=off">server-sort</a>` : qq`<a href="${uri_for_quicksort_link}quicksort=on">quick-sort</a>`!eg;
      $opts{template} =~ s!%%%if-show_opts_links%%%(.*?)%%%end-show_opts_links%%%!$opts{hide_opts_links} ? '' : $1!egs;
      $opts{template} =~ s!%%%if-show_sort_links%%%(.*?)%%%end-show_sort_links%%%!$opts{hide_sort_links} ? '' : $1!egs;
      $opts{template} =~ s!%%%ifelse-prevlink%%%(.*?)%%%else%%%(.*?)%%%endelse-prevlink%%%!$current_page ne 1 ? $1 : $2!egs;
      $opts{template} =~ s!%%%ifelse-nextlink%%%(.*?)%%%else%%%(.*?)%%%endelse-nextlink%%%!$current_page ne $num_pages ? $1 : $2!egs;
      $opts{template} =~ s!%%%if-multiple_pages%%%(.*?)%%%end-multiple_pages%%%!$num_pages > 1 ? $1 : ''!egs;

      $opts{template} =~ s!%%frstlink%%!${uri}page=1!g;
      $opts{template} =~ s!%%lastlink%%!${uri}page=$num_pages!g;
      $opts{template} =~ s!%%%ifelse-frstlink%%%(.*?)%%%else%%%(.*?)%%%endelse-frstlink%%%!$current_page ne 1 ? $1 : $2!egs;
      $opts{template} =~ s!%%%ifelse-lastlink%%%(.*?)%%%else%%%(.*?)%%%endelse-lastlink%%%!$current_page ne $num_pages ? $1 : $2!egs;

      $opts{template} =~ s!%%%template:linklist%%%(.+?)%%%end-template:linklist%%%!$link_template_output!gs;
      $opts{template} =~ s!%%spc%%!$spacer!g;
      $opts{template} =~ s!%%num_items%%!$opts{num_items}!g;
      $opts{template} =~ s!%%num_pages%%!$num_pages!g;
      $opts{template} =~ s!%%itemname%%!$opts{num_items} == 1 ? $opts{itemname_singular} : $opts{itemname_plural}!eg if $opts{itemname_singular} && $opts{itemname_plural};
      $opts{template} =~ s!%%pagename%%!$num_pages == 1 ? $opts{pagename_singular} : $opts{pagename_plural}!eg if $opts{pagename_singular} && $opts{pagename_plural};

      return $opts{template};
    } else {
      return '';
    }
  }


sub quicksort_is_active
  {
    return (get_qs_var('quicksort') eq 'on') || ($PREF{enable_quicksort_by_default} =~ /yes/i && get_qs_var('quicksort') ne 'off');
  }


sub field_structure_managed_by_us
  {
    my $field = shift;
    foreach my $table (keys %{$PREF{tables_listing_fields_whose_structure_we_manage}}) {
      sql_untaint($field,$table);
      die_unless_sqlsafe($field,$table);
      my $query = "SELECT `fieldtype`,`fieldlabel`,`listitems`,`defaultvalue` FROM `$table` WHERE `fieldname` = '$field'";
      #enc_warn "query=$query\n";

      if (my ($fieldtype,$label,$listitems,$defaultvalue) = enc_sql_select($query)) {
        #enc_warn qq`fieldtype,label,listitems,defaultvalue = $fieldtype,$label,$listitems,$defaultvalue\n`;
        if ($fieldtype =~ /^(freeformsingle|freeformmulti|dropdown|checkbox|radio)$/) {
          return ($fieldtype,$label,$listitems,$defaultvalue);
        } else {
          return ();
        }
      }
    }
  }


sub is_valid_email_address
  {
    return $_[0] =~ /^[\w\.\+-]+\@[\w\.-]+\.\w+$/;
  }


sub is_ipv4_address
  {
    return $_[0] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  }


sub interpolate_vars_from_URL_and_cookies
  {
    my $include_undefined = 0;
    my $sql_sanitize = 0;

    my %url_vars = ();
    for (split(/&/, $qs)) {
      my ($var,$value) = split(/=/);
      enc_urldecode($value);
      $url_vars{$var} = $value;
    }

    my %cookies = ();
    my %jar = get_cookies();
    foreach my $ck (keys %jar) {
      $cookies{$ck} = $jar{$ck}->value;
    }

    for (@_) {
      $include_undefined = $_ if $_ eq 'include_undefined';
      $sql_sanitize = $_ if $_ eq 'sql_sanitize';

      next unless m!(%URL{|%COOKIE{)!;

      if ($sql_sanitize) {
        my %done = ();
        while (m!%URL\{([^\{\}]+)\}!g) {
          my $varname = $1;
          if (exists $url_vars{$varname}   &&   !$done{$varname}) {
            sql_untaint($url_vars{$varname});
            replace_nonsqlsafe_chars_with('_', $url_vars{$varname});
            die_unless_sqlsafe($url_vars{$varname});
            $done{$varname} = 1;
          }
        }

        %done = ();
        while (m!%COOKIE\{([^\{\}]+)\}!g) {
          my $varname = $1;
          if (exists $cookies{$varname}   &&   !$done{$varname}) {
            sql_untaint($cookies{$varname});
            replace_nonsqlsafe_chars_with('_', $cookies{$varname});
            die_unless_sqlsafe($cookies{$varname});
            $done{$varname} = 1;
          }
        }
      }

      s!%URL\{([^\{\}]+)\}!exists $url_vars{$1} || $include_undefined ? $url_vars{$1} : $&!eg;
      s!%COOKIE\{(.+?)\}!exists $cookies{$1} || $include_undefined ? $cookies{$1} : $&!eg;
    }
  }


sub interpolate_vars_from_prefs
  {
    my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0; # 1st arg may be 'include_undefined' but does not have to be.
    for (@_) {
      s/%PREF{(\w+)}/exists $PREF{$1} || $include_undefined ? $PREF{$1} : $&/eg;
      s/%TEXT{(\w+)}/exists $TEXT{$1} || $include_undefined ? $TEXT{$1} : $&/eg;
    }
  }


sub interpolate_vars_from_env
  {
    my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0; # 1st arg may be 'include_undefined' but does not have to be.
    for (@_) {
      s/%ENV{(\w+)}/exists $ENV{$1} || $include_undefined ? $ENV{$1} : $&/eg;
    }
  }


sub interpolate_vars_from_sql
  {
    my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0; # 1st arg may be 'include_undefined' but does not have to be.
    for (@_) {
      while (m!(%SQL\{\{(.+?)\}\})!g) {
        my ($wholething,$sql_statement) = ($1,$2);
        get_db_connection() unless $PREF{dbh};
        interpolate_vars_from_URL_and_cookies($include_undefined, 'sql_sanitize', $sql_statement);
        my $output = enc_sql_select($sql_statement);
        s!\Q$wholething\E!$output!g;
      }
    }
  }


sub interpolate_vars_from_date
  {
    my $include_undefined = $_[0] eq 'include_undefined' ? shift : 0; # 1st arg may be 'include_undefined' but does not have to be.
    my $etime = $_[0] =~ /^etime=(\d+)$/ ? shift : offsettime();
    $etime =~ s/[^\d]//g;
    s!%DATE{(.+?)}{now([\+-]\d+[smhdb])}!strftime($1,localtime(offset_etime($etime,$2)))!eg for @_;
    s!%DATE{(.+?)}!strftime($1,localtime($etime))!eg for @_;
  }


sub do_standard_template_conditionals_processing
  {
    for (@_) {
      s!%%%if-admin_is_logged_in%%%(.*?)%%%end-admin_is_logged_in%%%!$PREF{admin_is_logged_in} ? $1 : ''!egs;
      s!%%%if-admin_not_logged_in%%%(.*?)%%%end-admin_not_logged_in%%%!$PREF{admin_is_logged_in} ? '' : $1!egs;
      s!%%%ifelse-admin_is_logged_in%%%(.*?)%%%else%%%(.*?)%%%endelse-admin_is_logged_in%%%!$PREF{admin_is_logged_in} ? $1 : $2!egs;

      s!%%%if-member_is_logged_in%%%(.*?)%%%end-member_is_logged_in%%%!$PREF{member_is_logged_in} ? $1 : ''!egs;
      s!%%%if-member_not_logged_in%%%(.*?)%%%end-member_not_logged_in%%%!$PREF{member_is_logged_in} ? '' : $1!egs;
      s!%%%ifelse-member_is_logged_in%%%(.*?)%%%else%%%(.*?)%%%endelse-member_is_logged_in%%%!$PREF{member_is_logged_in} ? $1 : $2!egs;

      s!%%%if-member_of_group_([^%]+)%%%(.*?)%%%end-member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $2 : ''!egs;
      s!%%%if-not_member_of_group_([^%]+)%%%(.*?)%%%end-not_member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? '' : $2!egs;

      s!%%%ifelse-member_of_group_([^%]+)%%%(.*?)%%%else%%%(.*?)%%%endelse-member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $2 : $3!egs;
      s!%%%ifelse-not_member_of_group_([^%]+)%%%(.*?)%%%else%%%(.*?)%%%endelse-not_member_of_group_\1%%%!user_is_member_of_group($PREF{logged_in_userid}, $1) ? $3 : $2!egs;

      s!%%%if-allowed_to_(\w+)%%%(.*?)%%%end-allowed_to_\1%%%!user_is_allowed_to($1) ? $2 : ''!egs;
      s!%%%ifelse-allowed_to_(\w+)%%%(.*?)%%%else%%%(.*?)%%%endelse-allowed_to_\1%%%!user_is_allowed_to($1) ? $2 : $3!egs;
    }
  }


sub do_standard_template_vars_processing
  {
    interpolate_vars_from_sql(@_); # do this one first, so we can SQL-sanitize any nested URL/cookie variables and interpolate them manually, rather than letting the following functions do the regular interpolation with no SQL-sanitization.
    interpolate_vars_from_env(@_);
    interpolate_vars_from_prefs(@_);
    interpolate_vars_from_URL_and_cookies(@_);
    interpolate_vars_from_date(@_);
  }


sub do_standard_template_leftover_nulling
  {
    # Go in order from most specific to least specific.  For example, %%%set...%%%
    # is near the end, because it can contain spaces, so we need to make the
    # regex a little looser to match it.  And we explicitly match %%\w+%% even
    # though we later have a more generic %%[^%\s]+?%% because removing the
    # simple all-alphanumeric vars first makes it more straightforward to match
    # the more varied possibilities later.

    for (@_) {
      s!%%%if-(\S+)%%%.+?%%%end-\1%%%!!gs;
      s!%%%ifelse-(\S+)%%%.*?%%%else%%%.*?%%%endelse-\1%%%!!gs;
      s!%%%calculate:([^%]+)%%%.+?%%%end-calculate%%%!!gs;
      s!%%%customcode(:[^%]+)?%%%.+?%%%end-customcode%%%!!gs;
      s!%%\w+%%!!g;
      #s!%%[^%\s]+?%%!!g;
      s!%%%set[^%]+?%%%!!g;
    }
  }


sub do_standard_template_oddeven_processing # make this your last template-processing action, so any %%oddeven%%s present will definitely be present in the output.
  {
    for (@_) {
      my $i = 0; while(/%%oddeven%%/g) { s!%%oddeven%%!oddeven($i)!e; }
    }
  }


# This sub is designed to skip any interpolations that are currently null and/or
# whose values have other raw template variables within them.  This allows the
# template's various operations and variables to be nested in arbitrarily deep
# and complex ways.  Because of this, the sub iterates multiple times, since
# items that were skipped on earlier passes will be able to be processed on
# later passes.
#
sub do_custom_template_processing
  {
    my $templatevars = shift;   # hashref.
    for (my $i=0; $i<8; $i++) {
      for (@_) {
        s!%%%if-([^%]+)==([^%]+)%%%(.*?)%%%end-\1==\2%%%!$1 eq $2 ? $3 : ''!egs;

        s!%%%if-is_valid_price_([^%]+)%%%(.*?)%%%end-is_valid_price_\1%%%!item_price_is_valid($1) ? $2 : ''!egs;

        #while(m!\s*%%%set-urlencoded:(\w+)=([^%]*)%%%\s*!g)
        #{
        #	my ($name,$val) = ($1,$2);
        #	enc_urlencode($val);
        #	$$templatevars{$name} = $val;
        #}

        $$templatevars{$1} = $2 while $_ =~ m!\s*%%%set:(\w+)=([^%]*)%%%\s*!g;
        s!%%(\w+?)%%!exists $$templatevars{$1} ? $$templatevars{$1} : $&!eg;
        s!%%(\w+?)_urlencoded%%!exists $$templatevars{$1} ? enc_urlencode_return($$templatevars{$1}) : $&!eg;

        while (m!(%%%calculate:([^%]+)%%%\s*(.+?)\s*%%%end-calculate%%%)!gs) {
				#die "code is: '$3', wholething is: '$1'";
          my ($wholething,$options,$code) = ($1,$2,$3);

          next if $code =~ /%%\w+%%/; # skip it if it still has unprocessed variables in it.

          my $output = eval $code;
          exit_with_error($1) if $output =~ /die_from_eval:(.*)/;
          my $outputvarname = '';

          for (split(/\s*,\s*/, $options)) {
            if (/numdecimals=(\d+)/) {
              my $numdec = $1;
              $output =~ s/(\.\d{$numdec})\d+$/$1/;
              $output .= '.' unless $output =~ /\.\d*$/;
              $output .= '0' while length(   ($output =~ /\.(\d*)$/)[0]   ) < $numdec;
            } elsif (/varname=(\w+)/) {
              $outputvarname = $1;
            }
          }

          s!\Q$wholething\E!%%%set:$outputvarname=$output%%%!s;
        }

        while (m!(%%%customcode(:[^%]+)?%%%\s*(.+?)\s*%%%end-customcode%%%)!gs) {
				#die "code is: '$3', wholething is: '$1'";
          my ($wholething,$options,$code) = ($1,$2,$3);

          next if $code =~ /%%\w+%%/; # skip it if it still has unprocessed variables in it.

          my $output = eval $code;

          exit_with_error($1) if $output =~ /die_from_eval:(.*)/;

          s!\Q$wholething\E!!s;
        }

        if (exists $$templatevars{eitemcode} && exists $$templatevars{eitemname} && exists $$templatevars{eitemdesc} && exists $$templatevars{eitemopts} && exists $$templatevars{eitemcost}) {
          $$templatevars{eitemfingerprint} = get_cart_item_fingerprint(
            $$templatevars{eitemcode},
            $$templatevars{eitemname},
            $$templatevars{eitemdesc},
            $$templatevars{eitemopts},
            $$templatevars{eitemcost}
          );
        }
      }
    }
  }


# Create a fingerprint before and after adding the item to the cart, to
# prevent modification of any of the values (particularly the price).
#
sub get_cart_item_fingerprint($$$$$)
  {
    return enc_hash(
      $PREF{database_name} . $PREF{database_username} . $PREF{database_password} . 
        $_[0] . $_[1] . $_[2] . $_[3] . $_[4] . 
          $ENV{DOCUMENT_ROOT} . $ENV{PATH} . $ENV{SCRIPT_FILENAME}
	);
  }


sub format_xml_nicely
  {
    my $input_xml = shift;
    my $output_xml = '';
    my $depth = 0;
    my $prev_line_was_opener = 0;
    while ($input_xml =~ /(<[^<>]+>)/g) {
      my $line = $1;
      #print STDERR "Line is: '$line'\n";
      my $opener = 0;
      if ($line =~ m!^<\?xml!i) {
        $output_xml .= "$line\n";
        next;
      } elsif ($line =~ m!^<[^<]+/>$!) {
        $depth++ if $prev_line_was_opener;
      } elsif ($line =~ m!^</[^<]+>$!) {
        $depth--;
        $opener = 0;
        #$line .= '-';
      } elsif ($line =~ m!^<[^<]+>$!) {
        $depth++;
        $opener = 1;
        #$line .= '+';
      }

      $output_xml .= '  ' x ($depth - 1);
      $output_xml .= "$line\n";

      $prev_line_was_opener = $opener;
    }
    return $output_xml;
  }


sub is_zero                     # to differentiate values from null.
  {
    return $_[0] =~ /^0$/;
  }


sub dumphash
  {
    my ($hashref,$separator) = @_;
    $separator ||= ', ';
    my $output = '';
    foreach my $key (sort keys %$hashref) {
      $output .= "$key=$$hashref{$key}$separator";
    }
    $output =~ s!$separator$!!;
    return $output;
  }


sub remove_common_leading_substring
  {
    # Pass in an array of strings, and this sub will remove any common leading
    # portion from each of the strings in the array.  Note: this currently has
    # a hard-coded relief valve (the "$done = 1 if $i > N") until it gets more
    # widespread testing, because a malfunction could result in an infinite loop.

    my $done = 0;
    my $i = 0;
    my $longest_common_substring = '';
    while (!$done) {
      $i++;
      #print STDERR "increasing \$i to $i\n";
      my $substring = '';
      for (@_) {
        #print STDERR "\tprocessing $_ : ";
        if (!length($substring)) {
				# Set our test string from the first string in the array.  And this is
				# in its own separate if() because there's no sense in testing whether
				# this first string matches itself.
				#
          $substring = substr($_, 0, $i);

				# Also note that, because of this if() and the fact that we only set
				# the LCS variable in the following else(), that means we're technically
				# only removing length(LCS)-1 characters -- but that's what we want,
				# because otherwise we'd be leaving a null string in the event that one
				# of the strings *is* the LCS.  Instead we're leaving one character from
				# the end of the LCS as the first character on all the output strings.
        } else {
          if (/^$substring/) {
            #print STDERR "still matches ('$_' matches '$substring')\n";
            $longest_common_substring = $substring;
          } else {
            # failed the match, so we need to roll it back by 1 char:
            $longest_common_substring = substr($longest_common_substring, 0, -1);
            #print STDERR "failed match; we're done here. \$longest_common_substring='$longest_common_substring'\n";
            $done = 1; last;
          }
        }
        if (length($substring) >= length($_)) {
				#print STDERR "\n\tsubstring now as long as the shortest string; we're done here\n";
          $done = 1; last;
        }
      }
      $done = 1 if $i > 100; 
    }
    s!^$longest_common_substring!! for @_;
  }


sub datestring8_to_etime($$)
  {
    my $d8 = shift;
    my $when = shift;
    $when = $when =~ /start/ ? 'start' : 'end';

    my ($year,$month,$day) = ($d8 =~ /^(\d{4})(\d{2})(\d{2})$/);

    my ($sec,$min,$hour);
    if ($when eq 'start') {
      ($sec,$min,$hour) = (0,0,0);
    } else {
      ($sec,$min,$hour) = (59,59,23);
    }

    return timelocal($sec,$min,$hour,$day,($month - 1),$year);
  }


sub num_elapsed_days_between_datestring8_dates($$)
  {
    my $earlier_date = shift;
    my $later_date = shift;

    if ($earlier_date !~ /^\d{8}$/ || $later_date !~ /^\d{8}$/) {
      die qq`$0: datestrings must contain exactly 8 digits and nothing else, but you've passed "$earlier_date" and "$later_date"\n`;
    }

    return 0 if $earlier_date == $later_date;

    if ($earlier_date > $later_date) {
      my $temp = $earlier_date;
      $earlier_date = $later_date;
      $later_date = $temp;
    }

    # now $earlier_date is smaller/earlier than $later_date.

    my $elapsed_days = 0;
    while ($earlier_date < $later_date) {
      $later_date = decrement_datestring_8($later_date, 1);
      $elapsed_days++;
    }

    return $elapsed_days;
  }


sub increment_datestring_8($$)
  {
    my $start = shift;
    my $amount = shift;
    my $i = ();

    die_nice("Error: increment_datestring_8('$start', '$amount'): invalid start date '$start'.\n") unless $start =~ /^\d{8}$/;

    for ($i=1; $i<=$amount; $i++) {
      my ($year,$month,$day) = ($start =~ /(\d{4})(\d{2})(\d{2})/);
      my ($newmonth,$newday) = ($month,$day);

      s/^0// for($newmonth,$newday);

      # try to inc the day
      eval { timelocal(0,0,0,$newday+1,$newmonth-1,$year); }; # note: timelocal's month is 0..11 so $month-1 = $month
      if ($@)                   # means there was an error.
        {
          # try to inc the month
          eval { timelocal(0,0,0,1,$newmonth,$year); };
          if ($@) {
				# inc the year
            eval { timelocal(0,0,0,1,0,$year+1); };
            if ($@) {
              die_nice("Error: increment_datestring_8('$start', '$amount'): can't increment the year: $@\n");
            } else {
              $year++;
              $start = $year . '0101';
            }
          } else {
            $newmonth++;
            $newmonth = "0$newmonth" if ($newmonth =~ /^\d$/);
            $start = $year . $newmonth . '01';
          }
        } else {
          $newday++;
          $newday = "0$newday" if ($newday =~ /^\d$/);
          $start = $year . $month . $newday;
        }
    }

    return $start;
  }


sub decrement_datestring_8($$)
  {
    my $start = shift;
    my $amount = shift;
    my $i = ();

    die_nice("Error: decrement_datestring_8('$start', '$amount'): invalid start date '$start'.\n") unless $start =~ /^\d{8}$/;

    for ($i=1; $i<=$amount; $i++) {
      my ($year,$month,$day) = ($start =~ /(\d{4})(\d{2})(\d{2})/);
      my ($newmonth,$newday) = ($month,$day);

      s/^0// for($newmonth,$newday);

      # try to dec the day
      eval { timelocal(0,0,0,$newday-1,$newmonth-1,$year); }; # note: timelocal's month is 0..11 so $month-1 = $month
      if ($@ || $newday !~ /[1-9]/) # $@ means there was an error.  also need to make sure $newday is nonzero for servers whose timelocal() is broken, incorrectly reporting 0 as a valid day.
        {
          # try to dec the month
          eval { timelocal(0,0,0,1,$newmonth-2,$year); };
          if ($@) {
				# month is Jan... dec the year
            eval { timelocal(0,0,0,1,0,$year-1); };
            if ($@) {
              die_nice("Error: decrement_datestring_8('$start', '$amount'): can't decrement the year: $@\n");
            } else {
              $year--;
              $start = $year . '1231';
            }
          } else {
				# we know the month is valid, so find the highest valid day:
            $newday = 32;
            do { $newday--; eval { timelocal(0,0,0,$newday,$newmonth-2,$year); }; } while ($@);

            $newmonth--;
            $newmonth = "0$newmonth" if ($newmonth =~ /^\d$/);
            $start = $year . $newmonth . $newday;
          }
        } else {
          $newday--;
          $newday = "0$newday" if ($newday =~ /^\d$/);
          $start = $year . $month . $newday;
        }
    }

    return $start;
  }


sub increment_datestring_6
  {
    my $date = shift;
    die_nice qq`Invalid datestring6 value: '$date'.` unless $date =~ /^\d{6}$/;
    my ($year,$month) = ($date =~ /(\d{4})(\d{2})/);
    $month =~ s!^0!!;
    $month++;
    if ($month > 12) {
      $month = 1;
      $year++;
    }
    $month = "0$month" if $month =~ /^\d$/;
    return "$year$month";
  }


sub decrement_datestring_6
  {
    my $date = shift;
    die_nice qq`Invalid datestring6 value: '$date'.` unless $date =~ /^\d{6}$/;
    my ($year,$month) = ($date =~ /(\d{4})(\d{2})/);
    $month =~ s!^0!!;
    $month--;
    if ($month < 1) {
      $month = 12;
      $year--;
    }
    $month = "0$month" if $month =~ /^\d$/;
    return "$year$month";
  }


sub split_path_and_filename
  {
    return ($_[0] =~ m!^(.*?)([^/\\]+)$!);
  }


sub serialize_filename_if_file_exists
  {
    my $fullfile = shift;
    my $separator = shift;		# optional
    my $paddinglength = shift || 2;	# optional

    my ($path,$file) = split_path_and_filename($fullfile);
    $separator ||= $file =~ / / ? ' ' : '_';

    my $i = my $j = 1;
    while (-e $fullfile) {
      $j = $i;
      $j = "0$j" while(length($j) < $paddinglength);
      my $tempname = $file;
      $tempname =~ s/(\.[^\.]+)$/$separator$j$1/;
      $fullfile = $path . $tempname;
      $i++;
    }

    return wantarray ? ($fullfile, $separator, $j) : $fullfile;
  }


sub get_all_subdirs
  {
    #print STDERR "get_all_subdirs('$_[0]')\n";

    my $dir = shift;
    my $mode = shift;
    unless(-d $dir)
      {
        print_http_headers();
        print qq`<p>Error: get_all_subdirs(): we need a directory, but we received "$dir".</p>\n`;
        return;
      }
    opendir(DIRHFORSUBS, $dir) or die_nice "couldn't open directory '$dir': $!\n";
    my @dirs = sort { lc($a) cmp lc($b) } grep {  -d "$dir/$_"  &&  -w "$dir/$_"  &&  !/^\.$/  &&  !/\.{2}/  } readdir(DIRHFORSUBS);
    closedir DIRHFORSUBS or die_nice "couldn't close directory '$dir': $!\n";

    my @subdirs = ();
    # now recurse through everything below this point.
    foreach my $level1dir (@dirs) {
      foreach my $level2dir (get_all_subdirs("$dir/$level1dir")) {
        push @subdirs, "$level1dir/$level2dir";
      }
    }
    push @dirs, @subdirs;

    return sort { lc($a) cmp lc($b) } @dirs;
  }


sub get_all_files
  {
    my $dir = shift;
    opendir(DIRHFORFILES, $dir) or die_nice "couldn't open directory '$dir': $!\n";
    my @files = sort { lc($a) cmp lc($b) } grep {  -f "$dir/$_"  &&  -r "$dir/$_"  &&  !/^\.$/  &&  !/\.{2}/  } readdir(DIRHFORFILES);
    closedir DIRHFORFILES or die_nice "couldn't close directory '$dir': $!\n";
    return @files;
  }


sub get_enc_visitor_id_iframe()
  {
    return $PREF{enc_visitor_id_was_missing} ? qq`<iframe src="$ENV{SCRIPT_NAME}?action=set_enc_visitor_id&amp;newid=$PREF{enc_visitor_id}" name="enc_vis_id_setter" id="enc_vis_id_setter" width="1" height="1"></iframe>\n` : '';
  }


sub set_enc_visitor_id()
  {
    set_cookie($PREF{enc_visitor_id_cookie}, get_qs_var('newid'), "+365d");
    print_http_headers();
    exit;
  }


sub generate_random_hash()
  {
    # We're using md5_hex() here instead of enc_hash() because the latter is prefs-dependent,
    # but we need this sub to be callable before prefs are loaded; and because, for a random
    # hash, as opposed to a hash of sensitive data like a password, the issues that make MD5
    # weaker than SHA1 are irrelevant.  Also note that, because the input data will be
    # different every single time this sub is called, and thus the output hash will never be
    # the same for any two calls (which is the whole point), that means that at any point in
    # the future, we can change to a different hash function, without it breaking anything
    # (for example, if/when sha1_hex() ever becomes available on virtually every installation,
    # as md5_hex() is now).

    return md5_hex($ENV{REMOTE_ADDR} . $$ . $ENV{HTTP_USER_AGENT} . $ENV{REMOTE_PORT} . time() . rand());
  }


sub start_html_output_std
  {
    return if $PREF{start_html_output_called};
    $PREF{start_html_output_called} = 1;

    my $subtitle = shift;

    print_http_headers();
    if ($PREF{internal_appname} eq 'userbase') {
      return if $qs =~ /format=mini/;
    }

    my $css = get_css();
    my $js = get_js();

    $PREF{title} = $PREF{"title_$PREF{on_page}"} if exists $PREF{"title_$PREF{on_page}"};
    my $show_app_pagetitle = $PREF{"hide_app_pagetitle_on_$PREF{on_page}_page"} !~ /yes/i;
    my $show_app_subtitle  = $PREF{"hide_app_subtitle_on_$PREF{on_page}_page"} !~ /yes/i;
    my $title_for_titlebar = exists $PREF{"titlebar_title___$PREF{on_page}"} ? $PREF{"titlebar_title___$PREF{on_page}"} : exists $PREF{titlebar_title} ? $PREF{titlebar_title} : $PREF{title};
    $title_for_titlebar =~ s!%%subtitle%%!$subtitle!g;
    $title_for_titlebar =~ s!<[^>]*>!!g;

    my $body_details = qq`id="$PREF{twochar_app_id}body" class="$PREF{on_page}body $PREF{current_app_style}_style"`;

    if ($ENV{REQUEST_METHOD} =~ /post/i   ||   $PREF{"print_full_html_tags_for_$PREF{on_page}"} =~ /yes/i   ||   ($PREF{print_full_html_tags} =~ /yes/i   &&   $PREF{"print_full_html_tags_for_$PREF{on_page}"} !~ /no/i)   ||   (get_qs_var('forcefullhtml') eq 'yes')   ||   (get_qs_var('forcefullpage') eq 'yes')) {
      print	  qq`<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">`
        . qq`\n<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">`
          . qq`\n<head>`
            . qq`\n<meta http-equiv="Content-type" content="text/html; charset=ISO-8859-1" />`
              . qq`\n<title>$title_for_titlebar</title>`
                . qq`\n<script type="text/javascript">\n/* <![CDATA[ */  /* so (X)HTML validators ignore the javascript. */\n\n$js\n\n/* ]]> */  /* so (X)HTML validators ignore the javascript. */\n</script>`
                  . qq`\n<style type="text/css">$css</style>`
                    . $PREF{extra_header_output}
                      . qq`\n</head>`
			. qq`\n<body $body_details>`
                          . qq`\n`;
    } elsif ($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file}) {
      my $title = $PREF{title_for_template_file} || $title_for_titlebar || $subtitle;
      open(HEADERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
      my $infh = \*HEADERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
      flock $infh, 1;
      seek $infh, 0, 0;
      while (<$infh>) {
        s!%%title%%!$title!g;
        s#(<!--\s*)?%%js%%(\s*-->)?#<script type="text/javascript" src="$ENV{SCRIPT_NAME}?js"></script>#g;
        s#(<!--\s*)?%%css%%(\s*-->)?#<link rel="stylesheet" type="text/css" media="all" href="$ENV{SCRIPT_NAME}?css">#g;

        if (/^(.*?)(?:<!--\s*)?%%encodable_app_output%%/i) {
          print $1; last;
        } else {
          print $_;
        }
      }
      close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";

      print	  $PREF{extra_header_output};
      print	  $PREF{body_container_start} || qq`<div $body_details>\n`;
    } else {
      print	  $PREF{extra_header_output};
      print	  $PREF{body_container_start} || qq`<div $body_details>\n`;
    }

    $PREF{app_output_template} =~ s!%%title%%!$PREF{title}!g;
    $PREF{app_output_template} =~ s!%%subtitle%%!$subtitle ? qq`<div id="encsubtitle">$subtitle</div>` : ''!eg;
    $PREF{app_output_template} =~ s!%%%if-pagetitle%%%(.*?)%%%end-pagetitle%%%!$PREF{title} && $show_app_pagetitle ? $1 : ''!egs;
    $PREF{app_output_template} =~ s!%%%if-pagesubtitle%%%(.*?)%%%end-pagesubtitle%%%!$subtitle && $show_app_subtitle ? $1 : ''!egs;
    $PREF{app_output_template} =~ s!%%on_page%%!$PREF{on_page}!g;
    $PREF{app_output_template} =~ s!%%wide_page_css_wrapper_id%%!$PREF{on_a_wide_page} ? "$PREF{twochar_app_id}wrapper_widepage" : ''!egs;
    $PREF{app_output_template} =~ s!%%%if-onpage_(\w+)%%%(.*?)%%%endif-onpage_\1%%%!$PREF{on_page} eq $1 ? $2 : ''!egs;
    $PREF{app_output_template} =~ s!%%%ifelse-onpage_(\w+)%%%(.*?)%%%else%%%(.*?)%%%endelse-onpage_\1%%%!$PREF{on_page} eq $1 ? $2 : $3!egs;
    do_standard_template_vars_processing('include_undefined', $PREF{app_output_template});

    my $output_tophalf = ($PREF{app_output_template} =~ /(.*)%%app_output_body%%/s)[0];
    my $linkbar = get_linkbar(@_);
    $output_tophalf =~ s!%%linkbar_top%%!$linkbar!g;
    print $output_tophalf;

    if ($PREF{internal_appname} eq 'userbase' && -e $PREF{default_account_temp_file}) {
      print qq`<div style="margin: 20px auto; max-width: 400px;">To determine your default admin account, login to your server via your normal method (FTP, etc) and then read the file $PREF{default_account_temp_file} (within your cgi-bin folder or login folder by default).&nbsp; This message will be displayed until you delete that file.</div>\n`;
    }
  }


sub finish_html_output_std
  {
    return if $PREF{finish_html_output_called};
    $PREF{finish_html_output_called} = 1;

    if ($PREF{internal_appname} eq 'userbase') {
      return if $qs =~ /format=mini/;
    }

    my $linkbar = get_linkbar(@_);
    my $output_bottomhalf = ($PREF{app_output_template} =~ /%%app_output_body%%(.*)/s)[0];
    $output_bottomhalf =~ s!%%linkbar_bottom%%!$linkbar!g;
    $output_bottomhalf =~ s!%%powered_by%%!$PREF{hide_poweredby} eq 'yes' ? '' : get_powered_by()!eg;
    print $output_bottomhalf;

    if ($PREF{enable_debug} =~ /yes/i) {
      print qq`<div style="margin: 20px auto; min-width: 400px; max-width: 600px; padding: 5px; background: #fff; color: #444; border: 1px solid #999;">`
        . qq`Warning: you've set \$PREF{enable_debug} to 'yes'.&nbsp; If you're not having problems, you should disable this.&nbsp; And if you are having problems, you should still disable this, because in some cases it can cause features not to work.&nbsp; Only enable this temporarily.`
          . qq`\n</div>\n`;
    }

    if (($CGI::VERSION < 3.03)   &&   ($PREF{ignore_ancient_CGI_module} !~ /yes/i)) {
      print qq`<div style="margin: 20px auto; min-width: 400px; max-width: 600px; padding: 5px; background: #fff; color: #444; border: 1px solid #999;">`
        . qq`Warning: your server's version of the CGI.pm Perl module is $CGI::VERSION, which is extremely outdated.&nbsp; `
          . qq`Some features like uploading may not work at all, or may be unreliable.&nbsp; To fix this, `
            . qq`<a href="http://encodable.com/sharedfaq/#oldcgi" target="_blank">update your CGI module</a>.&nbsp; `
              . qq`To ignore this problem (not recommended), add this line to the end of your prefs file: `
                . qq`\$PREF{ignore_ancient_CGI_module}='yes';</div>\n`;
    }

    send_event_calendar_reminders() if $PREF{internal_appname} eq 'userbase';
    print get_extra_debug_output();

    if ($ENV{REQUEST_METHOD} =~ /post/i   ||   $PREF{"print_full_html_tags_for_$PREF{on_page}"} =~ /yes/i   ||   ($PREF{print_full_html_tags} =~ /yes/i   &&   $PREF{"print_full_html_tags_for_$PREF{on_page}"} !~ /no/i)   ||   (get_qs_var('forcefullhtml') eq 'yes')   ||   (get_qs_var('forcefullpage') eq 'yes')) {
      print	  $PREF{extra_footer_output};
      print	  qq`</body>\n</html>\n`;
    } elsif ($PREF{encodable_app_template_file} && -e $PREF{encodable_app_template_file}) {
      print	  $PREF{body_container_end} || qq`</div><!-- end #$PREF{twochar_app_id}body -->\n`;
      print	  $PREF{extra_footer_output};

      open(FOOTERFH, "<$PREF{encodable_app_template_file}") or die "$0: couldn't open \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') for reading:: $!\n";
      my $infh = \*FOOTERFH; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
      flock $infh, 1;
      seek $infh, 0, 0;
      my $found_token = 0;
      while (<$infh>) {
        if ($found_token) {
          print $_;
        } elsif (/%%encodable_app_output%%(?:\s*-->)?(.*?)$/i) {
          print $1; $found_token = 1;
        }
      }
      close $infh or die "$0: couldn't close \$PREF{encodable_app_template_file} ('$PREF{encodable_app_template_file}') after reading:: $!\n";
    } else {
      print	  $PREF{body_container_end} || qq`</div><!-- end #$PREF{twochar_app_id}body -->\n`;
      print	  $PREF{extra_footer_output};
    }
  }


sub check_image_modules
  {
    exit_with_needprivs() unless user_is_allowed_to('view_administration_page');

    my $separator = qq`<br /><br /><hr><br />\n`;

    start_html_output("Check Image Modules");
    print qq`\n<div style="text-align: left; margin: 30px auto;">$PREF{internal_appname_nice} uses image modules in order to enable image-based features like rotation, resizing/thumbnails, etc.&nbsp; It supports 3 different methods for this: the GD Perl module, the ImageMagick Perl module, and the ImageMagick convert/identify commands; and usually only one of these is necessary.&nbsp; This page will show whether your server supports these modules.&nbsp; See <a href="http://encodable.com/filechucker/faq/#image">this FAQ</a> for more details.$separator`;

    unless ($PREF{already_tested_for_im}) {
      eval { require Image::Magick; }; $PREF{imagemagick_error} = $@;
    }
    unless ($PREF{already_tested_for_gd}) {
      eval { require GD; require GD::Simple; }; $PREF{gd_error} = $@;
    }
    foreach my $module ('ImageMagick', 'GD') {
      my $error = $PREF{lc($module) . "_error"};
      print qq`Attempting to load the $module Perl module... `;
      print !$error	? qq`success.`
        : qq`failed.&nbsp; The error was: <div style="margin: 20px 40px;">$error</div>`
          . qq`This means that <strong>the $module Perl module is not installed, or not installed <em>properly</em>, on your server</strong>.&nbsp; `
            . qq`This is a server error, not a $PREF{internal_appname_nice} error.&nbsp; <a href="http://encodable.com/filechucker/faq/#image">This FAQ</a> may help, `
              . qq`but you'll need to contact your hosting company if you want to get the $module Perl module installed properly.&nbsp; Or, if you have `
                . qq`root/Administrator access to your server, then we may be able to install it for you; the cost is typically 1 hour of labor.&nbsp; `
                  . qq`<a href="http://encodable.com/contact/">Contact us</a> if you'd like us to look into this.`;
      print $separator;
    }

    print "Attempting to locate a 'convert' command:<br />\n";
    print "\nExecuting 'which convert': ";
    my $which_output = `which convert`;
    print $which_output && $which_output !~ /no convert in/ ? "found one or more convert commands: $which_output" : "command produced no output; no 'convert' in PATH.";
    print "<br />\n";
    print "Manually checking /usr/bin/convert: " . (-e '/usr/bin/convert' ? 'exists.' : 'does not exist.') . "<br />\n";
    print "Manually checking /usr/local/bin/convert: " . (-e '/usr/local/bin/convert' ? 'exists.' : 'does not exist.') . "<br />\n";
    print "<br />\nIf a convert command was found here, you can set \$PREF{convert_command} to it, and then enable the \$PREF{try_to_use_convert_*} settings (and probably also the \$PREF{try_to_use_identify_*} settings because an identify command probably exists in the same location).\n";
    #print "\nExecuting 'find / -name convert':<br />\n";
    #print `find / -name convert -type f`;
    print $separator;

    if ($PREF{im_and_gd_disabled_internally}) {
      print qq`Because neither the ImageMagick nor GD Perl modules are properly installed on your server, $PREF{internal_appname_nice} has internally disabled the \$PREF{try_to_use_*} prefs for them.&nbsp; You may be able to use the \$PREF{try_to_use_convert_*} settings instead.&nbsp; See <a href="http://encodable.com/filechucker/faq/#image">this FAQ</a> for more details.$separator`;
    }

    print qq`Note that this only affects the image-based features like rotation, thumbnails, etc.&nbsp; It does not affect $PREF{internal_appname_nice}'s core functionality.&nbsp; So $PREF{internal_appname_nice} itself will work just fine even if your server does not support these image modules.`;
    print qq`</div>\n`;

    finish_html_output();
  }


sub try_to_load_image_modules()
  {
    # TODO: find a reliable way to test whether the jpegtran and convert binaries are available.
    # For now, just hardcode the $PREF{(jpegtran|convert)_available} = 'yes'; and use the try_to_*
    # PREF to switch it off.
    #
    #if(!jpegtran_is_available()   &&   ($PREF{try_to_use_jpegtran_for_rotation} =~ /yes/i))
    #{
    #	die_nice qq`$PREF{internal_appname}: jpegtran is not available on your server, so you must either install it, or else disable the following setting in PREFs Section 15: <br /><br />\n\$PREF{try_to_use_jpegtran_for_rotation}`;
    #}
    $PREF{jpegtran_available} = 'yes';
    $PREF{convert_available} = 'yes';
    $PREF{identify_available} = 'yes';

    # Note: the call to *_is_available() MUST come last in these if()s, so that on
    # servers where the module is corrupt, we can prevent even trying to load it,
    # by setting the PREFs to 'no'.
    #
    my $tried_im_and_failed = 1 if(($PREF{try_to_use_imagemagick_for_rotation} =~ /yes/i || $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i || $PREF{try_to_use_imagemagick_for_humantest} =~ /yes/i)   &&   !imagemagick_is_available());
    my $tried_gd_and_failed = 1 if(($PREF{try_to_use_gd_for_rotation} =~ /yes/i || $PREF{try_to_use_gd_for_resizing} =~ /yes/i || $PREF{try_to_use_gd_for_humantest} =~ /yes/i)   &&   !gd_is_available());
    if ($tried_im_and_failed   &&   $tried_gd_and_failed) {
      $PREF{im_and_gd_disabled_internally} = 1;
      foreach my $pref (keys %PREF) {
        $PREF{$pref} = 'no' if $pref =~ /^try_to_use_(imagemagick|gd)/i;
      }
    }
  }

sub jpegtran_is_available()
  {
    $PREF{jpegtran_test_command} = 'jpegtran </dev/null >/dev/null 2>&1';
    my ($success,$msg) = enc_sys_call($PREF{jpegtran_test_command});
    if ($success) {
      $PREF{jpegtran_available} = 'yes';	$PREF{jpegtran_error} = '';
    } else {
      $PREF{jpegtran_available} = 'no';	$PREF{jpegtran_error} = "Failed to execute jpegtran: $msg";
    }
    return !$PREF{jpegtran_error};
  }


sub imagemagick_is_available()
  {
    unless ($PREF{already_tested_for_im}) {
      $PREF{already_tested_for_im} = 1;
      eval { require Image::Magick; }; $PREF{imagemagick_error} = $@;
      $PREF{imagemagick_available} = !$PREF{imagemagick_error};
    }
    return $PREF{imagemagick_available};
  }


sub gd_is_available()
  {
    unless ($PREF{already_tested_for_gd}) {
      $PREF{already_tested_for_gd} = 1;
      eval { require GD; require GD::Simple; }; $PREF{gd_error} = $@;
      $PREF{gd_available} = !$PREF{gd_error};
    }
    return $PREF{gd_available};
  }


sub do_automatic_resizing($)
  {
    my $files = shift;
    # hashref, formatted like this:
    # $$files{01}{name} = 'foo.jpg',
    # $$files{01}{realpath} = '/full/path/to/imagedir',
    # $$files{01}{force_overwrite} = 1 (optional).

    my @results = ();
    my $filecount = scalar keys %$files;

    if ($PREF{resize_uploaded_images} =~ /yes/i   ||   $PREF{create_resized_copies_of_uploaded_images} =~ /yes/i) {
      foreach my $pref (sort keys %PREF) {
        if ($pref =~ /^create_resized_copies_(\d+)__imagemagick_size$/) {
          my $num = $1;
          foreach my $file (sort keys %$files) {
            if (is_image($$files{$file}{name})) {
              my $file_id_for_status = $filecount == 1 ? $$files{$file}{name} : "#$file ($$files{$file}{name})";

              my $input_file_full = $$files{$file}{realpath} . '/' . $$files{$file}{name};
              condense_slashes('leave_leading_UNC', $input_file_full);

              if ($PREF{create_resized_copies_of_uploaded_images} =~ /yes/i) {
                my $smallsize = ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i) || $PREF{try_to_use_convert_for_resizing} =~ /yes/i ? $PREF{"create_resized_copies_${num}__imagemagick_size"} : gd_is_available() ? $PREF{"create_resized_copies_${num}__gd_size"} : '';

                if (-s $input_file_full > $PREF{"create_resized_copies_${num}__skip_if_bigger_than"}) {
                  push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: skipping because input file is bigger than the limit ($PREF{"create_resized_copies_${num}__skip_if_bigger_than"} bytes).`;
                  next;
                }

                my $output_dir = $PREF{"create_resized_copies_${num}__location_type"} eq 'absolute' ? $PREF{"create_resized_copies_${num}__folder_name"} : $$files{$file}{realpath};
                $output_dir .= '/' . $PREF{"create_resized_copies_${num}__folder_name"} if $PREF{"create_resized_copies_${num}__folder_name"} && $PREF{"create_resized_copies_${num}__location_type"} eq 'relative';
                condense_slashes('leave_leading_UNC', $output_dir);
                create_dir_if_DNE($output_dir,$PREF{writable_dir_perms});

                my $output_file = $PREF{"create_resized_copies_${num}__new_filename"};
                my ($origname,$ext) = ($$files{$file}{name} =~ /(.+)\.(.+)/);
                $output_file =~ s!%%orig%%!$origname!g;
                $output_file =~ s!%%ext%%!$ext!g;

                my $output_file_full = $output_dir . '/' . $output_file;
                #unless($PREF{overwrite_existing_files} =~ /yes/i)
                if ($PREF{"create_resized_copies_${num}__serialize_or_overwrite"} eq 'serialize') {
                  $output_file_full = serialize_filename_if_file_exists($output_file_full);
                }

                # Make sure to do the skip-if-exists check before the image-dims check, because
                # the latter is expensive.
                #
                if (-e $output_file_full && !$$files{$file}{force_overwrite}) {
                  push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: skipping because output file already exists.`;
                  next;
                }

                my ($origw,$origh) = get_image_dims($input_file_full);
                my ($thumbw,$thumbh) = ($smallsize =~ /^(\d*)x?(\d*)$/i);
                if ($origw > $thumbw || $origh > $thumbh || !$origw || !$thumbw) {
                  #resize_image($input_file_full, $output_file_full, $smallsize);
                  resize_image___withtimeout($PREF{image_resizing_timeout}, $input_file_full, $output_file_full, $smallsize);
                  push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: OK.` if -e $output_file_full;
                  push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: failed (output file does not exist afterwards).` unless -e $output_file_full;
                } else {
                  copy($input_file_full, $output_file_full) or die_nice "couldn't copy image file '$input_file_full' to thumbnail file '$output_file_full': $!\n";
                  push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: OK (copied from original because original was already small enough).` if -e $output_file_full;
                  push @results, qq`Creating ${smallsize}px resized copy of $file_id_for_status: failed (tried to copy from original because original was already small enough).` unless -e $output_file_full;
                }
                chmod $PREF{writable_file_perms}, $output_file_full;
              }

              if ($PREF{resize_uploaded_images} =~ /yes/i) {
                next if -s $input_file_full > $PREF{resize_uploaded_images__skip_if_bigger_than};

                my $smallsize = ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i) || $PREF{try_to_use_convert_for_resizing} =~ /yes/i ? $PREF{resize_uploaded_images__imagemagick_size} : gd_is_available() ? $PREF{resize_uploaded_images__gd_size} : '';
                my ($origw,$origh) = get_image_dims($input_file_full);
                my ($thumbw,$thumbh) = ($smallsize =~ /^(\d*)x?(\d*)$/i);
                if ($origw > $thumbw || $origh > $thumbh || !$origw || !$thumbw) {
                  #resize_image($input_file_full, $input_file_full, $smallsize);
                  resize_image___withtimeout($PREF{image_resizing_timeout}, $input_file_full, $input_file_full, $smallsize);
                  push @results, qq`Resizing $file_id_for_status to ${smallsize}px: OK.` if -e $input_file_full;
                  chmod $PREF{writable_file_perms}, $input_file_full;
                }
              }
            }
          }
        }
      }
    }

    return @results;
  }


sub get_image_dims
  {
    my $filename = shift;
    my ($width, $height, $xres, $yres) = ();
    my $decpoints = $PREF{num_decimal_points_for_image_details} =~ /^(\d+)$/ ? $1 : 2;
    if ($PREF{identify_available} =~ /yes/i && $PREF{try_to_use_identify_for_dimensions} =~ /yes/i) {
      my $info = `$PREF{identify_command} -verbose "$filename"`;
      ($width,$height) = ($1,$2) if $info =~ /^\s*Geometry:\s*(\d+)x(\d+)/m;
      ($xres,$yres) = ($1,$2) if $info =~ /^\s*Resolution:\s*(\d+)x(\d+)/m;

      # This works, and doesn't require reading the whole image into memory so it's
      # quicker, but it can only get a few image attributes, not all of them.
      #
      #my $info = `$PREF{identify_command} "$filename"`;
      #($width,$height) = ($1,$2) if $info =~ /^$filename [A-Z]+ (\d+)x(\d+) /   ||   $info =~ /^$filename [A-Z]+ (\d+)x(\d+)\+\d+\+\d+ /;
    } elsif ($PREF{imagemagick_available} && $PREF{try_to_use_imagemagick_for_dimensions} =~ /yes/i) {
      my $image = new Image::Magick;
      my $x = $image->Read($filename);
      #die_nice "ImageMagick Read() error: $x" if "$x"; # seems to die too easily, i.e. for unknown meta tags in an otherwise OK image.
      ($width, $height, $xres, $yres) = $image->Get('width', 'height', 'x-resolution', 'y-resolution');

      # This works, and doesn't require reading the whole image into memory so it's
      # quicker, but it can only get a few image attributes, not all of them.
      #
      #my $image = new Image::Magick;
      #my ($width, $height, $size, $format) = $image->Ping($filename);
      #return ($width, $height);

      # This works, but the output goes directly to STDOUT/STDERR instead of into @details.
      #
      #my $image = new Image::Magick;
      #my $x = $image->Read($filename);
      #die_nice "ImageMagick Read() error: $x" if "$x";
      #my @details = $image->Identify();
      ##die_nice (qq`Details: \n<br />` . join("\n<br /><br />", @details));
    } elsif (gd_is_available() && $PREF{try_to_use_gd_for_dimensions} =~ /yes/i) {
      my $image = GD::Image->new($filename);
      ($width,$height) = ($image->width, $image->height) if $image;
    }

    my $width_inches  = $width  && $xres ? $width/$xres  : '';
    my $height_inches = $height && $yres ? $height/$yres : '';

    for ($xres, $yres, $width_inches, $height_inches) {
      s!(\.\d{$decpoints}).+!$1!; $_ = int($_) unless $decpoints;
    }

    return ($width, $height, $xres, $yres, $width_inches, $height_inches);
  }


sub resize_image___withtimeout
  {
    my $timeout = shift;
    my $ignore_other_errors	= $_[0] eq 'ignore_other_errors' ? shift : '';
    my $timeouts_are_errors	= $_[0] eq 'timeouts_are_errors' ? shift : '';

    #use Time::HiRes 'gettimeofday';
    #my $starttime = gettimeofday();

    if ($timeout) {
      if (0) # eval method: (doesn't always work; for exaple with timeout set to 8, a certain image still takes 100+ seconds??)
        {
          eval {
            local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
            alarm $timeout;
            resize_image(@_);
            alarm 0;
          };
          if ($@) {
            if ($@ eq "alarm\n") {
              $timeouts_are_errors	&& die_nice("Timed out while trying to resize image.\n");
            }                   # timed out.
            else {
              $ignore_other_errors	|| die_nice("Error while trying to resize image: $@\n");
            }                   # propagate unexpected errors.
          }
          # else it didn't time out.
        } else                  # fork method:
          {
            my $pid = fork;
            defined $pid or die_nice "Could not fork: $!\n";
            unless ($pid) {
				# child:
              local $SIG{ALRM} = 'DEFAULT';
              alarm $timeout;
              resize_image(@_);
              alarm 0;
              exit;             # exit the child.
            }
            waitpid $pid, 0;
          }
    } else {
      resize_image(@_);
    }

    #print STDERR "resize_image___withtimeout(): timeout set to $timeout; actual time was " . int(gettimeofday() - $starttime) . "\n";
  }


sub resize_image
  {
    my $infile = shift;
    my $outfile = shift;
    my $newW = shift;
    my $newH = shift;

    return unless -s $infile;

    my $geom = ();
    if ($newW =~ /(\d*)x(\d*)!?/i) {
      $geom = $newW;
      ($newW,$newH) = ($1,$2);
    } else {
      $geom = $newW . 'x' . $newH;
    }

    die_nice "can't resize image because at least one of the dimensions must be specified (\$newW='$newW', \$newH='$newH')\n" unless ($newW =~ /[1-9]/ || $newH =~ /[1-9]/);

    if ($PREF{convert_available} =~ /yes/i   &&   $PREF{try_to_use_convert_for_resizing} =~ /yes/i) {
      printd qq`resize_image(): using convert\n`;

      my $cmd = $PREF{convert_resize_template};
      $cmd =~ s!%%size%%!${newW}x${newH}!g;
      $cmd =~ s!%%infile%%!$infile!g;
      $cmd =~ s!%%outfile%%!$outfile!g;
      my ($success,$msg) = enc_sys_call($cmd);
      unless ($success) {
        die_nice(qq`failed: $msg`);
      }
    } elsif ($PREF{imagemagick_available}   &&   $PREF{try_to_use_imagemagick_for_resizing} =~ /yes/i) {
      printd qq`resize_image(): using IM\n`;

      my $image = new Image::Magick;
      my $retval = ();

      $retval = $image->Read($infile);
      if ($retval) {
        printd "$0: error: resize_image(): \$image->Read()   returned $retval.\n"; return;
      }

      $retval = $image->Resize(geometry=>$geom, filter=>'Lanczos');
      if ($retval) {
        printd "$0: error: resize_image(): \$image->Resize() returned $retval.\n"; return;
      }

      $image->Set(quality=>95);
      $image->Write($outfile);
    } elsif (gd_is_available()   &&   $PREF{try_to_use_gd_for_resizing} =~ /yes/i) {
      printd qq`resize_image(): using GD\n`;

      my $inputimage = GD::Image->new($infile);
      if (!$inputimage) {
        printd "$0: error: resize_image(): GD::Image->new($infile) returned null...\n"; return;
      }

      my $oldW = $inputimage->width;
      my $oldH = $inputimage->height;

      die "$0: can't resize image because a dimension is missing (\$oldW='$oldW', \$oldH='$oldH')\n" unless $oldW =~ /[1-9]/ && $oldH =~ /[1-9]/;

      if (!$newW) {
        $newW = ($newH * $oldW) / $oldH;
        $newW =~ s/\..*//;
      }
      if (!$newH) {
        $newH = ($newW * $oldH) / $oldW;
        $newH =~ s/\..*//;
      }

      my $outputimage = GD::Image->newTrueColor($newW,$newH);
      $outputimage->copyResampled($inputimage,0,0,0,0,$newW,$newH,$oldW,$oldH);
      open(RESIMG, ">$outfile") or die "$0: couldn't create file '$outfile': $!\n";
      my $fh = \*RESIMG; # voodoo required since ancient Perls can't accept "open(my $foo_fh)".
      binmode $fh;
      if ($outfile =~ /\.jpe?g$/i) {
        print $fh $outputimage->jpeg(95);
      } elsif ($outfile =~ /\.png$/i) {
        print $fh $outputimage->png(3);
      } elsif ($outfile =~ /\.gif$/i) {
        print $fh $outputimage->gif();
      } else {
        die "$0: resize_image(): image format not supported by GD.\n";
      }
      close $fh or die "$0: couldn't close file '$outfile' after creating it: $!\n";
    } else {
      die_nice "no image-resizing library available.";
    }

    exit_with_error qq`Output file does not exist after resizing; try adjusting or disabling \$PREF{image_resizing_timeout} and other image/video timeouts.` unless -f $outfile;
  }


sub image_orientation_is_resettable($)
  {
    my $filename = shift;
    return 0 unless $filename =~ /\.(jpg|jpe|jpeg)$/i;
    return command_is_available("exiftool") || command_is_available("exifautotran");
  }


sub reset_image_orientation($)
  {
    my $filename_with_path = shift;
    exit_with_error qq`file doesn't exist: '$filename_with_path'.` unless -e $filename_with_path;
    if (command_is_available("exiftool")) {
      system("exiftool -n -P -Orientation=1 \"$filename_with_path\"");
    } elsif (command_is_available("exifautotran")) {
      system("exifautotran \"$filename_with_path\"");
    } else {
      exit_with_error qq`no image-orientation-resetting program available.`;
    }
    chmod $PREF{writable_file_perms}, $filename_with_path;
  }


# Prereqs: the passed command must be *just* a command; it must
# not contain any arguments.  (But because of systems with dumb
# setups (i.e. Windows), the command may still contain spaces.)
# The reason is that we'll actually execute whatever command is
# passed in, so including arguments on it will make the command
# actually do stuff, as opposed to just executing and quitting,
# as most commands will do when no arg is passed.
#
sub command_is_available($)
  {
    my $cmd = shift;
    my $retval = $^O =~ /MSWin/ ? system("$cmd >NUL 2>NUL") : system("$cmd >/dev/null 2>&1");
    my $failed = 0;
    $failed = 1 if $? == -1;
    #$failed = 1 if $? & 127;
    $failed = 1 if $retval != 0;
    return $failed ? 0 : 1;
  }


sub it_is_time_for_periodic_task($)
  {
    # Usage: create a task in your prefs like this:
    #
    #	$PREF{periodic_tasks}{01}{name}		= 'some_task';
    #	$PREF{periodic_tasks}{01}{enabled}	= 'yes';
    #	$PREF{periodic_tasks}{01}{period}	= 60*10; # in seconds.
    #
    # Then in the code, do this:
    #
    #	do_the_some_task_function() if it_is_time_for_periodic_task('some_task');

    my $taskname = shift;
    my $period = '';
    my $enabled = 0;
    foreach my $i (sort { $a <=> $b } keys %{$PREF{periodic_tasks}}) {
      if ($PREF{periodic_tasks}{$i}{name} eq $taskname) {
        $period = $PREF{periodic_tasks}{$i}{period};
        $enabled = $PREF{periodic_tasks}{$i}{enabled} =~ /yes/i;
      }
    }
    return unless $taskname && $enabled;
    exit_with_error qq`Error: missing or invalid period setting for periodic task "$taskname".  You must create a \$PREF{periodic_tasks}{NN}{period} setting, and set it to a number, indicating the number of seconds to wait between executions of this particular task.` unless $period =~ /^\d+$/;

    my $taskslist = $PREF{datadir} . "/periodic_tasks_log.cgi";
    create_file_if_DNE($taskslist, $PREF{writable_file_perms});
    open(my $iofh, "+<$taskslist") or die_nice qq`couldn't open taskslist file '$taskslist' for I/O: $!`;
    flock $iofh, 2;
    seek $iofh, 0, 0;
    my @contents = ();
    my $time_of_last_execution = '';
    while (<$iofh>) {
      chomp;
      if (/^(\d+):$taskname$/) {
        $time_of_last_execution = $1;
      } else {
        push @contents, "$_\n";
      }
    }

    my $it_is_time = 0;
    if (!$time_of_last_execution) {
      $it_is_time = 1;
      push (@contents, offsettime() . ":" . $taskname . "\n");
      seek $iofh, 0, 0; print $iofh @contents; truncate $iofh, tell $iofh;
      encdebug qq`This task has never been executed before, so it IS time for task $taskname.`;
    } elsif ((offsettime() - $time_of_last_execution) > $period) {
      $it_is_time = 1;
      push (@contents, offsettime() . ":" . $taskname . "\n");
      seek $iofh, 0, 0; print $iofh @contents; truncate $iofh, tell $iofh;
      encdebug qq`offsettime() - $time_of_last_execution = ` . (offsettime() - $time_of_last_execution) . qq`, which exceeds the period of $period, so it IS time for task $taskname.`;
    } else {
      encdebug qq`offsettime() - $time_of_last_execution = ` . (offsettime() - $time_of_last_execution) . qq`, which is less than $period, so it is not time for task $taskname.`;
    }

    close $iofh or die_nice qq`couldn't close taskslist file '$taskslist' after I/O: $!`;

    return $it_is_time;
  }


$PREF{regerr} = sub
  {
    # exit_with_error qq`Registration error: $PREF{internal_appname_nice} must be installed on the registered domain, as stated in your license email.`;
  };


##############################################################################
### Login-UB: ################################################################
##############################################################################


sub do_login
  {

    if ($PREF{internal_appname} eq 'userbase') {

      $PREF{admin_is_logged_in} = 0;
      $PREF{member_is_logged_in} = 0;

      # Get the user's inputted username and password:
#      my $input_username	= param($PREF{userbase_user_fieldname}) || ($PREF{on_failed_login_redirect_to} ? enc_redirect($PREF{on_failed_login_redirect_to}) : exit_with_error($TEXT{empty_username_error}));
#       my $input_password	= param($PREF{userbase_pass_fieldname}) || ($PREF{on_failed_login_redirect_to} ? enc_redirect($PREF{on_failed_login_redirect_to}) : exit_with_error($TEXT{empty_password_error}));

      my $input_username	= param($PREF{userbase_user_fieldname});
      unless (defined($input_username) and length($input_username)) {
        # No username specified.
        sleep $PREF{num_seconds_to_sleep_on_failed_login};
        enc_redirect("$PREF{login_url}?phase=ebadauth");
        # exit_with_error($TEXT{empty_username_error});
      }

      my $temp_input_password	= param($PREF{userbase_pass_fieldname});
      # If password is empty, try with default.  if it works, log user in, and set must change password.

      my $input_password = $temp_input_password;
      if (not(defined($input_password) and length($input_password))) {
        $input_password = $PREF{ahc_default_password};
      }

      my $ref = param("ref");
      my ($expiry) = ();

      $input_username = lc($input_username) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} !~ /yes/i;
      $input_username = uc($input_username) if $PREF{make_usernames_case_insensitive} =~ /yes/i && $PREF{make_case_insensitive_usernames_uppercase} =~ /yes/i;

     if (param("remember_me") eq "on") {
        if ($PREF{num_days_rememberme_cookie_lasts} !~ /^\d+$/) {
          $PREF{num_days_rememberme_cookie_lasts} = 7;
        }
        $expiry = "+$PREF{num_days_rememberme_cookie_lasts}d";
      }

      my $restrict_ip = (   ($PREF{enable_ip_address_restriction} =~ /yes/i && param("restrict_ip") =~ /on/i)   ||   ($PREF{force_ip_address_restriction} =~ /yes/i)   ) ? 1 : 0;
      $restrict_ip = 0 if $ENV{HTTP_USER_AGENT} =~ /AOL/ && $PREF{disable_ip_restriction_for_AOL_users} =~ /yes/i;

      # Get the crypted version of the input password:
      check_username_for_sql_safeness($input_username);
      my $salt = enc_sql_select("SELECT `salt` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");
      unless ($salt) {
        # ahc.  No salt - no account.
        sleep $PREF{num_seconds_to_sleep_on_failed_login};
        enc_redirect("$PREF{login_url}?phase=ebadauth");
        # exit_with_error(qq`Invalid Login`);
      }
      my $crypted_input_password = salt_and_crypt_password($input_password, $salt);

      my $account_locked = enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `username` = '$input_username';");
      if ($account_locked) {
        my $lock_expired = ! account_exceeds_failed_login_limit($input_username);
        if ($PREF{lock_expires_automatically} =~ /yes/i   &&   $lock_expired) {
          my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = FALSE WHERE `username` = '$input_username';");
          die_nice("Error: do_login(input_username='$input_username'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
        } else {
          sleep $PREF{num_seconds_to_sleep_on_failed_login};
          enc_redirect("$PREF{login_url}?phase=eacctlck");
        }
      }

      my $go = '';
      if (account_exists($input_username, $crypted_input_password, 'new_login')) {
        # Successful username/password combo.
        if (enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `username` = '$input_username';")) {
          enc_redirect("$PREF{login_url}?phase=eacctdis");
        }

        $PREF{member_is_logged_in} = 1; # technically true, but can still be revoked by later tests.
        $PREF{logged_in_userid} = my $userid = get_user_id($input_username);

        enc_redirect("$PREF{login_url}?phase=eacctpndvrf&uid=$userid&user=$input_username") if account_is_pending_email_verification($PREF{logged_in_userid});
        enc_redirect("$PREF{login_url}?phase=eacctpndpmt") if account_is_pending_payment($PREF{logged_in_userid});
        enc_redirect("$PREF{login_url}?phase=eacctpndadm") if account_is_pending_admin_approval($PREF{logged_in_userid});

        my $session_id = create_new_session_id($input_username, $crypted_input_password);
        if (my $shared_session_id = check_for_multiple_logins($userid, $input_username)) {
          $session_id = $shared_session_id;
        }
        update_loggedin_count_for_this_user($userid);

        set_cookie($PREF{site_session_cookie}, $session_id, $expiry);

        unless (enc_sql_select("SELECT `failed_logins` FROM `$PREF{user_table}` WHERE `id` = $userid;") eq '') {
          my $statement = "UPDATE `$PREF{user_table}` SET `failed_logins` = NULL WHERE `id` = $userid;";
          my $success = enc_sql_update($statement);
          die_nice("Error: do_login(id='$userid'): SQL returned '$success' instead of '1' while updating failed_logins.  SQL was: [[$statement]]") unless $success == 1;
        }

        # ahc
        unless (length($temp_input_password)) {
          # If no password entered and default password was used, force password update.
          my $statement = "UPDATE `$PREF{user_table}` SET `forcepwchng` = 1 WHERE `id` = '$userid';";
          my $success = enc_sql_update($statement);
        }

        log_user_into_db($userid, $session_id, offsettime(), $restrict_ip);
        update_logins_table($userid, $session_id);
        $PREF{admin_is_logged_in} = is_admin($PREF{logged_in_userid});

        send_login_notification_email($userid, $input_username);

        my %REDIRS = ();
        if (force_pw_change($userid)) {
          $REDIRS{force_pw_change} = $PREF{login_url_qsready} . "action=edituser&id=$userid";
        }
        if (   (my $return = param('loginreturn'))   &&   $PREF{loginreturn}{ param('loginreturn') }   ) {
          $REDIRS{loginreturn} = $PREF{loginreturn}{$return};
        }
        foreach my $pref (sort keys %PREF) {
          if ($pref =~ /^on_(.+?)_login_redirect_to$/i) {
            my $group = $1;
            if (   user_is_member_of_group($PREF{logged_in_userid}, $group)   &&   $PREF{$pref}   &&   !($PREF{admin_is_logged_in} && ($group eq $PREF{member_group_name}))   ) {
              $REDIRS{redirect} = $PREF{$pref};
              $REDIRS{redirect} =~ s/%%username%%/$input_username/g;
              #last; # Actually, don't skip out after the first one; process them all so only the last one applies.
            }
          }
        }
        $REDIRS{referer} = determine_default_login_destination($ref);

        foreach my $redir_type (split(/\s*,\s*/, "force_pw_change, $PREF{login_destination_precedence_list}")) {
          if ($REDIRS{$redir_type}) {
            $go = $REDIRS{$redir_type};
            last;
          }
        }

        enc_redirect($go);
      }

      # Else they tried to log in but failed.
      else {
        # Be sure that we do the sleep before the email, so that any
        # potential email errors don't cause us to abort early thereby
        # skipping the sleep and possibly giving away the fact that the
        # login failed.
        #

        sleep $PREF{num_seconds_to_sleep_on_failed_login};

        my $account_locked = account_exceeds_failed_login_limit($input_username, 'increment');
        if ($account_locked) {
          unless (enc_sql_select("SELECT `acct_locked` FROM `$PREF{user_table}` WHERE `username` = '$input_username'")) {
            my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `acct_locked` = TRUE WHERE `username` = '$input_username';");
            die_nice("Error: do_login(input_username='$input_username'): SQL returned '$success' instead of '1' while updating acct_locked.") unless $success == 1;
          }
        }

        update_failed_logins_table($input_username, $input_password);
        email_failed_logins_to_webmaster($input_username, $input_password);

        if ($PREF{on_failed_login_redirect_to}) {
          $go = $PREF{on_failed_login_redirect_to};

          if ($account_locked) {
            $go .= $go =~ /\?/ ? '&account_locked=1' : '?account_locked=1';
          }
        } else {
          if ($account_locked) {
            $go = "$PREF{login_url}?phase=eacctlck";
          } else {
            $go = "$PREF{login_url}?phase=ebadauth";
          }
        }

        enc_redirect($go);
      }
    } else {
      my $whence = ($qs =~ /(?:^|&)whence=(.+)/)[0]; $whence = '' if $whence =~ /(log(ged)?out|smsg=|kmsg=)/i;
      if ($ENV{REQUEST_METHOD} =~ /post/i) {
        smsg_redirect('failedlogin') if param('password') !~ /\S/;
        my $hashed_password = md5_hex(param('password'));
        my $expiry = param('persist') eq 'on' ? "+$PREF{num_days_login_lasts}d" : '';

        smsg_redirect('failedlogin') unless ($PREF{all_admin_password_hashes}{$hashed_password}   ||   $PREF{all_member_password_hashes}{$hashed_password});

        set_cookie($PREF{non_userbase_login_cookie}, $hashed_password, $expiry);
        my $ref = param('ref'); $ref = '' if $ref =~ /(log(ged)?out|smsg=|kmsg=)/i;
        $whence =~ s!_THEQS_!?!g; $whence =~ s!_ANAMP_!&!g;
        enc_redirect($ref || $whence || $PREF{here});
      } else {
        if ($PREF{all_admin_password_hashes}) {
          my $action = $PREF{internal_appname} eq 'visitorlog' ? 'action=vllogin' : 'action=login';
          $action .= $PREF{default_url_vars};
          $action .= "&amp;whence=$whence" if $whence;
          start_html_output($PREF{subtitle___login});
          print	  qq`<form method="post" id="nonub_login" action="$ENV{SCRIPT_NAME}?$action">`
            . qq`\n<p>$TEXT{Enter_the_password}</p>\n<input type="password" name="password" maxlength="200" class="default text" /><input type="hidden" name="ref" value="$ENV{HTTP_REFERER}" />`
              . ($PREF{show_keep_me_logged_in_checkbox_on_login_page} !~ /yes/i ? '' : qq`\n<br /><br /><input type="checkbox" name="persist" id="persist" /><label for="persist"> $TEXT{Keep_me_logged_in_for} $PREF{num_days_login_lasts} $TEXT{days}</label>`)
                . qq`\n<br /><br /><input type="submit" value="$TEXT{Login}" class="default button submit" />\n</form>\n`;
          print $TEXT{Forgot_password_};
          finish_html_output();
        } else {
          $TEXT{password_not_set} =~ s!%%newpw_link%%!$PREF{here_login_qsready}newpw!g;
          exit_with_output($TEXT{password_not_set});
        }
      }
    }
  }


sub check_if_logged_in()
  {
    my %cookies = get_cookies();
    ($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_realname}, $PREF{logged_in_email}, $PREF{logged_in_userid}) = (0,0,'','','','');

    if ($PREF{integrate_with_existing_login_system} =~ /yes/i   &&   $PREF{integrate_with_userbase} !~ /yes/i) {
      if ($PREF{enable_username_from_apache_auth} =~ /yes/i) {
        if (my $username = $ENV{REMOTE_USER}) {
          $PREF{logged_in_username}	= $username;
          $PREF{member_is_logged_in}	= 1;
          $PREF{admin_is_logged_in}	= $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
          $PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
        }
      } elsif ($PREF{enable_username_from_cookie} =~ /yes/i) {
        my $username = '';
        if (exists($cookies{$PREF{username_cookie_name}})   &&   ($username = $cookies{$PREF{username_cookie_name}}->value)) {
          $PREF{logged_in_username}	= $username;
          $PREF{member_is_logged_in}	= 1;
          $PREF{admin_is_logged_in}	= $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
          $PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
        }
      } elsif ($PREF{enable_username_from_php_session} =~ /yes/i) {
        my $username = '';
        if (exists $ENV{PHP_ENC_USERNAME}) # must use if(exists $foo) rather than just if($foo) so that we properly unset the variable when a user has logged out; otherwise we'd just pull it from our php-var-cache even though the user had already logged out.
          {
            $username = $ENV{PHP_ENC_USERNAME}; save_php_var_to_cache('username',$username);
          } else                # we were POSTed to?
            {
              $username = get_php_var_from_cache('username');
            }

        if ($username) {
          $PREF{logged_in_username}	= $username;
          $PREF{member_is_logged_in}	= 1;
          $PREF{admin_is_logged_in}	= $PREF{admin_usernames_list} =~ /(?:^|,)\s*$username\s*(?:,|$)/;
          $PREF{logged_in_userid}		= $PREF{admin_is_logged_in} ? -3 : -2;
        }
      } else {
        exit_with_error qq`To use \$PREF{integrate_with_existing_login_system}, you must also enable either \$PREF{enable_username_from_cookie}, \$PREF{enable_username_from_php_session}, or \$PREF{enable_username_from_apache_auth}.`;
      }
    } elsif ($PREF{integrate_with_userbase_method_b} =~ /yes/i   &&   $PREF{path_to_userbase}) {
      # Won't work on many IIS configurations where executing external commands
      # from within IIS is prevented by user account policy.  But the eval method
      # in the following block works on IIS.
      #
      my $userbase_output = `export QUERY_STRING="action=chklogin" && export SCRIPT_NAME="$PREF{userbase_local_scriptname}" && "$PREF{path_to_userbase}" 2>&1`;

      if ($userbase_output !~ /\w+/) {
        # Use "package" to create a separate namespace for this block.  This is because we're going to use
        # "eval" as a way to execute another Perl script, but we only want that script's output; we don't
        # want its globals and subroutines being imported into our namespace.  In particular we don't want
        # functions such as start_html_output() "overwriting" our own copy of that function in the main
        # namespace.
        # 
        package CALLTOUBFORLOGINCHECK;

        # Don't die/die_nice anywhere in here; we want to let the next if() check whether $userbase_output
        # is valid and then print a more useful error if not.
        #
        my $file = $PREF{path_to_userbase};
        my $file_contents = ();
        open(IN,"<$file");
        flock IN, 1;
        seek IN, 0, 0;
        while (<IN>) {
          $file_contents .= $_;
        }
        close IN;

        $file_contents =~ /(.*)/s;
        $file_contents = $1; # cheap untaint since this is our own file.

        my ($real_qs, $real_sn) = ($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME});
        ($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME}) = ("action=chklogin&print=false", $PREF{userbase_local_scriptname});
        $userbase_output = eval $file_contents;
        ($ENV{QUERY_STRING}, $ENV{SCRIPT_NAME}) = ($real_qs, $real_sn);
      }

      if ($userbase_output =~ /admin=(\d):::::member=(\d):::::username=(.*?):::::userid=(\d*?):::::group_memberships=(.*?):::::realname=(.*?):::::email=(.*?):::::(.*)/s) {
        ($PREF{admin_is_logged_in},$PREF{member_is_logged_in},$PREF{logged_in_username},$PREF{logged_in_userid},$PREF{logged_in_group_memberships},$PREF{logged_in_realname},$PREF{logged_in_email})
          = ($1,$2,$3,$4,$5,$6,$7);

        $PREF{ub_var_username}	= $PREF{logged_in_username};
        $PREF{ub_var_userid}	= $PREF{logged_in_userid};
        $PREF{ub_var_realname}	= $PREF{logged_in_realname};
        $PREF{ub_var_email}	= $PREF{logged_in_email};

        if (my $other_ub_vars = $8) {
          while ($other_ub_vars =~ /(.+?)=(.+?):::::/g) {
            $PREF{"ub_var_$1"} = $2;
            $PREF{"logged_in_$1"} = $2 unless $PREF{"logged_in_$1"};
          }
        }
      } else {
        exit_with_error("$PREF{internal_appname}: check_if_logged_in(): integrate_with_userbase_method_b failed: UserBase output was: "
                          . ($userbase_output ? 'null' : "[[ $userbase_output ]] ")
                            . qq`<br /><br />\n\nMake sure you've got UserBase itself running properly before trying this.`
                          );
      }
    } elsif (userbase_available()) {
      if (my $session_id = get_cookie($PREF{site_session_cookie})) {
        check_sessionid_for_sql_safeness($session_id);

        my ($username,$realname,$email,$id,$ip) = enc_sql_select("SELECT username,name,email,id,ip FROM `$PREF{user_table}` WHERE `mrsession` = '$session_id';");

        if ($username   &&   $id   &&   !account_is_pending($id)) {
          if (enc_sql_select("SELECT `acct_disabled` FROM `$PREF{user_table}` WHERE `id` = '$id';")) {
            enc_redirect("$PREF{login_url}?phase=eacctdis");
          }

          my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$id';");
          if (($numusers > 1) && $PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i) {
            # If there's already >1 user logged in under this username (for example, because we
            # didn't enable prevent_multiple_simultaneous_logons_per_username until after some
            # usage had already occurred), then we can't really do a one-by-one check to try and
            # decide which logins to kill, so kill them all.

            log_user_out_of_db($username, 'force');
            enc_redirect("$PREF{login_url}?phase=emultkicked");
          }

				# The IP check MUST come *after* the multiple_simultaneous_logons check, because if the
				# multiple_simultaneous_logons check fails, we need to take an action in response (namely
				# logging all the users out of the db) -- but if the IP check also fails (which is likely
				# to happen when the multiple_simultaneous_logons check fails) then we simply return, so
				# the multiple_simultaneous_logons check would never get a chance to do its db-logouts
				# if the IP check came first (and failed).
				#
          if (($PREF{enable_ip_address_restriction} =~ /yes/i && $ip) || ($PREF{force_ip_address_restriction} =~ /yes/i)) {
            enc_redirect("$PREF{login_url}?phase=eipmismatch") unless $ip eq $PREF{ip};
          }

          $PREF{logged_in_username} = $username;
          $PREF{logged_in_realname} = $realname;
          $PREF{logged_in_email} = $email; $PREF{logged_in_email} = $PREF{logged_in_username} if ($PREF{logged_in_email} !~ /.+\@.+\..+/ && $PREF{logged_in_username} =~ /.+\@.+\..+/);
          $PREF{logged_in_userid} = $id;
          $PREF{member_is_logged_in} = 1;

          if (is_admin($PREF{logged_in_userid})) {
            $PREF{admin_is_logged_in} = 1;
          }

          $PREF{ub_var_username}	= $PREF{logged_in_username};
          $PREF{ub_var_userid}	= $PREF{logged_in_userid};
          $PREF{ub_var_realname}	= $PREF{logged_in_realname};
          $PREF{ub_var_email}	= $PREF{logged_in_email};

          foreach my $customfield (get_custom_userbase_field_names($PREF{user_table})) {
            my $value = enc_sql_select("SELECT `$customfield` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}'");
            $PREF{"ub_var_$customfield"} = $value;
            $PREF{"logged_in_$customfield"} = $value unless $PREF{"logged_in_$customfield"};
          }

          check_and_update_login_session($PREF{logged_in_userid});

          if (force_pw_change($PREF{logged_in_userid})) {
            if ($PREF{internal_appname} eq 'userbase') {
              if ($qs !~ /^(logout|logoutall|action=commitedituser)$/) {
                # ahc This is the line that prevents error messages from being shown when force pw change.
		# ahc_exit("up to here 0");
                print_user_form('edit', $PREF{logged_in_userid});
                exit;
              }
            } else {
              enc_redirect("$PREF{login_url_qsready}action=edituser&id=$PREF{logged_in_userid}");
            }
          }
        }
      }
    } elsif ($PREF{all_admin_password_hashes} || $PREF{all_member_password_hashes}) {
      my $hashed_password_in_cookie = get_cookie($PREF{non_userbase_login_cookie});

      if ($hashed_password_in_cookie   &&   $PREF{all_admin_password_hashes}{$hashed_password_in_cookie}) {
        ($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}) = (1, 1, '', -3);
      } elsif ($hashed_password_in_cookie   &&   $PREF{all_member_password_hashes}{$hashed_password_in_cookie}) {
        ($PREF{admin_is_logged_in}, $PREF{member_is_logged_in}, $PREF{logged_in_username}, $PREF{logged_in_userid}) = (0, 1, '', -2);
      }
      # TODO: explicitly set 0/0/''/-1 for public?
    }
  }


sub check_and_update_login_session($)
  {
    my $userid = shift;
    my $my_session_id = get_cookie($PREF{site_session_cookie});
    my $session_id_in_db = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE `id` = $userid;");
    my $login_time = enc_sql_select("SELECT `loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid;");

    #if(   ($my_session_id == $session_id_in_db)   &&   ($login_time =~ /[1-9]/   &&   !login_session_expired($login_time))   )
    if (   ($my_session_id == $session_id_in_db)   &&   (!login_session_expired($login_time))   ) {
      update_loggedin_time($userid, $my_session_id, offsettime());
    } else {
      do_logout() if $PREF{idle_timeout} > 0;
    }
  }


sub update_loggedin_time
  {
    my ($userid, $my_session_id, $newtime) = @_;

    die_unless_numeric($userid,'userid');
    die_unless_numeric($newtime,'newtime');
    check_sessionid_for_sql_safeness($my_session_id);

    my $value_is_unchanged = $newtime == enc_sql_select("SELECT `loggedin` FROM `$PREF{user_table}` WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
    unless($value_is_unchanged) # prevent the 0E0 error, which isn't actually an error in the case that the value was unchanged.
      {
        my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = $newtime WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
        die_nice("Error: update_loggedin_time('$userid', '$my_session_id', '$newtime'): SQL returned '$success' instead of '1' while updating loggedin.") unless $success == 1;
      }

    if (db_column_exists('lastactive', $PREF{user_table})) # for backwards compatibility with older versions of apps.
      {
        my $value_is_unchanged = $newtime == enc_sql_select("SELECT `lastactive` FROM `$PREF{user_table}` WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
        unless($value_is_unchanged) # prevent the 0E0 error, which isn't actually an error in the case that the value was unchanged.
          {
            my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `lastactive` = $newtime WHERE `id` = $userid AND `mrsession` = '$my_session_id'");
            die_nice("Error: update_loggedin_time('$userid', '$my_session_id', '$newtime'): SQL returned '$success' instead of '1' while updating lastactive.") unless $success == 1;
          }
      }
  }


sub login_session_expired($)
  {
    my $loggedin_time = shift;
    return (

      (   ($PREF{idle_timeout} > 0)   &&   (offsettime() - $loggedin_time > $PREF{idle_timeout})   )

        ||

          (
            ($PREF{num_days_rememberme_cookie_lasts} > 0)
              &&
                (   offsettime()   >   ($loggedin_time + ($PREF{num_days_rememberme_cookie_lasts} * 86400))   )
              )
	);
  }


sub log_user_out_of_db
  {
    my ($username, $my_session_id) = @_;

    check_username_for_sql_safeness($username);
    check_sessionid_for_sql_safeness($my_session_id) unless $my_session_id eq 'force';

    # It's possible (and probably not particularly uncommon) that a user logs in at one location, then leaves
    # that location and his session goes idle, and then he logs in at another location with the same account.  In
    # that case, a call to log_user_out_of_db() from the first location should not actually do the db logout, 
    # because the session does not belong to him anymore.  But note that this is not an error condition, so we
    # should just silently return.
    #
    my $session_id_in_db = enc_sql_select("SELECT `mrsession` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");

    if (($my_session_id == $session_id_in_db)   ||   ($my_session_id eq 'force')) {
      my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `loggedin` = 0 WHERE LOWER(`username`) = LOWER('$username');");
      die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting loggedin to zero.") unless $success == 1;

      $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `mrsession` = '' WHERE LOWER(`username`) = LOWER('$username');");
      die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting mrsession to null.") unless $success == 1;

      my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username');");
      if ($numusers) # this check only required because of crappy old MySQL versions that fail to ever set numusers properly in the DB (??).
        {
          $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers` = 0 WHERE LOWER(`username`) = LOWER('$username');");
          die_nice("Error: log_user_out_of_db('$username', '$my_session_id'): SQL returned '$success' instead of '1' while setting numusers to zero.") unless $success == 1;
        }
    }
  }


sub do_logout
  {
    if ($PREF{internal_appname} eq 'userbase') {
      my $force_logout_all = shift; $force_logout_all = $force_logout_all eq 'all' ? 1 : 0;

      if ($PREF{we_are_virtual}) {
        print_http_headers();
        $PREF{forced_logout_link} =~ s/%%logout_url%%/$PREF{logout_url}/g;
        print $PREF{forced_logout_link};
        exit;
      } else {
        my $ref = $ENV{HTTP_REFERER};
        if ($ref) {
				# Remove the "logout" from the referrer, otherwise we'll get stuck
				# in an infinite logout loop with this Location: call.
          $ref =~ s/\?.*log(ged)?out.*//;

          $ref = '' if $ref =~ /(smsg=|kmsg=)/i; # don't redirect to any static/keyed messages that probably no longer apply now that the login state has changed.
        }

        # Delete the login cookie regardless of $PREF{member_is_logged_in}, because
        # it may be that the user has the cookie but it's invalid (expired, wrong IP,
        # etc) in which case we didn't set $PREF{member_is_logged_in}.  In that case,
        # we still want to allow the user to force a logout (i.e. delete his cookie).
        #
        delete_login_cookie();

        my $whence = '';
        if ($PREF{member_is_logged_in}) {
          if ($PREF{prevent_multiple_simultaneous_logons_per_username} =~ /yes/i   ||   $force_logout_all) {
            log_user_out_of_db($PREF{logged_in_username}, get_cookie($PREF{site_session_cookie}));
          } else {
            die_unless_numeric($PREF{logged_in_userid}, 'logged_in_userid');
            my $numusers = enc_sql_select("SELECT `numusers` FROM `$PREF{user_table}` WHERE `id` = '$PREF{logged_in_userid}';");
            if ($numusers > 1) {
              my $success = enc_sql_update("UPDATE `$PREF{user_table}` SET `numusers`=GREATEST((`numusers`-1),0) WHERE `id` = '$PREF{logged_in_userid}';");
              die_nice("Error: do_logout(): SQL returned '$success' instead of '1' while decrementing numusers column.") unless $success == 1;
            } else {
              log_user_out_of_db($PREF{logged_in_username}, get_cookie($PREF{site_session_cookie}));
            }
          }

          if ($PREF{admin_is_logged_in}   &&   $PREF{on_admin_logout_redirect_to}) {
            $PREF{on_admin_logout_redirect_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
            enc_redirect($PREF{on_admin_logout_redirect_to});
          } elsif ($PREF{member_is_logged_in}   &&   !$PREF{admin_is_logged_in}   &&   $PREF{on_member_logout_redirect_to}) # need the !admin because admins are members too.
            {
              $PREF{on_member_logout_redirect_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
              enc_redirect($PREF{on_member_logout_redirect_to});
            } else {
              # After logging out, return to the page we were on.
              $whence = $ref;
            }
        } else {
          $whence = $ref;
        }

        $whence =~ s!^https?://$ENV{HTTP_HOST}!!; # some servers don't like extra "http://"s in URLs.
        enc_urlencode($whence);
        $whence = '' if $PREF{server_bug_prohibits_use_of_whence} =~ /yes/i;
        enc_redirect("$PREF{login_url_qsready}action=loggedout&whence=$whence");
      }
    } else {
      my $go = '';
      if ($PREF{integrate_with_userbase} =~ /yes/i   ||   $PREF{integrate_with_userbase_method_b} =~ /yes/i   ||   $PREF{integrate_with_existing_login_system} =~ /yes/i) {
        $go = $PREF{logout_url};
      } else {
        set_cookie($PREF{non_userbase_login_cookie}, 'blank', '-1d');
        my $whence = $ENV{HTTP_REFERER};
        $whence =~ s!^https?://$ENV{HTTP_HOST}!!; # some servers don't like extra "http://"s in URLs.
        $whence =~ s/\?logout$//; # Remove "logout" from the ref so we don't get stuck in an infinite loop.
        $go = "$PREF{here_login_qsready}action=loggedout&whence=$whence";
      }

      if ($PREF{we_are_virtual}) {
        print_http_headers();
        if ($PREF{use_javascript_redirect_when_necessary} !~ /no/i) {
          print qq`\n<script type="text/javascript">location.href="$go";</script>\n`;
        } else {
          $PREF{forced_logout_link} =~ s/%%logout_url%%/$go/g;
          print $PREF{forced_logout_link};
        }
        exit;
      } else {
        enc_redirect($go);
      }
    }
  }


sub delete_login_cookie
  {
    set_cookie($PREF{site_session_cookie}, 0, '-1M');
  }


sub show_loggedout_page
  {
    my $ref = shift;
    enc_urldecode($ref);
    $ref = '' if $ref =~ /(log(ged)?out|smsg=|kmsg=|phase=)/i;
    my $message = $PREF{loggedout_page_template__no_referer};
    if ($ref) {
      $message = $PREF{loggedout_page_template__with_referer};
      $message =~ s/%%ref%%/$ref/g;
    }
    exit_with_success($message);
  }


sub get_logout_url
  {
    return $PREF{integrate_with_userbase} =~ /yes/i || $PREF{integrate_with_userbase_method_b} =~ /yes/i || $PREF{integrate_with_existing_login_system} =~ /yes/i ? $PREF{logout_url} : ($ENV{SCRIPT_NAME} . ($ENV{SCRIPT_NAME} =~ /\?/ ? '&' : '?') . "logout");
  }


sub get_login_url
  {
    return $PREF{integrate_with_userbase} =~ /yes/i || $PREF{integrate_with_userbase_method_b} =~ /yes/i || $PREF{integrate_with_existing_login_system} =~ /yes/i ? $PREF{login_url} : "$PREF{here_login_qsready}action=login";
  }


# This function must do a case-sensitive lookup (i.e., do NOT use LOWER()) because
# FC's userdirs are case-sensitive.  So whatever case is used when a username is
# created is the case that must always be used when logging in with it.
# UPDATE: MySQL's equal operator (=) is case-insensitive, absurdly.  To force it
# to act case-sensitively, you must use the BINARY function, as in:
#	... WHERE BINARY `username` = '$username'
#
sub account_exists($$$)
  {
    #printd "account_exists('$_[0]', '$_[1]', '$_[2]')\n";

    my $user = shift;
    my $pass = shift;
    my $third_arg = shift;

    check_username_for_sql_safeness($user);
    check_hashedpw_for_sql_safeness($pass);

    my $BINARY = $PREF{make_usernames_case_insensitive} =~ /yes/i ? '' : 'BINARY';

    my $count = ();
    if ($third_arg eq 'new_login') {
      $count = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE $BINARY `username` = '$user' AND `password` = '$pass'");
    } else {
      die_unless_numeric($third_arg,'userid');
      $count = enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE $BINARY `username` = '$user' AND `password` = '$pass' AND `id` = $third_arg");
    }

    if ($count == 1) {
      return 1;
    } elsif ($count > 1) {
      die_nice("$0: account_exists('$user', '$pass', '$third_arg'): error: duplicate records ($count total) for this user!\n");
    } else {
      return 0;
    }
  }


sub account_is_pending
  {
    return 0 if !userbase_available();
    my $userid = shift;
    die_unless_numeric($userid, "user ID in account_is_pending()");
    return (account_is_pending_email_verification($userid) || account_is_pending_admin_approval($userid) || account_is_pending_payment($userid));
  }


sub account_is_pending_email_verification
  {
    my $userid = shift;
    return ($PREF{require_email_verification_for_new_signups} =~ /yes/i) && account_is_pending_email_verification_in_db($userid);
  }


sub account_is_pending_email_verification_in_db
  {
    my $userid = shift;
    die_unless_numeric($userid, "user ID in account_is_pending_email_verification_in_db()");
    return enc_sql_select("SELECT `pending_email_verification` FROM `$PREF{user_table}` WHERE `id` = $userid");
  }


sub account_has_completed_email_verification
  {
    my $userid = shift;
    die_unless_numeric($userid, "user ID in account_has_completed_email_verification()");
    return enc_sql_select("SELECT `completed_email_verification` FROM `$PREF{user_table}` WHERE `id` = $userid");
  }


sub account_is_pending_admin_approval
  {
    my $userid = shift;
    return ($PREF{require_admin_approval_for_new_signups} =~ /yes/i) && account_is_pending_admin_approval_in_db($userid);
  }


sub account_is_pending_admin_approval_in_db
  {
    my $userid = shift;
    die_unless_numeric($userid, "user ID in account_is_pending_admin_approval_in_db()");
    return enc_sql_select("SELECT `pending_admin_approval` FROM `$PREF{user_table}` WHERE `id` = $userid");
  }


sub account_is_pending_payment
  {
    my $userid = shift;
    die_unless_numeric($userid, "user ID in account_is_pending_payment()");
    return enc_sql_select("SELECT `pending_payment` FROM `$PREF{user_table}` WHERE `id` = $userid");
  }


sub account_has_completed_payment
  {
    my $userid = shift;
    die_unless_numeric($userid, "user ID in account_has_completed_payment()");
    return enc_sql_select("SELECT COUNT(*) FROM `$PREF{payments_table}` WHERE `userid` = $userid");
  }


sub get_custom_userbase_field_names
  {
    my $which_user_table = shift;
    my $include_disabled_fields = shift;

    my (@custom_fields, %custom_fields) = ();
    if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{custom_field_list_table}`")) {
      my ($fieldname,$fieldlabel,$enabled) = ();
      my $sth = $PREF{dbh}->prepare("SELECT fieldname,fieldlabel,enabled FROM `$PREF{custom_field_list_table}` ORDER BY `fieldposition`");
      $sth->execute() or die_nice("$PREF{internal_appname}: Error: get_custom_userbase_field_names(): $DBI::errstr\n");
      $sth->bind_columns(\$fieldname,\$fieldlabel,\$enabled);
      while ($sth->fetchrow_arrayref) {
        next unless db_column_exists($fieldname, $which_user_table);
        next if (!$enabled   &&   !$include_disabled_fields);
        $custom_fields{$fieldname} = 1;
        push @custom_fields, $fieldname;
      }
    }

    return wantarray ? @custom_fields : \%custom_fields;
  }


sub is_admin($)
  {
    #printd "is_admin('$_[0]')\n";

    my $userid = shift;
    return 0 unless $userid;

    return 1 if (!userbase_available()   &&   $userid == -3);

    # don't bother checking the validity of $userid here,
    # because user_is_member_of_group() will do it.
    return user_is_member_of_group($userid,$PREF{admin_group_name});
  }


  sub force_pw_change($)
    {
      my $userid = shift;
      my $force_pw_change = 0;

      if ($PREF{enable_forced_password_change} =~ /yes/i
            &&
              enc_sql_select("SELECT `forcepwchng` FROM `$PREF{user_table}` WHERE `id` = '$userid';")
                &&
                  (
                    !is_admin($userid)
                      ||
                        (is_admin($userid) && $PREF{admins_can_be_forced_to_change_their_own_pws} =~ /yes/i)
                      )
                ) {
        $force_pw_change = 1;
      }
      
      if (password_has_expired()) {
        $force_pw_change = 1;
      }
      
      return $force_pw_change;
    }
    

sub password_has_expired
  {
    my $expired = 0;
    if ($PREF{force_pw_chng_after_this_many_hours} =~ /^\d+$/ && $PREF{force_pw_chng_after_this_many_hours} > 0) {
      unless ($PREF{admin_is_logged_in} && $PREF{admins_can_be_forced_to_change_their_own_pws} =~ /no/i) {
        my $time_now = offsettime();
        die_unless_numeric($PREF{logged_in_userid}, '$PREF{logged_in_userid}');
        my $time_of_last_pw_change = enc_sql_select("SELECT MAX(`timestamp`) FROM `$PREF{password_activity_table}` WHERE `user_id` = $PREF{logged_in_userid}");
        $expired = 1 if ($time_now - $time_of_last_pw_change) > ($PREF{force_pw_chng_after_this_many_hours} * 3600);
      }
    }
    return $expired;
  }


sub get_group_id($)
  {
    printd "get_group_id($_[0])\n";
    my $group = shift;

    if (userbase_available()) {
      check_groupname_for_uniqueness($group); # checks for sql safeness too.
      return enc_sql_select("SELECT `id` FROM `$PREF{group_table}` WHERE `group` = '$group'");
    } else {
      if ($group =~ /^$PREF{public_group_name}$/i) {
        return -1;
      } elsif ($group =~ /^$PREF{member_group_name}$/i) {
        return -2;
      } elsif ($group =~ /^$PREF{admin_group_name}$/i) {
        return -3;
      } else {
        die_nice("invalid group name '$group'.\n");
      }
    }
  }


sub check_uid_for_uniqueness($)
  {
    die_unless_numeric($_[0], 'user ID');
    check_id_for_sql_safeness($_[0]);
    if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `id` = $_[0]")   >   1) {
      die_nice("more than one user record with id=$_[0]!\n");
    }
  }


sub check_gid_for_uniqueness($)
  {
    return unless userbase_available();
    printd "check_gid_for_uniqueness: '$_[0]'\n";

    check_id_for_sql_safeness($_[0]);
    if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE `id` = $_[0]")   >   1) {
      die_nice("more than one group record with id=$_[0]!\n");
    }
  }


sub check_username_for_uniqueness($)
  {
    #printd "check_username_for_uniqueness: '$_[0]'\n";

    check_username_for_sql_safeness($_[0]);
    if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$_[0]')")   >   1) {
      die_nice("more than one user record with username='$_[0]'!\n");
    }
  }


sub check_groupname_for_uniqueness
  {
    return unless userbase_available();
    printd "check_groupname_for_uniqueness($_[0])\n";

    check_groupname_for_sql_safeness($_[0]);
    if (enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$_[0]')")   >   1) {
      die_nice("more than one user record with groupname='$_[0]'!\n");
    }
  }


sub user_is_member_of_group
  {
    my $userid = shift;
    my $group = shift;
    my $not_checking_loggedin_user = shift;

    if ($PREF{integrate_with_userbase_method_b} =~ /yes/i   &&   $PREF{logged_in_group_memberships}   &&   !$not_checking_loggedin_user) {
      return $PREF{logged_in_group_memberships} =~ /(^|,)$group(,|$)/;
    }
    if (userbase_available()   &&   ($PREF{member_is_logged_in} || $not_checking_loggedin_user)) {
      check_groupname_for_sql_safeness($group);
      die_unless_numeric($userid,'userid');

      return 1 if $group =~ /^$PREF{public_group_name}$/i;
      return 1 if $group =~ /^$PREF{member_group_name}$/i && enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE `id` = $userid;");

      # special internal groups:
      return 1 if $group eq 'encwhitelisted' && $PREF{user_is_encwhitelisted};
      return 1 if $group eq 'encblacklisted' && $PREF{user_is_encblacklisted};

      return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group') AND `members` REGEXP '(^|,)$userid(,|\$)'");
    } else {
      # special internal groups:
      return 1 if $group eq 'encwhitelisted' && $PREF{user_is_encwhitelisted};
      return 1 if $group eq 'encblacklisted' && $PREF{user_is_encblacklisted};

      return 1 if $group =~ /^$PREF{public_group_name}$/i;
      return 1 if $group =~ /^$PREF{member_group_name}$/i && $userid =~ /^-(2|3)$/;
      return 1 if $group =~ /^$PREF{admin_group_name}$/i && $userid == -3;
    }
  }


sub user_belongs_to_one_of_these_group_ids($$)
  {
    my $uid = shift;
    my $idlist = shift; # list of numeric group IDs separated either by commas or "|||".
    $idlist =~ s!\|\|\|!,!g;
    my $belongs = 0;
    foreach my $gid (split(/\s*,\s*/, $idlist)) {
      #$belongs = 1 if user_is_member_of_group($uid, get_group_name($gid));
      if (user_is_member_of_group($uid, get_group_name($gid))) {
        #encdebug qq`user $uid IS member of group ` . get_group_name($gid) . qq` (list=$idlist)`;
        $belongs = 1;
      }
    }
    return $belongs;
  }


sub logged_in_user_belongs_to_one_of_these_group_ids($)
  {
    return user_belongs_to_one_of_these_group_ids($PREF{logged_in_userid}, $_[0]);
  }


sub userbase_available
  {
    return ($PREF{internal_appname} eq 'userbase'   ||   $PREF{integrate_with_userbase} =~ /yes/i   ||   $PREF{integrate_with_userbase_method_b} =~ /yes/i);
  }


sub get_user_id($)
  {
    #printd "get_user_id('$_[0]')\n";

    my $username = shift;

    if (userbase_available()   &&   $username) {
      die_nice("Error: invalid username '$username'.\n") unless username_is_valid($username);
      check_username_for_uniqueness($username); # checks for sql safeness too.
      return enc_sql_select("SELECT `id` FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$username')");
    } else {
      if ($PREF{admin_is_logged_in}) {
        return -3;
      } elsif ($PREF{member_is_logged_in}) {
        return -2;
      } else {
        return -1;
      }                         # public.
    }
  }


sub get_member_ids_for_group
  {
    printd "get_member_ids_for_group($_[0])\n";

    my $group = shift;
    check_groupname_for_sql_safeness($group);

    # every account is automatically a member of these groups.
    if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i) {
      my $statement = "SELECT `id` FROM `$PREF{user_table}`";
      return $PREF{dbh}->selectall_hashref($statement, 'id');
    } else {
      my $member_ids = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')");
      my %member_ids = map { $_ => 1 } split(/,/, $member_ids);
      return \%member_ids;
    }
  }


# 20110404: APICHANGE: previously this sub accepted just a single argument,
# which was the group name.  Now it accepts an anonymous hash.
#
sub get_users_belonging_to_group
  {
    # Example usage:
    #my $users = get_users_belonging_to_group({ group=>'member' });
    #foreach my $uid (keys %$users)
    #{
    #	print qq`Name: $$users{$uid}{name}, Email: $$users{$uid}{email} <br /><br />`;
    #}

    my $optsref = shift; my %opts = %$optsref if $optsref;

    my $group = $opts{group};
    check_groupname_for_sql_safeness($group);
    my $userids = '';

    if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i) {
      my $userids_hashref = enc_sql_select_multi("SELECT `id` FROM `$PREF{user_table}`");
      foreach my $j (sort { $a <=> $b } keys %$userids_hashref) {
        $userids .= $$userids_hashref{$j}{id} . ",";
      }
      decommaify($userids);
    } else {
      $userids = enc_sql_select("SELECT `members` FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group')");
    }

    my %users = ();
    foreach my $uid (split(/,/, $userids)) {
      die_unless_numeric($uid, 'user ID');
      next if $opts{exclude_pending} && account_is_pending($uid);
      next if $opts{exclude_admins} && is_admin($uid);
      my $userdata = enc_sql_select_multi("SELECT * FROM `$PREF{user_table}` WHERE `id` = $uid");
      foreach my $field (keys %{$$userdata{1}}) {
        $users{$uid}{$field} = $$userdata{1}{$field};
      }
    }

    return \%users;
  }


sub get_user_name($)
  {
    check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
    return enc_sql_select("SELECT `username` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
  }


sub get_group_name($)
  {
    my $gid = shift;
    if (userbase_available()) {
      check_gid_for_uniqueness($gid); # checks for sql safeness too.
      return enc_sql_select("SELECT `group` FROM `$PREF{group_table}` WHERE `id` = $gid");
    } else {
      if ($gid == -1) {
        return $PREF{public_group_name};
      } elsif ($gid == -2) {
        return $PREF{member_group_name};
      } elsif ($gid == -3) {
        return $PREF{admin_group_name};
      } else {
        die_nice("$PREF{internal_appname}: get_group_name(): invalid group ID '$gid'.\n");
      }
    }
  }


sub get_email_address($)
  {
    return unless userbase_available();
    check_uid_for_uniqueness($_[0]); # checks for sql safeness too.
    my ($username,$email) = enc_sql_select("SELECT `username`,`email` FROM `$PREF{user_table}` WHERE `id` = $_[0]");
    $email = $username if is_valid_email_address($username) && !is_valid_email_address($email);
    return $email;
  }


sub hashedpw_is_valid				{ return  $_[0] =~ /^[0-9A-Za-z]+$/					&&	length($_[0]) <= $PREF{max_hashedpw_length};	}
sub sessionid_is_valid				{ return  $_[0] =~ /^[0-9A-Za-z]+$/					&&	length($_[0]) <= $PREF{max_hashedpw_length};	}


sub username_is_valid
  {
    my $space = $PREF{allow_spaces_in_usernames} =~ /yes/i ? ' ' : '';
    my $atsign = $PREF{allow_atsigns_in_usernames} =~ /yes/i ? '@' : '';
    my $dot = $PREF{allow_dots_in_usernames} =~ /yes/i ? '.' : '';
    my $dash = $PREF{allow_dashes_in_usernames} =~ /yes/i ? '-' : '';

    return ($_[0] =~ /^[0-9A-Za-z_$space$atsign$dot$dash]+$/   &&   $_[0] =~ /\w/	&&	length($_[0]) <= $PREF{max_username_length});
  }

sub groupname_is_valid
  {
    my $space	= ($PREF{allow_spaces_in_usernames} =~ /yes/i	|| $PREF{allow_spaces_in_groupnames} =~ /yes/i)		? ' ' : '';
    my $atsign	= ($PREF{allow_atsigns_in_usernames} =~ /yes/i	|| $PREF{allow_atsigns_in_groupnames} =~ /yes/i)	? '@' : '';
    my $dot		= ($PREF{allow_dots_in_usernames} =~ /yes/i	|| $PREF{allow_dots_in_groupnames} =~ /yes/i)		? '.' : '';
    my $dash	= ($PREF{allow_dashes_in_usernames} =~ /yes/i	|| $PREF{allow_dashes_in_groupnames} =~ /yes/i)		? '-' : '';

    return ($_[0] =~ /^[0-9A-Za-z_$space$atsign$dot$dash]+$/   &&   $_[0] =~ /\w/	&&	length($_[0]) <= $PREF{max_groupname_length});
  }

sub check_hashedpw_for_sql_safeness		{ die_nice(qq`Invalid hashed password:	'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless hashedpw_is_valid($_[0]);	}
sub check_username_for_sql_safeness		{ die_nice(qq`Invalid username:		'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless username_is_valid($_[0]);	}
sub check_groupname_for_sql_safeness		{ die_nice(qq`Invalid groupname:	'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless groupname_is_valid($_[0]);	}
sub check_sessionid_for_sql_safeness		{ die_nice(qq`Invalid session ID:	'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless sessionid_is_valid($_[0]);	}
sub check_id_for_sql_safeness			{ die_nice(qq`Invalid ID:		'$_[0]' [called from: ` . (caller 1)[3]  . qq`]`) unless $_[0] =~ /^(\d+|-[123])$/;	}


sub get_groups_hash
  {
    printd "get_groups_hash('$_[0]')\n";

    # If you pass in a uid, then the resulting hash will
    # also indicate which groups that user is a member of.
    #

    my $user_id = shift;

    my ($id, $group, $members, %groups) = ();
    if (userbase_available()) {
      my $sth = $PREF{dbh}->prepare("SELECT `id`, `group`, `members` FROM `$PREF{group_table}`");
      $sth->execute();
      $sth->bind_columns(\$id, \$group, \$members);
      while ($sth->fetchrow_arrayref) {
        $groups{$group}{name} = $group;
        $groups{$group}{id} = $id;
        $groups{$group}{members} = $members;

        my $is_member = ();
        if ($group =~ /^($PREF{public_group_name}|$PREF{member_group_name})$/i) {
          $is_member = 1;
        } elsif ($user_id =~ /^\d+$/) {
          $is_member = $members =~ /(^|,)$user_id(,|$)/;
        }

        $groups{$group}{is_member} = $is_member;
      }
    } else {
      $groups{$PREF{public_group_name}}{name}		= $PREF{public_group_name};
      $groups{$PREF{public_group_name}}{id}		= -1;
      $groups{$PREF{public_group_name}}{is_member}	= 1; # everyone's a member of the public.

      $groups{$PREF{member_group_name}}{name}		= $PREF{member_group_name};
      $groups{$PREF{member_group_name}}{id}		= -2;
      $groups{$PREF{member_group_name}}{is_member}	= 1 if $user_id =~ /^-(2|3)$/;

      $groups{$PREF{admin_group_name}}{name}		= $PREF{admin_group_name};
      $groups{$PREF{admin_group_name}}{id}		= -3;
      $groups{$PREF{admin_group_name}}{is_member}	= 1 if $user_id =~ /^-3$/;
    }

    return \%groups;
  }


sub get_email_addresses_for_all_members_of_this_users_groups
  {
    my $uid = shift; die_unless_numeric($uid, "user ID");
    my $include_users_own_email_address = shift; $include_users_own_email_address = 0 unless $include_users_own_email_address eq 'include_users_own_email_address';
    my $include_builtin_public_group = shift;    $include_builtin_public_group    = 0 unless $include_builtin_public_group    eq 'include_builtin_public_group';
    my $include_builtin_member_group = shift;    $include_builtin_member_group    = 0 unless $include_builtin_member_group    eq 'include_builtin_member_group';
    my $include_builtin_admin_group = shift;     $include_builtin_admin_group     = 0 unless $include_builtin_admin_group     eq 'include_builtin_admin_group';

    my %email_addresses = ();
    my $allgroups = get_groups_hash($uid);
    foreach my $group (sort keys %$allgroups) {
      next if $group =~ /^$PREF{public_group_name}$/i && !$include_builtin_public_group;
      next if $group =~ /^$PREF{member_group_name}$/i && !$include_builtin_member_group;
      next if $group =~ /^$PREF{admin_group_name}$/i  && !$include_builtin_admin_group;

      if (my $this_user_belongs_to_this_group = $$allgroups{$group}{is_member}) {
        foreach my $member_id (split(/\s*,\s*/, $$allgroups{$group}{members})) {
          my $email = get_email_address($member_id);
          $email_addresses{ $email } = 1 unless !$include_users_own_email_address && $email eq $PREF{logged_in_email};
        }
      }
    }
    return keys %email_addresses; # returns an array when this sub is called in list context.
  }


# This function must do a case-insensitive lookup (i.e. use LOWER() on both sides)
# so that we never create a username multiple times with different cases.
#
sub username_is_taken
  {
    return 0 unless userbase_available();
    my $user = shift;
    check_username_for_sql_safeness($user);
    return enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`username`) = LOWER('$user')");
  }


sub email_address_is_taken
  {
    my $address = shift;
    check_emailaddr_for_sql_safeness($address);
    return enc_sql_select("SELECT COUNT(*) FROM `$PREF{user_table}` WHERE LOWER(`email`) = LOWER('$address')");
  }


sub salt_and_crypt_password($$)
  {
    my $plaintext_password = shift;
    my $salt = shift;
    $plaintext_password = lc($plaintext_password) if $PREF{make_passwords_case_insensitive} =~ /yes/i;
    die "$0: salt_and_crypt_password(): no salt?\n" unless $salt;
    my ($salt1,$salt2) = ($salt =~ /^(.{15})(.{25})$/);
    my $crypted_password = enc_hash($salt1 . $plaintext_password . $salt2);
    return $crypted_password;
  }


sub make_password_hash
  {
    if ($ENV{REQUEST_METHOD} =~ /post/i) {
      my $hashed_password = md5_hex(param('password'));
      start_html_output('Here is your hashed password...');
      print	  qq`<p>The hashed version of the password you just entered is:</p><p>$hashed_password</p>`
        . qq`<p>Now open your prefs file and paste this hash into one of the `
          . qq`\n\$PREF{admin_password_hash*} or \$PREF{member_password_hash*} settings.</p>`;
      finish_html_output();
		
    } else {
      start_html_output('Enter your new password');
      print	  qq`<form method="post" action="$ENV{SCRIPT_NAME}?newpw">`
        . qq`\nEnter your new password:`
          . qq`\n<br /><br /><input type="password" name="password" maxlength="200" class="default text" />`
            . qq`\n<br /><br /><input type="submit" value="create hash" class="default button submit" />`
              . qq`\n</form>`;
      finish_html_output();
    }
  }


sub user_is_allowed_to
  {
    # TODO: these separate per-app branches can probably be partially or totally reconciled.

    if ($PREF{internal_appname} eq 'userbase') {
      my $userid_performing_action = scalar(@_) == 1 ? $PREF{logged_in_userid} : shift; # if only 1 arg was passed, it's the action, implying we should automatically use the logged_in_userid.
      my $action = shift;
      my $user_affected_by_action = shift;
      my $userid_affected_by_action = get_user_id($user_affected_by_action);

      if ($action eq 'edit_user_info') {
        return 1 if (logged_in_user_is_subgroup_manager()   &&   $userid_affected_by_action   &&   logged_in_subgroup_manager_owns_this_user($userid_affected_by_action));
      }

      foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"})) {
        return 0 if user_is_member_of_group($userid_performing_action, $group);
      }

      foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"})) {
        if ($group =~ /^self$/i) {
          return 0 if ($PREF{member_is_logged_in}   &&   $userid_performing_action == $userid_affected_by_action);
        } else {
          return 0 if user_is_member_of_group($userid_performing_action, $group);
        }
      }

      foreach my $group (split(/\s*,\s*/, $PREF{"groups_allowed_to_$action"})) {
        if ($group =~ /^self$/i) {
          return 1 if ($PREF{member_is_logged_in}   &&   $userid_performing_action == $userid_affected_by_action);
        } else {
          return 1 if user_is_member_of_group($userid_performing_action, $group);
        }
      }

      return 0;
    } else {
      my $action = shift;
      foreach my $group (split(/\s*,\s*/, $PREF{"groups_not_allowed_to_$action"})) {
        return 0 if user_is_member_of_group($PREF{logged_in_userid}, $group);
      }
      foreach my $group (split(/\s*,\s*/, $PREF{"groups_allowed_to_$action"})) {
        return 1 if user_is_member_of_group($PREF{logged_in_userid}, $group);
      }
      return 0;
    }
  }


sub logged_in_user_is_part_of_a_subgroup()
  {
    #foreach my $group (enc_sql_select("SELECT "))
    #{
    #	if($group =~ /.+$PREF{subgroup_groupname_suffix}$/i)
    #	{
    #		return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE LOWER(`group`) = LOWER('$group') AND `members` REGEXP '(^|,)$PREF{logged_in_userid}(,|\$)'");
    #	}
    #}

    my $subgroup_groupname_suffix = $PREF{subgroup_groupname_suffix};
    sql_untaint($subgroup_groupname_suffix);
    exit_with_error("logged_in_user_is_part_of_a_subgroup() not SQL safe: \$subgroup_groupname_suffix ('$subgroup_groupname_suffix').") if not_sqlsafe($subgroup_groupname_suffix);

    die_unless_numeric($PREF{logged_in_userid}, '$PREF{logged_in_userid}');

    return enc_sql_select("SELECT COUNT(*) FROM `$PREF{group_table}` WHERE `group` REGEXP '.+$subgroup_groupname_suffix\$' AND `members` REGEXP '(^|,)$PREF{logged_in_userid}(,|\$)'");
  }


sub logged_in_user_is_subgroup_manager
  {
    foreach my $group (split(/\s*,\s*/, $PREF{groups_that_can_manage_subgroup_users})) {
      return 1 if user_is_member_of_group($PREF{logged_in_userid}, $group);
    }
    return 0;
  }


sub logged_in_subgroup_manager_owns_this_user($)
  {
    my $userid_to_check = shift;
    return user_is_member_of_group($userid_to_check, "$PREF{logged_in_username}$PREF{subgroup_groupname_suffix}");
  }


sub user_is_subgroup_manager
  {
    my $username = shift;
    my $userid = get_user_id($username);
    foreach my $group (split(/\s*,\s*/, $PREF{groups_that_can_manage_subgroup_users})) {
      return 1 if user_is_member_of_group($userid, $group, 1);
    }
    return 0;
  }


sub this_subgroup_manager_owns_this_user($$)
  {
    my $subgroup_manager_userid = shift;
    my $userid_to_check = shift;
    my $subgroup_manager_username = get_user_name($subgroup_manager_userid);
    return user_is_member_of_group($userid_to_check, "${subgroup_manager_username}$PREF{subgroup_groupname_suffix}");
  }


sub exit_with_access_denied
  {
    exit_with_needprivs();
  }


##############################################################################
### Dispatch-UB: #############################################################
##############################################################################


load_prefs();

if ($qs eq 'logout') {
  do_logout();
} elsif ($qs eq 'logoutall') {
  do_logout('all');
}

# Note: this must happen before most other checks in the dispatch chain, to prevent stuff that doesn't belong in the mini or justlink modes from showing up there.
elsif ($qs =~ /(?:^|&)format=justlink(?:&|$)/) {
  print_login_logout_link_and_exit();
} elsif ($qs =~ /(?:^|&)format=loginstatus(?:&|$)/) {
  print_login_status_and_exit();
} elsif ($qs =~ /(?:^|&)format=mini(?:&|$)/) {
  # ahc
  my $whereto = $PREF{member_is_logged_in} ? 'a' : $qs =~ /action=validate/ ? 'b' : 'c';

  $PREF{member_is_logged_in} ? print_main_menu() : $qs =~ /action=validate/ ? do_login() : prompt_for_login();
}

# Note: this must happen before most other checks in the dispatch chain, because of things like action=serverinfo which are valid for multiple
# apps including UB.  F.e. if FC redirects to UB to get auth for serverinfo, we want to display the login page, not our own serverinfo page.
# TODO: might need to tweak this though, for the case where a member *is* logged in but doesn't have *enough* privs for the requested page.
elsif ($qs =~ /(?:^|&)needprivs=true(?:&|$)/) {
  $PREF{member_is_logged_in} ? print_main_menu() : prompt_for_login();
} elsif ($qs =~ /(?:^|&)kmsg=(\w+)(?:&|$)/) {
  exit_with_kmsg($1);
} elsif ($qs =~ /(?:^|&)smsg=(\w+)(?:&|$)/) {
  exit_with_error($TEXT{The_password_you_entered_is_incorrect___}) if $1 eq 'failedlogin';
  exit_with_error($TEXT{"smsg_$1"}) if $TEXT{"smsg_$1"}; # for text strings that are entirely static, name them $TEXT{smsg_foo}.
} elsif ($qs =~ /createrandomadmin/ && $PREF{allow_random_admin_account_creation} =~ /yes/i) {
  create_random_admin_account_and_exit();
} elsif ($qs =~ /(?:^|&)action=loggedout(?:&whence=(.*))?(?:&|$)/) {
  $PREF{member_is_logged_in} ? enc_redirect($PREF{here}) : show_loggedout_page($1);
} # note that the whence regex is .* not .*? because the value will likely contain ampersands that we want to keep.
elsif ($qs =~ /(?:^|&)action=showusers(?:&|$)/) {
  showusers();
} elsif ($qs =~ /(?:^|&)action=showuserstest(?:&|$)/) {
  showusers_new();
} elsif ($qs =~ /(?:^|&)action=userinfo&id=(\d+)(?:&|$)/) {
  show_user_info($1);
} elsif ($qs =~ /(?:^|&)action=(signup|newaccount)(?:&|$)/) {
  print_user_form('user_signup');
} elsif ($qs =~ /(?:^|&)action=adduser(?:&|$)/) {
  print_user_form('added_by_admin');
} elsif ($qs =~ /(?:^|&)action=edituser(?:&|$)/) {
  print_user_form('edit');
} elsif ($qs =~ /(?:^|&)action=commitadduser(?:&|$)/) {
  process_new_account();
} elsif ($qs =~ /(?:^|&)action=commitedituser(?:&|$)/) {
  edit_user_account();
} elsif ($qs =~ /(?:^|&)action=verify&u=(\d+)&t=(\w+)(?:&|$)/) {
  do_email_verification($1,$2);
} elsif ($qs =~ /(?:^|&)action=resendvrfemail(?:&|$)/) {
  resend_verification_email();
} elsif ($qs =~ /(?:^|&)action=approve_or_del&uid=(\d+)(?:&|$)/) {
  approve_or_delete_pending_account($1);
} elsif ($qs =~ /(?:^|&)action=approve_pending_acct&uid=(\d+)(?:&|$)/) {
  approve_or_delete_pending_account_stage2($1,'approve');
} elsif ($qs =~ /(?:^|&)action=delete_pending_acct&uid=(\d+)(?:&|$)/) {
  approve_or_delete_pending_account_stage2($1,'delete');
} elsif ($qs =~ /(?:^|&)action=showlogins(?:&|$)/) {
  show_logins();
} elsif ($qs =~ /(?:^|&)action=showfailedlogins(?:&|$)/) {
  show_failed_logins();
} elsif ($qs =~ /(?:^|&)action=showpwlog(?:&|$)/) {
  show_password_activity();
} elsif ($qs =~ /(?:^|&)action=infoupdates(?:&|$)/) {
  show_userinfo_updates();
} elsif ($qs =~ /(?:^|&)action=changeimage(?:&|$)/) {
  change_profile_image();
} elsif ($qs =~ /(?:^|&)action=viewuser(?:&|$)/) {
  show_user_profile();
} elsif ($qs =~ /(?:^|&)action=memberdirectory(?:&|$)/) {
  show_member_directory();
} elsif ($qs =~ /(?:^|&)action=commitdeleteuser&id=(.+?)(?:&|$)/) {
  commit_delete_user($1);
}

# new group-management subs:
elsif ($qs =~ /(?:^|&)action=groups(?:&|$)/) {
  show_groups_table();
} elsif ($qs =~ /(?:^|&)action=validate(?:&|$)/) {
  do_login();
} elsif ($qs =~ /(?:^|&)action=chklogin(?:&|$)/) {
  check_login();
}
#elsif($qs =~ /(?:^|&)action=chpw(?:&|$)/)				{ chpw();		}
#elsif($qs =~ /(?:^|&)action=chpw2(?:&|$)/)				{ chpw2();		}

# new custom fields manager:
elsif ($qs =~ /(?:^|&)action=customfields(?:&|$)/) {
  show_custom_fields_manager();
} elsif ($qs =~ /(?:^|&)action=fieldsections(?:&|$)/) {
  show_field_sections_manager();
} elsif ($qs =~ /(?:^|&)action=import(?:&|$)/) {
  import_users();
} elsif ($qs =~ /(?:^|&)action=csvimport(?:&|$)/) {
  import_users_from_CSV_file();
} elsif ($qs =~ /(?:^|&)action=csvexport(?:&|$)/) {
  export_users_to_CSV_file();
} elsif (get_qs_var('action') eq 'showprefs') {
  show_prefs();
} elsif (get_qs_var('action') eq 'serverinfo') {
  show_server_info();
} elsif ($qs =~ /(?:^|&)action=pwreset1(?:&|$)/) {
  print_pwreset_page();
} elsif ($qs =~ /(?:^|&)action=pwreset2(?:&|$)/) {
  send_pwreset_email();
} elsif ($qs =~ /(?:^|&)action=pwreset3(?:&|$)/) {
  process_pwreset();
} elsif ($qs =~ /(?:^|&)action=test(?:&|$)/) {
  test_function();
} elsif ($qs =~ /(?:^|&)rslt=\d+(?:&|$)/) {
  show_results_page();
} elsif ($qs =~ /(?:^|&)phase=([es].+?)(?:&|$)/) {
  show_message($1);
} elsif ($qs =~ /(?:^|&)action=startpayment&type=(\d+)&uid=(\d+)(?:&|$)/) {
  print_payment_form($1,$2);
} elsif ($qs =~ /(?:^|&)action=confirmpayment(?:&|$)/) {
  print_payment_confirmation_page();
} elsif ($qs =~ /(?:^|&)action=editmainmenu(?:&|$)/) {
  edit_main_menu();
} elsif ($qs =~ /(?:^|&)action=groupmenu(?:&|$)/) {
  print_group_menu();
} elsif ($qs =~ /(?:^|&)pdir=(\d+)&ppge=(.+)(?:&|$)/) {
  display_protected_page_simple($1,$2);
} elsif ($qs =~ /(?:^|&)(?:protectedpage|ppge)=(.+)(?:&|$)/) {
  display_protected_page($1);
} elsif (get_qs_var('action') eq 'calendar') {
  show_event_calendar();
} elsif (get_qs_var('action') eq 'calendarlog') {
  show_event_calendar_reminderlog();
} elsif ($qs =~ /(?:^|&)action=imagemodules(?:&|$)/) {
  check_image_modules();
} elsif ($qs =~ /do_email_test/ && ($PREF{enable_email_test} =~ /yes/i || $PREF{admin_is_logged_in})) {
  do_email_test();
} elsif ($qs =~ /^webconfig$/ || $qs =~ /action=webconfig/) {
  do_web_config();
} elsif ($qs =~ /(?:^|&)action=showipndata(?:&|$)/) {
  show_ipn_data();
} elsif (!$qs && $ENV{REQUEST_METHOD} =~ /post/i) {
  do_paypal_ipn();
} else {
  if ($PREF{admin_is_logged_in}   &&   $PREF{always_redirect_admins_to}) {
    $PREF{always_redirect_admins_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
    enc_redirect($PREF{always_redirect_admins_to});
  } elsif ($PREF{member_is_logged_in}   &&   !$PREF{admin_is_logged_in}   &&   $PREF{always_redirect_members_to}) # need the !admin because admins are members too.
    {
      $PREF{always_redirect_members_to} =~ s/%%username%%/$PREF{logged_in_username}/g;
      enc_redirect($PREF{always_redirect_members_to});
    } else {
      if ($PREF{member_is_logged_in} && $qs !~ /forceloginform=true/) {
        print_main_menu();
      } else {
        prompt_for_login();
      }
    }
}
# print STDERR "UBruntime=" . (gettimeofday() - $PREF{script_start_time_highres}) . "\n";

