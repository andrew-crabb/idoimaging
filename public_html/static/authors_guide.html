A guide for open source authors

I've seen a lot of open source imaging programs, hundreds of them.
Here are a few points that I've noticed help make a program useful and
effective.

Caveat/Disclaimer: I break most of these rules in my own software.  I
don't collaborate well (or at all).  I've never released a major
software project (just lots of little ones).

A clever idea is a good start.

When the program is finished, you're about half done.
Think of all the other work people have to go to, to actually utilize
your program.  Provide a reliable installer, and make the installation
clean.  Don't make people use a certain path, or set environment
variables, or install obscure software (other than yours...or mine).

Go ahead and reinvent the wheel.
If there's one thing the world needs, it's another half-complete DICOM
viewer, and it needs you to write it.  After you have, go back to
using one of the stable, publically available DICOM viewers, and write
something that fulfils a need.

People love a good website...and a snappy URL.
A good website makes a good impression, and people are more likely to
stick around to check out your software.  You can register a URL for
under $10 a year, and host a simple site with that dedicated URL for
not much more than that per year.  Now you have your very own top
level domain name, and you're letting someone else take care of the
problems of running the server.  Further, you have a nice stable Web
address that people can remember, bookmark, and revisit.

Make your project easy to track.
Include the version number, release date, and notes clearly on your
web site.  This makes it easy for automated crawlers (including mine)
to keep track of your releases.

Release early, release often.
Get something out there.  It will inspire you to continue development,
and you may even get some feedback.

Don't die quietly.
If you want your program to play nicely with others, be scrupulous
about catching errors and reporting them.  Try to think of how your
software might fail (hard to believe, I know, but your program might
crash some day).  Catch the errors through return codes or exceptions,
and quit with a message and an error code.  This will give your user
(who might be a person, or another program) a chance to fail
gracefully.  The worst thing that can happen is if your program does
not die on an error condition, so the system sails on thinking
everything is just fine.  

Think of the system, not just the software.
Your program is part of the processing system, not all of it.  The
system in its larger sense includes the user (human or software)
getting the data together, running the program, interpreting the
output, sending the data on to another program, and dealing with
problems.  So if you have made your program easy to integrate into
this processing stream, you have improved its usefulness.  Lots of
things help: make the input data format flexible, make the output easy
to process, minimize the work required to run it.

GUI is not always better.
Graphical interfaces are great when used in the correct application.
Some functions are inherently graphical, and should be implemented as
such.  But a GUI sets a program's speed limit to be as fast as you can
point and click - fine if you're doing something once, but not so
great if you have to do it 10 times, or 10,000.  And...

The command line will always be here.
Having your program run from the command line (even as an option)
opens the way to batch processing, and the power that brings.  Now
your happy users can write a simple script to call your program as
often as they like with no effort.  And it might be called from a
database front end, or a web server, or another program, thereby
multiplying its functionality.  If you do offer a command line, make
as much functionality available as possible through command line
arguments. 

Consider making the library accessible as an API.  
Power users are not going to be satisfied with a GUI, and even command
line access can be too limiting.  If someone wants to use your program
as part of a larger system, they will need tight control over
parameters and return codes, more than they can get from the system
environment.  If you write the programming functionality as a clearly
defined API, separate from the user interface, you make your program
available to a wider audience.  A significant side benefit is that
separation of function from interface is excellent programming
practice, and will improve your program and your programming.

Best of all, offer it all.
Write your functionality as an API, then write your interface to use
only that API.  Now you can write both GUI and command line
interfaces, and your empowered customers have three ways to use your
code, depending on their application.  Three times the power!

Think of your customer.
You might just love programming in Eiffel, but you're not in a
majority.  By all means support lesser-represented environments, but
realise that you are not going to change the way people work.  If fame
and fortune is your goal, think of the middle ground.  Just don't go
too far and write a Windows program.  Just kidding!  Sort of.

Make your project easy to find.


Make your project easy to get.
Don't put obstacles in people's way.  You might want to know who is
running your lifework, but making people give their personal details
is presenting an obstruction.  You can track how many downloads there
are, and if you are really devious you could have the program send you
a postcard when it gets installed.

Release your code.
Your program is great, no doubt about it.  But you need a developer
base greater than one to conquer the world.  If you release your code,
you're not giving away all your work.  It takes so much work to read
and understand a significant code base that your problem is likely to
be getting people to download it.  If giving away their code is good
enough for Sun, SGI and Netscape, it's good enough for us.


Key points to consider.
1. You're competing to sell your project.
Time is money.  You're asking people to invest their valuable time
learning about your program and how to use it to save themselves time.
Everyone has many demands on their time, so minimize their cost in
time, or they'll go to the competition.

2. A simple program that works is better than a buggy omnibus.
The 80/20 rule applies: 80 percent of the functionality comes from 20
percent of the code.  Get the 20 percent done and working reliably,
and add the rest later.

3. Think of the overall process.
Your program, great as it is, is only part of the process.  Your user
still has to get the data together, run the program, and handle the
results.  Try to make each of these steps easy.  A power user might
incorporate your program into a system - try to build in this
capability from the start.
